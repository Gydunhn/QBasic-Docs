{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QBasic","text":"<p>QBasic (Quick Beginners All purpose Symbolic Instruction Code) es un entorno de desarrollo integrado y lenguaje de programaci\u00f3n basado en BASIC, desarrollado por Microsoft y lanzado con MS-DOS 5.0 en 1991. Fue dise\u00f1ado como una versi\u00f3n simplificada de Microsoft QuickBASIC, orientado principalmente a principiantes y estudiantes.</p>"},{"location":"#caracteristicas-principales","title":"Caracter\u00edsticas principales","text":"<ul> <li>Entorno de desarrollo integrado (IDE) con editor de texto integrado</li> <li>Herramientas de depuraci\u00f3n incorporadas</li> <li>Sintaxis sencilla y accesible para principiantes</li> <li>Soporte para gr\u00e1ficos, sonido y manejo de archivos</li> <li>Compatibilidad con todas las versiones de MS-DOS desde la 5.0</li> </ul>"},{"location":"#proposito-de-esta-documentacion","title":"Prop\u00f3sito de esta documentaci\u00f3n","text":"<p>Esta documentaci\u00f3n proporciona una gu\u00eda completa sobre QBasic, desde su historia, sintaxis b\u00e1sica, instrucciones fundamentales, hasta t\u00e9cnicas avanzadas y buenas pr\u00e1cticas de programaci\u00f3n. Est\u00e1 dise\u00f1ada tanto para principiantes que desean aprender los fundamentos de la programaci\u00f3n con QBasic, como para programadores experimentados que buscan referencias espec\u00edficas.</p>"},{"location":"#comenzando","title":"Comenzando","text":"<p>Si eres nuevo en QBasic, te recomendamos seguir estas secciones en orden:</p> <ol> <li>Historia - Conoce los or\u00edgenes y evoluci\u00f3n de QBasic</li> <li>Instalaci\u00f3n - C\u00f3mo obtener e instalar QBasic en sistemas modernos</li> <li>Sintaxis - Aprende las reglas b\u00e1sicas del lenguaje</li> <li>Instrucciones B\u00e1sicas - Conoce los comandos fundamentales</li> </ol>"},{"location":"2D/","title":"Gr\u00e1ficos 2D en QBasic","text":"<p>QBasic ofrece potentes capacidades para crear gr\u00e1ficos bidimensionales. Esta secci\u00f3n cubre desde conceptos b\u00e1sicos hasta t\u00e9cnicas avanzadas para crear gr\u00e1ficos 2D en QBasic.</p>"},{"location":"2D/#rotacion-de-graficos-2d","title":"Rotaci\u00f3n de Gr\u00e1ficos 2D","text":"<p>La rotaci\u00f3n de gr\u00e1ficos es una t\u00e9cnica fundamental para crear animaciones y efectos visuales interesantes. Aunque QBasic no tiene una funci\u00f3n nativa para rotar gr\u00e1ficos, podemos implementarla usando principios trigonom\u00e9tricos b\u00e1sicos.</p>"},{"location":"2D/#fundamentos-matematicos","title":"Fundamentos Matem\u00e1ticos","text":"<p>El principio fundamental para la rotaci\u00f3n es el siguiente: si tenemos un punto en un c\u00edrculo de radio 1 ubicado en la posici\u00f3n (1,0) y rotamos este punto un \u00e1ngulo A en sentido antihorario, sus nuevas coordenadas ser\u00e1n (COS(A), SIN(A)).</p> <pre><code>        *****\n      **  |  **\n     *    |    *\n    *_____|O____X\n    *     |     *\n     *    |    *\n      **  |  **\n        *****\n</code></pre> <p>En el diagrama anterior, si rotamos el punto X un \u00e1ngulo A, terminar\u00eda en la posici\u00f3n determinada por las coordenadas (COS(A), SIN(A)).</p>"},{"location":"2D/#rotacion-de-cualquier-punto","title":"Rotaci\u00f3n de Cualquier Punto","text":"<p>Para rotar cualquier punto (no solo los que est\u00e1n exactamente a 1 unidad del origen), necesitamos:</p> <ol> <li>Calcular la distancia del punto al origen (el radio)</li> <li>Calcular el \u00e1ngulo inicial del punto</li> <li>Sumar el \u00e1ngulo de rotaci\u00f3n al \u00e1ngulo inicial</li> <li>Calcular las nuevas coordenadas usando seno y coseno</li> </ol>"},{"location":"2D/#implementacion-en-qbasic","title":"Implementaci\u00f3n en QBasic","text":"<p>A continuaci\u00f3n se presenta un ejemplo de c\u00f3mo implementar la rotaci\u00f3n de un objeto gr\u00e1fico en QBasic:</p> <pre><code>DEFINT A-Z\n\nCONST pi! = 3.141593\n\n' Definir coordenadas del rect\u00e1ngulo a rotar, con (0,0) en el centro de la pantalla\nCONST BOXX1 = -12    ' Coordenada X izquierda\nCONST BOXX2 = 12     ' Coordenada X derecha\nCONST BOXY1 = -12    ' Coordenada Y superior\nCONST BOXY2 = 12     ' Coordenada Y inferior\n\n' Matrices para almacenar radio, \u00e1ngulo y color de cada pixel\nDIM r!(BOXX1 TO BOXX2, BOXY1 TO BOXY2)    ' Radio (distancia al origen)\nDIM a!(BOXX1 TO BOXX2, BOXY1 TO BOXY2)    ' \u00c1ngulo original\nDIM p(BOXX1 TO BOXX2, BOXY1 TO BOXY2)     ' Color del pixel\n\n' Precalcular radio y \u00e1ngulo para cada punto\nFOR x = BOXX1 TO BOXX2\n  FOR y = BOXY1 TO BOXY2\n    ' Calcular radio (distancia al origen)\n    r!(x, y) = SQR((x ^ 2) + (y ^ 2))\n    IF x &lt; 0 THEN r!(x, y) = -r!(x, y)\n\n    ' Calcular \u00e1ngulo inicial\n    IF x = 0 THEN \n      a!(x, y) = (pi / 4) \n    ELSE \n      a!(x, y) = ATN(y / x)\n    END IF\n  NEXT y\nNEXT x\n\n' Configurar modo gr\u00e1fico y sistema de coordenadas centrado\nSCREEN 7\nWINDOW (-160, 100)-(160, -100)    ' (0,0) en el centro de la pantalla\n\n' Dibujar el objeto que se va a rotar\nLINE (-12, 12)-(12, -12), 15, B    ' Rect\u00e1ngulo exterior, color 15\nLINE (-11, 11)-(11, -11), 12, B    ' Rect\u00e1ngulo interior, color 12\nLINE (-12, 12)-(12, -12), 13       ' Diagonal, color 13\nLINE (-12, -12)-(12, 12), 14       ' Diagonal, color 14\n\n' Capturar el objeto dibujado en nuestra matriz\nFOR x = BOXX1 TO BOXX2\n  FOR y = BOXY1 TO BOXY2\n    p(x, y) = POINT(x, y)    ' Guardar el color de cada pixel\n  NEXT y\nNEXT x\n\n' Esperar a que el usuario presione una tecla antes de comenzar la animaci\u00f3n\na$ = INPUT$(1)\n\n' C\u00f3digo de rotaci\u00f3n (los \u00e1ngulos est\u00e1n en RADIANES, donde 2\u03c0 rad = 360\u00b0)\ncurpage = 0    ' Para animaci\u00f3n con doble buffer\n\nDO\n  ' Rotar 360 grados en incrementos de 0.1 radianes\n  FOR angle! = 0 TO 2 * pi! STEP .1\n    SCREEN 7, , curpage, 1 - curpage    ' Configurar buffer invisible\n    CLS    ' Limpiar pantalla\n\n    ' Dibujar el objeto rotado\n    FOR x = BOXX1 TO BOXX2\n      FOR y = BOXY1 TO BOXY2\n        ' Calcular nuevas coordenadas despu\u00e9s de la rotaci\u00f3n\n        newx = COS(angle! + a!(x, y)) * r!(x, y)\n        newy = SIN(angle! + a!(x, y)) * r!(x, y)\n\n        ' Dibujar el pixel en su nueva posici\u00f3n con su color original\n        PSET (newx, newy), p(x, y)\n      NEXT y\n    NEXT x\n\n    curpage = 1 - curpage    ' Alternar entre p\u00e1ginas para doble buffer\n  NEXT angle!\nLOOP UNTIL INKEY$ = CHR$(27)    ' Continuar hasta que se presione ESC\n</code></pre>"},{"location":"2D/#explicacion-del-algoritmo","title":"Explicaci\u00f3n del Algoritmo","text":""},{"location":"2D/#paso-1-precalculo-de-variables","title":"Paso 1: Prec\u00e1lculo de Variables","text":"<p>Antes de realizar la rotaci\u00f3n, precalculamos:</p> <ul> <li>Radio (r): La distancia de cada punto al origen, usando el teorema de Pit\u00e1goras:</li> </ul> <p><code>qbasic   r!(x, y) = SQR((x ^ 2) + (y ^ 2))</code></p> <ul> <li>\u00c1ngulo inicial (a): El \u00e1ngulo que forma cada punto con respecto al eje X positivo:</li> </ul> <p><code>qbasic   a!(x, y) = ATN(y / x)    ' Si x \u2260 0</code></p>"},{"location":"2D/#paso-2-captacion-del-grafico","title":"Paso 2: Captaci\u00f3n del Gr\u00e1fico","text":"<p>Guardamos el color de cada p\u00edxel en la matriz <code>p</code>:</p> <pre><code>p(x, y) = POINT(x, y)\n</code></pre>"},{"location":"2D/#paso-3-rotacion","title":"Paso 3: Rotaci\u00f3n","text":"<p>Para cada \u00e1ngulo de rotaci\u00f3n, calculamos las nuevas coordenadas de cada punto:</p> <pre><code>newx = COS(angle! + a!(x, y)) * r!(x, y)\nnewy = SIN(angle! + a!(x, y)) * r!(x, y)\n</code></pre> <p>Estas f\u00f3rmulas aplican la regla mencionada anteriormente: las nuevas coordenadas se calculan combinando el \u00e1ngulo inicial del punto con el \u00e1ngulo de rotaci\u00f3n, y multiplicando por el radio.</p>"},{"location":"2D/#paso-4-dibujo","title":"Paso 4: Dibujo","text":"<p>Dibujamos cada punto en su nueva posici\u00f3n, manteniendo su color original:</p> <pre><code>PSET (newx, newy), p(x, y)\n</code></pre>"},{"location":"2D/#optimizaciones","title":"Optimizaciones","text":"<ol> <li> <p>Doble Buffer: La t\u00e9cnica de doble buffer (<code>SCREEN 7, , curpage, 1 - curpage</code>) reduce el parpadeo durante la animaci\u00f3n.</p> </li> <li> <p>Prec\u00e1lculo: Al calcular los radios y \u00e1ngulos iniciales una sola vez, el programa es m\u00e1s eficiente durante la animaci\u00f3n.</p> </li> <li> <p>Manejo de Casos Especiales: El programa maneja el caso especial donde x = 0, que causar\u00eda una divisi\u00f3n por cero en el c\u00e1lculo del \u00e1ngulo.</p> </li> </ol>"},{"location":"2D/#consideraciones-adicionales","title":"Consideraciones Adicionales","text":"<ul> <li> <p>Este m\u00e9todo funciona bien para dibujos peque\u00f1os. Para gr\u00e1ficos m\u00e1s grandes, considera usar otras t\u00e9cnicas como sprites o arrays de puntos.</p> </li> <li> <p>La rotaci\u00f3n se realiza alrededor del punto (0,0). Para rotar alrededor de un punto diferente, primero debes traducir las coordenadas.</p> </li> <li> <p>Se pueden lograr efectos interesantes combinando rotaci\u00f3n con escalado o traslaci\u00f3n.</p> </li> </ul>"},{"location":"2D/#sistemas-de-coordenadas-y-rotacion","title":"Sistemas de Coordenadas y Rotaci\u00f3n","text":"<p>Una limitaci\u00f3n aparente al trabajar con rotaci\u00f3n 2D en QBasic es que la rotaci\u00f3n debe realizarse alrededor del origen del sistema de coordenadas (0,0), que en QBasic se encuentra en la esquina superior izquierda de la pantalla. Sin embargo, podemos superar esta limitaci\u00f3n mediante el uso de un sistema de coordenadas virtual.</p>"},{"location":"2D/#coordenadas-fisicas-vs-coordenadas-virtuales","title":"Coordenadas F\u00edsicas vs. Coordenadas Virtuales","text":"<p>Para rotar objetos alrededor de cualquier punto de la pantalla, podemos implementar dos sistemas de coordenadas:</p> <ol> <li> <p>Sistema de Coordenadas F\u00edsicas: El sistema nativo de QBasic donde (0,0) est\u00e1 en la esquina superior izquierda.</p> </li> <li> <p>Sistema de Coordenadas Virtuales: Un sistema definido por nosotros donde el origen (0,0) puede estar en cualquier lugar de la pantalla.</p> </li> </ol> <p>Mediante la definici\u00f3n de variables que contengan la ubicaci\u00f3n X e Y de nuestro origen virtual, podemos transformar las coordenadas calculadas relativas al origen virtual a coordenadas f\u00edsicas de pantalla.</p>"},{"location":"2D/#formulas-de-rotacion-2d","title":"F\u00f3rmulas de Rotaci\u00f3n 2D","text":"<p>Las f\u00f3rmulas trigonom\u00e9tricas para rotar un par de coordenadas (x, y) son:</p> <pre><code>x = (x_anterior * COS(angulo)) + (y_anterior * SIN(angulo))\ny = (y_anterior * COS(angulo)) - (x_anterior * SIN(angulo))\n</code></pre> <p>Donde:</p> <ul> <li><code>x_anterior</code> y <code>y_anterior</code> son las coordenadas originales antes de la rotaci\u00f3n</li> <li><code>angulo</code> es el \u00e1ngulo de rotaci\u00f3n en radianes</li> <li><code>x</code> e <code>y</code> son las nuevas coordenadas despu\u00e9s de la rotaci\u00f3n</li> </ul>"},{"location":"2D/#direccion-de-rotacion","title":"Direcci\u00f3n de Rotaci\u00f3n","text":"<ul> <li>Para una rotaci\u00f3n en sentido horario, utiliza un \u00e1ngulo negativo (ejemplo: -45 grados)</li> <li>Para una rotaci\u00f3n en sentido antihorario, utiliza un \u00e1ngulo positivo (ejemplo: 45 grados)</li> </ul>"},{"location":"2D/#conversion-entre-grados-y-radianes","title":"Conversi\u00f3n entre Grados y Radianes","text":"<p>Las funciones trigonom\u00e9tricas en QBasic requieren que el \u00e1ngulo est\u00e9 en radianes, pero es m\u00e1s intuitivo pensar en grados. Las f\u00f3rmulas de conversi\u00f3n son:</p> <pre><code>Radianes = Grados * 0.017453  ' Aproximadamente Grados * PI / 180\nGrados = Radianes * 57.29577  ' Aproximadamente Radianes * 180 / PI\n</code></pre>"},{"location":"2D/#ejemplo-de-rotacion-alrededor-de-un-punto-arbitrario","title":"Ejemplo de Rotaci\u00f3n Alrededor de un Punto Arbitrario","text":"<p>El siguiente ejemplo muestra c\u00f3mo rotar un p\u00edxel alrededor de un punto arbitrario en la pantalla:</p> <pre><code>SCREEN 9  ' Establecer modo gr\u00e1fico de alta resoluci\u00f3n\n\n' Definir coordenadas del origen virtual\nVX = 250  ' Coordenada X del origen virtual\nVY = 150  ' Coordenada Y del origen virtual\n\n' Coordenadas iniciales del punto a rotar (relativas al origen virtual)\nX = 100\nY = 100\n\nRotacion = 0           ' Contador de rotaci\u00f3n\nAngulo = -5 * 0.017453 ' 5 grados en sentido horario (convertidos a radianes)\n\nDO\n  ' Guardar coordenadas actuales\n  AnteriorX = X\n  AnteriorY = Y\n\n  ' Calcular nuevas coordenadas rotadas\n  X = (AnteriorX * COS(Angulo)) + (AnteriorY * SIN(Angulo))\n  Y = (AnteriorY * COS(Angulo)) - (AnteriorX * SIN(Angulo))\n\n  ' Dibujar en la pantalla (convertir de coordenadas virtuales a f\u00edsicas)\n  ' Multiplicar Y por 0.75 para compensar la relaci\u00f3n de aspecto de los p\u00edxeles\n  PSET (X + VX, (0.75 * Y) + VY), 15\n\n  ' Dibujar un c\u00edrculo en la posici\u00f3n actual\n  CIRCLE (X + VX, (0.75 * Y) + VY), 5, 15\n\n  ' Incrementar el contador de rotaci\u00f3n\n  Rotacion = Rotacion + 5\nLOOP WHILE Rotacion &lt; 360  ' Completar una rotaci\u00f3n completa\n</code></pre>"},{"location":"2D/#consideraciones-importantes","title":"Consideraciones Importantes","text":"<ol> <li> <p>Relaci\u00f3n de Aspecto: Para crear un patr\u00f3n circular (en lugar de el\u00edptico) en muchos modos gr\u00e1ficos de QBasic, es necesario ajustar la coordenada Y multiplic\u00e1ndola por un factor (como 0.75 en el ejemplo) para compensar la forma no cuadrada de los p\u00edxeles.</p> </li> <li> <p>Tipos de Variables: Al utilizar funciones trigonom\u00e9tricas, el argumento del \u00e1ngulo debe expresarse como tipo Single y en radianes para obtener resultados precisos.</p> </li> <li> <p>Rendimiento: Para animaciones m\u00e1s complejas, considera usar tablas precalculadas de seno y coseno para evitar c\u00e1lculos trigonom\u00e9tricos repetitivos.</p> </li> </ol>"},{"location":"2D/#aplicaciones-practicas","title":"Aplicaciones Pr\u00e1cticas","text":"<p>La rotaci\u00f3n 2D puede utilizarse para crear:</p> <ul> <li>Diales y medidores en simulaciones</li> <li>Manecillas de relojes en aplicaciones de tiempo</li> <li>Objetos giratorios en juegos</li> <li>Part\u00edculas y efectos visuales</li> <li>Sistemas planetarios simples</li> </ul>"},{"location":"2D/#conclusion","title":"Conclusi\u00f3n","text":"<p>La rotaci\u00f3n de gr\u00e1ficos 2D en QBasic demuestra c\u00f3mo los principios matem\u00e1ticos b\u00e1sicos pueden utilizarse para crear efectos visuales complejos. Aunque QBasic no tiene funciones nativas para rotaci\u00f3n, con un poco de trigonometr\u00eda podemos implementar esta funcionalidad de manera eficiente.</p> <p>Estos conceptos sirven como base para entender t\u00e9cnicas m\u00e1s avanzadas en gr\u00e1ficos por computadora, y son muy \u00fatiles para crear juegos, simulaciones o demostraciones visuales en QBasic.</p>"},{"location":"3D/","title":"Gr\u00e1ficos 3D en QBasic","text":"<p>Aunque QBasic no fue dise\u00f1ado originalmente para gr\u00e1ficos tridimensionales, es posible implementar t\u00e9cnicas b\u00e1sicas de representaci\u00f3n 3D. Este cap\u00edtulo explora c\u00f3mo crear efectos tridimensionales usando QBasic.</p>"},{"location":"3D/#conceptos-basicos","title":"Conceptos B\u00e1sicos","text":""},{"location":"3D/#sistemas-de-coordenadas-3d","title":"Sistemas de Coordenadas 3D","text":"<p>En un espacio tridimensional, necesitamos tres coordenadas para representar un punto:</p> <ul> <li>X: posici\u00f3n horizontal (izquierda/derecha)</li> <li>Y: posici\u00f3n vertical (arriba/abajo)</li> <li>Z: profundidad (cerca/lejos)</li> </ul> <p>Para visualizar objetos 3D en una pantalla 2D, necesitamos proyectar estos puntos 3D en un plano 2D, que es nuestra pantalla.</p>"},{"location":"3D/#proyeccion","title":"Proyecci\u00f3n","text":"<p>La proyecci\u00f3n m\u00e1s simple es la proyecci\u00f3n paralela (ortogr\u00e1fica), donde simplemente ignoramos la coordenada Z:</p> <pre><code>' Convertir coordenadas 3D a 2D con proyecci\u00f3n ortogr\u00e1fica\nScreenX = X + OriginX\nScreenY = Y + OriginY\n</code></pre> <p>Sin embargo, esto no produce un efecto realista de profundidad. Para ello, necesitamos una proyecci\u00f3n en perspectiva:</p> <pre><code>' Convertir coordenadas 3D a 2D con proyecci\u00f3n en perspectiva\nScale = 200 / (Z + 200)  ' Factor de escala basado en la profundidad\nScreenX = X * Scale + OriginX\nScreenY = Y * Scale + OriginY\n</code></pre>"},{"location":"3D/#representacion-de-objetos-3d","title":"Representaci\u00f3n de Objetos 3D","text":""},{"location":"3D/#puntos-y-lineas","title":"Puntos y L\u00edneas","text":"<p>La forma m\u00e1s b\u00e1sica de representar objetos 3D es mediante puntos y l\u00edneas que forman wireframes (mallas de alambre).</p> <pre><code>' Dibujar un punto 3D\nSUB DrawPoint3D (X, Y, Z, Color)\n    Scale = 200 / (Z + 200)\n    ScreenX = X * Scale + 160  ' Centro horizontal de la pantalla\n    ScreenY = Y * Scale + 100  ' Centro vertical de la pantalla\n    PSET (ScreenX, ScreenY), Color\nEND SUB\n\n' Dibujar una l\u00ednea 3D\nSUB DrawLine3D (X1, Y1, Z1, X2, Y2, Z2, Color)\n    Scale1 = 200 / (Z1 + 200)\n    ScreenX1 = X1 * Scale1 + 160\n    ScreenY1 = Y1 * Scale1 + 100\n\n    Scale2 = 200 / (Z2 + 200)\n    ScreenX2 = X2 * Scale2 + 160\n    ScreenY2 = Y2 * Scale2 + 100\n\n    LINE (ScreenX1, ScreenY1)-(ScreenX2, ScreenY2), Color\nEND SUB\n</code></pre>"},{"location":"3D/#ejemplo-cubo-wireframe","title":"Ejemplo: Cubo Wireframe","text":"<p>Aqu\u00ed hay un ejemplo de c\u00f3mo dibujar un cubo simple en 3D:</p> <pre><code>SCREEN 13\nCLS\n\nTYPE Point3D\n    X AS SINGLE\n    Y AS SINGLE\n    Z AS SINGLE\nEND TYPE\n\n' Definir los v\u00e9rtices del cubo\nDIM CubeVertices(7) AS Point3D\n\n' Cara frontal (Z = 50)\nCubeVertices(0).X = -30: CubeVertices(0).Y = -30: CubeVertices(0).Z = 50\nCubeVertices(1).X = 30: CubeVertices(1).Y = -30: CubeVertices(1).Z = 50\nCubeVertices(2).X = 30: CubeVertices(2).Y = 30: CubeVertices(2).Z = 50\nCubeVertices(3).X = -30: CubeVertices(3).Y = 30: CubeVertices(3).Z = 50\n\n' Cara trasera (Z = 110)\nCubeVertices(4).X = -30: CubeVertices(4).Y = -30: CubeVertices(4).Z = 110\nCubeVertices(5).X = 30: CubeVertices(5).Y = -30: CubeVertices(5).Z = 110\nCubeVertices(6).X = 30: CubeVertices(6).Y = 30: CubeVertices(6).Z = 110\nCubeVertices(7).X = -30: CubeVertices(7).Y = 30: CubeVertices(7).Z = 110\n\n' Dibujar las aristas del cubo\nCOLOR 15\n\n' Cara frontal\nDrawLine3D CubeVertices(0).X, CubeVertices(0).Y, CubeVertices(0).Z, CubeVertices(1).X, CubeVertices(1).Y, CubeVertices(1).Z, 15\nDrawLine3D CubeVertices(1).X, CubeVertices(1).Y, CubeVertices(1).Z, CubeVertices(2).X, CubeVertices(2).Y, CubeVertices(2).Z, 15\nDrawLine3D CubeVertices(2).X, CubeVertices(2).Y, CubeVertices(2).Z, CubeVertices(3).X, CubeVertices(3).Y, CubeVertices(3).Z, 15\nDrawLine3D CubeVertices(3).X, CubeVertices(3).Y, CubeVertices(3).Z, CubeVertices(0).X, CubeVertices(0).Y, CubeVertices(0).Z, 15\n\n' Cara trasera\nDrawLine3D CubeVertices(4).X, CubeVertices(4).Y, CubeVertices(4).Z, CubeVertices(5).X, CubeVertices(5).Y, CubeVertices(5).Z, 15\nDrawLine3D CubeVertices(5).X, CubeVertices(5).Y, CubeVertices(5).Z, CubeVertices(6).X, CubeVertices(6).Y, CubeVertices(6).Z, 15\nDrawLine3D CubeVertices(6).X, CubeVertices(6).Y, CubeVertices(6).Z, CubeVertices(7).X, CubeVertices(7).Y, CubeVertices(7).Z, 15\nDrawLine3D CubeVertices(7).X, CubeVertices(7).Y, CubeVertices(7).Z, CubeVertices(4).X, CubeVertices(4).Y, CubeVertices(4).Z, 15\n\n' Conexiones entre caras\nDrawLine3D CubeVertices(0).X, CubeVertices(0).Y, CubeVertices(0).Z, CubeVertices(4).X, CubeVertices(4).Y, CubeVertices(4).Z, 15\nDrawLine3D CubeVertices(1).X, CubeVertices(1).Y, CubeVertices(1).Z, CubeVertices(5).X, CubeVertices(5).Y, CubeVertices(5).Z, 15\nDrawLine3D CubeVertices(2).X, CubeVertices(2).Y, CubeVertices(2).Z, CubeVertices(6).X, CubeVertices(6).Y, CubeVertices(6).Z, 15\nDrawLine3D CubeVertices(3).X, CubeVertices(3).Y, CubeVertices(3).Z, CubeVertices(7).X, CubeVertices(7).Y, CubeVertices(7).Z, 15\n\n' Subrutina para dibujar l\u00ednea 3D\nSUB DrawLine3D (X1, Y1, Z1, X2, Y2, Z2, Color)\n    Scale1 = 200 / (Z1 + 200)\n    ScreenX1 = X1 * Scale1 + 160\n    ScreenY1 = Y1 * Scale1 + 100\n\n    Scale2 = 200 / (Z2 + 200)\n    ScreenX2 = X2 * Scale2 + 160\n    ScreenY2 = Y2 * Scale2 + 100\n\n    LINE (ScreenX1, ScreenY1)-(ScreenX2, ScreenY2), Color\nEND SUB\n</code></pre>"},{"location":"3D/#rotacion-3d","title":"Rotaci\u00f3n 3D","text":"<p>Para animar objetos 3D, necesitamos rotarlos. Las matrices de rotaci\u00f3n son fundamentales para esto:</p>"},{"location":"3D/#rotacion-alrededor-del-eje-x","title":"Rotaci\u00f3n alrededor del eje X","text":"<pre><code>' Rotar un punto alrededor del eje X\nSUB RotateX (Point() AS Point3D, Angle AS SINGLE)\n    Rad = Angle * 3.14159 / 180  ' Convertir a radianes\n    FOR i = 0 TO UBOUND(Point)\n        Y = Point(i).Y\n        Z = Point(i).Z\n        Point(i).Y = Y * COS(Rad) - Z * SIN(Rad)\n        Point(i).Z = Y * SIN(Rad) + Z * COS(Rad)\n    NEXT i\nEND SUB\n</code></pre>"},{"location":"3D/#rotacion-alrededor-del-eje-y","title":"Rotaci\u00f3n alrededor del eje Y","text":"<pre><code>' Rotar un punto alrededor del eje Y\nSUB RotateY (Point() AS Point3D, Angle AS SINGLE)\n    Rad = Angle * 3.14159 / 180\n    FOR i = 0 TO UBOUND(Point)\n        X = Point(i).X\n        Z = Point(i).Z\n        Point(i).X = X * COS(Rad) + Z * SIN(Rad)\n        Point(i).Z = -X * SIN(Rad) + Z * COS(Rad)\n    NEXT i\nEND SUB\n</code></pre>"},{"location":"3D/#rotacion-alrededor-del-eje-z","title":"Rotaci\u00f3n alrededor del eje Z","text":"<pre><code>' Rotar un punto alrededor del eje Z\nSUB RotateZ (Point() AS Point3D, Angle AS SINGLE)\n    Rad = Angle * 3.14159 / 180\n    FOR i = 0 TO UBOUND(Point)\n        X = Point(i).X\n        Y = Point(i).Y\n        Point(i).X = X * COS(Rad) - Y * SIN(Rad)\n        Point(i).Y = X * SIN(Rad) + Y * COS(Rad)\n    NEXT i\nEND SUB\n</code></pre>"},{"location":"3D/#tecnicas-avanzadas","title":"T\u00e9cnicas Avanzadas","text":""},{"location":"3D/#eliminacion-de-caras-ocultas","title":"Eliminaci\u00f3n de Caras Ocultas","text":"<p>Para objetos m\u00e1s realistas, necesitamos eliminar las caras que no ser\u00edan visibles desde el punto de vista del observador:</p> <pre><code>' Determinar si una cara es visible\nFUNCTION IsVisible (A AS Point3D, B AS Point3D, C AS Point3D) AS INTEGER\n    ' Producto vectorial para determinar la normal de la cara\n    Nx = (B.Y - A.Y) * (C.Z - A.Z) - (B.Z - A.Z) * (C.Y - A.Y)\n    Ny = (B.Z - A.Z) * (C.X - A.X) - (B.X - A.X) * (C.Z - A.Z)\n    Nz = (B.X - A.X) * (C.Y - A.Y) - (B.Y - A.Y) * (C.X - A.X)\n\n    ' Producto escalar con el vector de visi\u00f3n (0, 0, -1)\n    IF Nz &gt; 0 THEN\n        IsVisible = 1  ' La cara es visible\n    ELSE\n        IsVisible = 0  ' La cara est\u00e1 oculta\n    END IF\nEND FUNCTION\n</code></pre>"},{"location":"3D/#sombreado-basico","title":"Sombreado B\u00e1sico","text":"<p>El sombreado puede a\u00f1adir realismo. Una t\u00e9cnica simple es el sombreado plano basado en la orientaci\u00f3n de la cara:</p> <pre><code>' Calcular el tono de color basado en la orientaci\u00f3n\nFUNCTION GetShade (A AS Point3D, B AS Point3D, C AS Point3D) AS INTEGER\n    ' Calcular la normal de la cara\n    Nx = (B.Y - A.Y) * (C.Z - A.Z) - (B.Z - A.Z) * (C.Y - A.Y)\n    Ny = (B.Z - A.Z) * (C.X - A.X) - (B.X - A.X) * (C.Z - A.Z)\n    Nz = (B.X - A.X) * (C.Y - A.Y) - (B.Y - A.Y) * (C.X - A.X)\n\n    ' Normalizar\n    Length = SQR(Nx * Nx + Ny * Ny + Nz * Nz)\n    Nx = Nx / Length\n    Ny = Ny / Length\n    Nz = Nz / Length\n\n    ' Producto escalar con la direcci\u00f3n de la luz (0, 0, -1)\n    Intensity = -Nz\n\n    ' Convertir a \u00edndice de color (0-15 en modo EGA)\n    IF Intensity &gt; 0 THEN\n        GetShade = 7 + INT(Intensity * 8)  ' De 7 a 15\n    ELSE\n        GetShade = 7 + INT(Intensity * 7)  ' De 0 a 7\n    END IF\nEND FUNCTION\n</code></pre>"},{"location":"3D/#ejemplo-completo-cubo-giratorio-con-caras-coloreadas","title":"Ejemplo Completo: Cubo Giratorio con Caras Coloreadas","text":"<pre><code>SCREEN 13\nCLS\n\nTYPE Point3D\n    X AS SINGLE\n    Y AS SINGLE\n    Z AS SINGLE\nEND TYPE\n\nTYPE Face\n    Vertex(3) AS INTEGER  ' \u00cdndices de los v\u00e9rtices\n    Color AS INTEGER\nEND TYPE\n\n' Definir v\u00e9rtices del cubo\nDIM Vertices(7) AS Point3D\nVertices(0).X = -30: Vertices(0).Y = -30: Vertices(0).Z = -30\nVertices(1).X = 30: Vertices(1).Y = -30: Vertices(1).Z = -30\nVertices(2).X = 30: Vertices(2).Y = 30: Vertices(2).Z = -30\nVertices(3).X = -30: Vertices(3).Y = 30: Vertices(3).Z = -30\nVertices(4).X = -30: Vertices(4).Y = -30: Vertices(4).Z = 30\nVertices(5).X = 30: Vertices(5).Y = -30: Vertices(5).Z = 30\nVertices(6).X = 30: Vertices(6).Y = 30: Vertices(6).Z = 30\nVertices(7).X = -30: Vertices(7).Y = 30: Vertices(7).Z = 30\n\n' Definir caras (cada cara es un cuadril\u00e1tero)\nDIM Faces(5) AS Face\n' Frente\nFaces(0).Vertex(0) = 0: Faces(0).Vertex(1) = 1: Faces(0).Vertex(2) = 2: Faces(0).Vertex(3) = 3\nFaces(0).Color = 9 ' Azul claro\n' Atr\u00e1s\nFaces(1).Vertex(0) = 5: Faces(1).Vertex(1) = 4: Faces(1).Vertex(2) = 7: Faces(1).Vertex(3) = 6\nFaces(1).Color = 10 ' Verde claro\n' Izquierda\nFaces(2).Vertex(0) = 4: Faces(2).Vertex(1) = 0: Faces(2).Vertex(2) = 3: Faces(2).Vertex(3) = 7\nFaces(2).Color = 12 ' Rojo claro\n' Derecha\nFaces(3).Vertex(0) = 1: Faces(3).Vertex(1) = 5: Faces(3).Vertex(2) = 6: Faces(3).Vertex(3) = 2\nFaces(3).Color = 14 ' Amarillo\n' Arriba\nFaces(4).Vertex(0) = 3: Faces(4).Vertex(1) = 2: Faces(4).Vertex(2) = 6: Faces(4).Vertex(3) = 7\nFaces(4).Color = 11 ' Cian claro\n' Abajo\nFaces(5).Vertex(0) = 4: Faces(5).Vertex(1) = 5: Faces(5).Vertex(2) = 1: Faces(5).Vertex(3) = 0\nFaces(5).Color = 13 ' Magenta\n\n' Animaci\u00f3n del cubo giratorio\nDO\n    CLS\n\n    ' Rotar el cubo\n    RotateX Vertices(), 1\n    RotateY Vertices(), 1\n    RotateZ Vertices(), 0.5\n\n    ' Dibujar caras visibles (eliminaci\u00f3n de caras ocultas)\n    FOR f = 0 TO 5\n        v0 = Faces(f).Vertex(0)\n        v1 = Faces(f).Vertex(1)\n        v2 = Faces(f).Vertex(2)\n\n        ' Comprobar si la cara es visible\n        IF IsVisible(Vertices(v0), Vertices(v1), Vertices(v2)) THEN\n            ' Proyectar v\u00e9rtices y dibujar la cara\n            DIM ScreenPoints(3, 1) AS INTEGER  ' X,Y para cada v\u00e9rtice\n\n            FOR v = 0 TO 3\n                vIdx = Faces(f).Vertex(v)\n                ScreenPoints(v, 0) = Project_X(Vertices(vIdx))\n                ScreenPoints(v, 1) = Project_Y(Vertices(vIdx))\n            NEXT v\n\n            ' Dibujar la cara como pol\u00edgono relleno\n            LINE (ScreenPoints(0, 0), ScreenPoints(0, 1))-(ScreenPoints(1, 0), ScreenPoints(1, 1)), Faces(f).Color\n            LINE -(ScreenPoints(2, 0), ScreenPoints(2, 1)), Faces(f).Color\n            LINE -(ScreenPoints(3, 0), ScreenPoints(3, 1)), Faces(f).Color\n            LINE -(ScreenPoints(0, 0), ScreenPoints(0, 1)), Faces(f).Color\n\n            ' Rellenar la cara (simplificado)\n            PAINT (ScreenPoints(0, 0) + 1, ScreenPoints(0, 1) + 1), Faces(f).Color, Faces(f).Color\n        END IF\n    NEXT f\n\n    ' Control de velocidad\n    FOR Delay = 1 TO 5000: NEXT Delay\n\nLOOP UNTIL INKEY$ &lt;&gt; \"\"\n\n' Funciones y subrutinas\n\nFUNCTION Project_X (P AS Point3D) AS INTEGER\n    Scale = 200 / (P.Z + 350)\n    Project_X = P.X * Scale + 160\nEND FUNCTION\n\nFUNCTION Project_Y (P AS Point3D) AS INTEGER\n    Scale = 200 / (P.Z + 350)\n    Project_Y = P.Y * Scale + 100\nEND FUNCTION\n\nSUB RotateX (Points() AS Point3D, Angle AS SINGLE)\n    Rad = Angle * 3.14159 / 180\n    FOR i = 0 TO UBOUND(Points)\n        Y = Points(i).Y\n        Z = Points(i).Z\n        Points(i).Y = Y * COS(Rad) - Z * SIN(Rad)\n        Points(i).Z = Y * SIN(Rad) + Z * COS(Rad)\n    NEXT i\nEND SUB\n\nSUB RotateY (Points() AS Point3D, Angle AS SINGLE)\n    Rad = Angle * 3.14159 / 180\n    FOR i = 0 TO UBOUND(Points)\n        X = Points(i).X\n        Z = Points(i).Z\n        Points(i).X = X * COS(Rad) + Z * SIN(Rad)\n        Points(i).Z = -X * SIN(Rad) + Z * COS(Rad)\n    NEXT i\nEND SUB\n\nSUB RotateZ (Points() AS Point3D, Angle AS SINGLE)\n    Rad = Angle * 3.14159 / 180\n    FOR i = 0 TO UBOUND(Points)\n        X = Points(i).X\n        Y = Points(i).Y\n        Points(i).X = X * COS(Rad) - Y * SIN(Rad)\n        Points(i).Y = X * SIN(Rad) + Y * COS(Rad)\n    NEXT i\nEND SUB\n\nFUNCTION IsVisible (A AS Point3D, B AS Point3D, C AS Point3D) AS INTEGER\n    Nx = (B.Y - A.Y) * (C.Z - A.Z) - (B.Z - A.Z) * (C.Y - A.Y)\n    Ny = (B.Z - A.Z) * (C.X - A.X) - (B.X - A.X) * (C.Z - A.Z)\n    Nz = (B.X - A.X) * (C.Y - A.Y) - (B.Y - A.Y) * (C.X - A.X)\n\n    ' Producto escalar con el vector de visi\u00f3n (0, 0, -1)\n    IsVisible = (Nz &lt; 0)\nEND FUNCTION\n</code></pre>"},{"location":"3D/#optimizaciones","title":"Optimizaciones","text":"<p>El renderizado 3D en QBasic puede ser lento. Algunas optimizaciones incluyen:</p> <ol> <li>Usar tipos de datos enteros cuando sea posible</li> <li>Precalcular valores trigonom\u00e9tricos para \u00e1ngulos comunes</li> <li>Limitar la complejidad de los objetos 3D</li> <li>Usar mallas de alambre en lugar de pol\u00edgonos rellenos</li> <li>Optimizar la eliminaci\u00f3n de caras ocultas</li> </ol>"},{"location":"3D/#conclusion","title":"Conclusi\u00f3n","text":"<p>Aunque QBasic tiene limitaciones para gr\u00e1ficos 3D avanzados, es posible crear representaciones tridimensionales impresionantes utilizando las t\u00e9cnicas adecuadas. Estos conceptos proporcionan la base para crear entornos 3D simples, y comprender estos principios es fundamental para desarrollar aplicaciones gr\u00e1ficas m\u00e1s complejas.</p>"},{"location":"3D/#conceptos-avanzados-de-3d","title":"Conceptos Avanzados de 3D","text":"<p>A continuaci\u00f3n exploramos conceptos m\u00e1s avanzados de gr\u00e1ficos 3D en QBasic, basados en el tutorial de Matt Bross.</p>"},{"location":"3D/#proyeccion-en-perspectiva","title":"Proyecci\u00f3n en Perspectiva","text":"<p>La conversi\u00f3n de coordenadas 3D a 2D es el fundamento de cualquier sistema de gr\u00e1ficos tridimensionales. La f\u00f3rmula de proyecci\u00f3n en perspectiva m\u00e1s eficiente es:</p> <pre><code>SX = X / Z\nSY = Y / Z\n</code></pre> <p>Donde SX y SY son las coordenadas de pantalla resultantes.</p> <p>En una implementaci\u00f3n real, necesitamos ajustar estas coordenadas para centrarlas en la pantalla y tener en cuenta la posici\u00f3n del observador:</p> <pre><code>SX = ((X - VX) / (Z - VZ)) + (SRX / 2)\nSY = ((Y - VY) / (Z - VZ)) + (SRY / 2)\n</code></pre> <p>Donde:</p> <ul> <li>VX, VY, VZ son las coordenadas del observador</li> <li>SRX, SRY son la resoluci\u00f3n de la pantalla</li> </ul>"},{"location":"3D/#rotacion-y-traslacion","title":"Rotaci\u00f3n y Traslaci\u00f3n","text":"<p>La traslaci\u00f3n es el movimiento de todos los puntos de un objeto en una direcci\u00f3n constante. Se implementa sumando un valor a cada coordenada:</p> <pre><code>SX = ((TX + X - VX) / (TZ + Z - VZ)) + (SRX / 2)\nSY = ((TY + Y - VY) / (TZ + Z - VZ)) + (SRY / 2)\n</code></pre> <p>Donde TX, TY, TZ son los valores de traslaci\u00f3n.</p> <p>La rotaci\u00f3n es m\u00e1s compleja y requiere el uso de coordenadas esf\u00e9ricas o matrices de rotaci\u00f3n. Las rotaciones b\u00e1sicas alrededor de los tres ejes principales pueden implementarse de la siguiente manera:</p> <pre><code>' Rotaci\u00f3n alrededor del eje Y\nTEMPX = X * COS(R2) - Z * SIN(R2)\nTEMPZ = X * SIN(R2) + Z * COS(R2)\n\n' Rotaci\u00f3n alrededor del eje X\nTEMPZ2 = TEMPZ * COS(R1) - Y * SIN(R1)\nTEMPY = TEMPZ * SIN(R1) + Y * COS(R1)\n\n' Rotaci\u00f3n alrededor del eje Z\nTEMPX2 = TEMPX * COS(R3) + TEMPY * SIN(R3)\nTEMPY2 = TEMPY * COS(R3) - TEMPX * SIN(R3)\n</code></pre>"},{"location":"3D/#sombreado-y-renderizado","title":"Sombreado y Renderizado","text":"<p>Las t\u00e9cnicas de sombreado avanzadas mejoran significativamente la calidad visual de los gr\u00e1ficos 3D.</p>"},{"location":"3D/#vectores-normales","title":"Vectores Normales","text":"<p>Un vector normal es un vector perpendicular a una superficie. Para calcular el vector normal de un tri\u00e1ngulo con puntos P1, P2 y P3:</p> <ol> <li>Calcular vectores entre puntos:</li> </ol> <p>```qbasic    Vector_A.X = P2.X - P1.X    Vector_A.Y = P2.Y - P1.Y    Vector_A.Z = P2.Z - P1.Z</p> <p>Vector_B.X = P3.X - P1.X    Vector_B.Y = P3.Y - P1.Y    Vector_B.Z = P3.Z - P1.Z    ```</p> <ol> <li>Calcular el producto vectorial:</li> </ol> <p><code>qbasic    Normal.X = (Vector_A.Y * Vector_B.Z) - (Vector_A.Z * Vector_B.Y)    Normal.Y = (Vector_A.Z * Vector_B.X) - (Vector_A.X * Vector_B.Z)    Normal.Z = (Vector_A.X * Vector_B.Y) - (Vector_A.Y * Vector_B.X)</code></p>"},{"location":"3D/#tecnica-de-eliminacion-de-caras-ocultas","title":"Tecnica de Eliminaci\u00f3n de Caras Ocultas","text":"<p>La t\u00e9cnica de \"backface culling\" elimina las caras que no son visibles para el observador, mejorando considerablemente el rendimiento. Una cara no es visible si su vector normal apunta en direcci\u00f3n opuesta al observador.</p> <pre><code>' Determinar si un pol\u00edgono es visible\ncull1 = X3 * ((Y1 * Z2) - (Z1 * Y2))\ncull2 = Y3 * ((X1 * Z2) - (Z1 * X2))\ncull3 = Z3 * ((X1 * Y2) - (Y1 * X2))\n\nIF cull1 + cull2 + cull3 &lt; 0 THEN\n    ' El pol\u00edgono es visible\nELSE\n    ' El pol\u00edgono no es visible\nEND IF\n</code></pre>"},{"location":"3D/#sombreado-de-lambert","title":"Sombreado de Lambert","text":"<p>La Ley de Lambert permite calcular la intensidad de luz en un pol\u00edgono bas\u00e1ndose en el \u00e1ngulo entre su vector normal y la direcci\u00f3n de la luz:</p> <pre><code>' Light es un vector normalizado que apunta hacia la fuente de luz\n' Normal es el vector normal del pol\u00edgono\n\nIntensidad = (Normal.X * Light.X + Normal.Y * Light.Y + Normal.Z * Light.Z)\n\nIF Intensidad &lt; 0 THEN Intensidad = 0\n</code></pre>"},{"location":"3D/#mapeo-de-texturas","title":"Mapeo de Texturas","text":"<p>El mapeo de texturas es una t\u00e9cnica que a\u00f1ade im\u00e1genes 2D a superficies 3D para aumentar el realismo. El m\u00e9todo m\u00e1s simple es el mapeo de texturas af\u00edn:</p> <ol> <li>Calcular las coordenadas UV (coordenadas de textura) para cada v\u00e9rtice del pol\u00edgono</li> <li>Interpolar linealmente estas coordenadas a trav\u00e9s de la superficie</li> <li>Buscar el color correspondiente en la textura y aplicarlo al p\u00edxel en la pantalla</li> </ol> <p>El mapeo de texturas b\u00e1sico puede implementarse con el siguiente algoritmo:</p> <pre><code>' Para cada p\u00edxel dentro del pol\u00edgono\nFOR y = YMin TO YMax\n    FOR x = XMin TO XMax\n        ' Calcular coordenadas UV usando interpolaci\u00f3n\n        U = U1 + (x - X1) * (U2 - U1) / (X2 - X1)\n        V = V1 + (y - Y1) * (V2 - V1) / (Y2 - Y1)\n\n        ' Obtener color de la textura\n        ColorTextura = POINT(U * AnchoTextura, V * AltoTextura)\n\n        ' Dibujar p\u00edxel con el color de la textura\n        PSET (x, y), ColorTextura\n    NEXT x\nNEXT y\n</code></pre>"},{"location":"3D/#algoritmo-del-pintor","title":"Algoritmo del Pintor","text":"<p>El Algoritmo del Pintor es una t\u00e9cnica simple para resolver el problema de visibilidad. Consiste en dibujar los pol\u00edgonos desde los m\u00e1s lejanos hasta los m\u00e1s cercanos al observador, similar a como un pintor pintar\u00eda un cuadro:</p> <ol> <li>Calcular la profundidad promedio (Z) de cada pol\u00edgono</li> <li>Ordenar los pol\u00edgonos por su valor Z, de mayor a menor</li> <li>Dibujar los pol\u00edgonos en ese orden</li> </ol> <pre><code>' Calcular la profundidad promedio de cada pol\u00edgono\nFOR i = 1 TO NumPoligonos\n    Poligono(i).Z_Promedio = (Punto(Poligono(i).P1).Z + Punto(Poligono(i).P2).Z + Punto(Poligono(i).P3).Z) / 3\nNEXT i\n\n' Ordenar pol\u00edgonos (algoritmo de burbuja simplificado)\nFOR i = 1 TO NumPoligonos\n    FOR j = 1 TO NumPoligonos - i\n        IF Poligono(j).Z_Promedio &lt; Poligono(j+1).Z_Promedio THEN\n            SWAP Poligono(j), Poligono(j+1)\n        END IF\n    NEXT j\nNEXT i\n\n' Dibujar pol\u00edgonos en orden\nFOR i = 1 TO NumPoligonos\n    ' C\u00f3digo para dibujar el pol\u00edgono\nNEXT i\n</code></pre>"},{"location":"3D/#z-buffer","title":"Z-Buffer","text":"<p>El Z-Buffer es una t\u00e9cnica m\u00e1s avanzada que el Algoritmo del Pintor para resolver el problema de visibilidad. Mantiene un buffer (matriz) con la profundidad de cada p\u00edxel dibujado:</p> <pre><code>' Inicializar Z-Buffer con valores m\u00e1ximos\nFOR y = 0 TO AltoVentana\n    FOR x = 0 TO AnchoVentana\n        Z_Buffer(x, y) = 32767 ' Valor m\u00e1ximo\n    NEXT x\nNEXT y\n\n' Al dibujar cada p\u00edxel\nFOR y = YMin TO YMax\n    FOR x = XMin TO XMax\n        ' Calcular la profundidad Z del punto actual\n        Z = CalcularProfundidad(x, y)\n\n        ' Comparar con el Z-Buffer\n        IF Z &lt; Z_Buffer(x, y) THEN\n            ' Este p\u00edxel est\u00e1 m\u00e1s cerca, actualizamos\n            Z_Buffer(x, y) = Z\n            PSET (x, y), Color\n        END IF\n    NEXT x\nNEXT y\n</code></pre> <p>Esta t\u00e9cnica permite renderizar correctamente escenas con pol\u00edgonos que se intersectan, pero requiere una gran cantidad de memoria.</p>"},{"location":"animaciones/","title":"Animaciones en QBasic","text":"<p>La animaci\u00f3n es una parte fundamental de los juegos y aplicaciones gr\u00e1ficas en QBasic. Este cap\u00edtulo explora c\u00f3mo crear animaciones eficientes, desde los conceptos b\u00e1sicos hasta t\u00e9cnicas m\u00e1s avanzadas.</p>"},{"location":"animaciones/#conceptos-fundamentales","title":"Conceptos Fundamentales","text":"<p>Todas las animaciones, desde las m\u00e1s rudimentarias hasta las secuencias m\u00e1s sofisticadas tipo Pixar, se crean de la misma manera: presentando r\u00e1pidamente una serie de im\u00e1genes est\u00e1ticas, llamadas frames. En la televisi\u00f3n, la tasa es de 30 fps (frames por segundo), y en las pel\u00edculas es de 24 fps.</p>"},{"location":"animaciones/#persistencia-de-vision","title":"Persistencia de Visi\u00f3n","text":"<p>La raz\u00f3n por la que la animaci\u00f3n funciona es debido a una propiedad llamada persistencia de visi\u00f3n. Cuando el ojo humano mira una imagen, esta se retiene en el cerebro durante un breve per\u00edodo de tiempo. Cuando otra imagen sigue r\u00e1pidamente, el cerebro la convierte en movimiento percibiendo un cambio en la posici\u00f3n de los objetos en lugar de un simple cambio de imagen.</p> <p>Algor\u00edtmicamente, esto se puede expresar como:</p> <pre><code>Bucle {\n    Mostrar una Imagen\n    Esperar un Poco\n}\n</code></pre>"},{"location":"animaciones/#animacion-en-qbasic","title":"Animaci\u00f3n en QBasic","text":"<p>Al crear animaciones mediante programaci\u00f3n, t\u00edpicamente no queremos crear una serie de frames completos que se muestran en secuencia. Es m\u00e1s f\u00e1cil programar los cambios de posici\u00f3n de objetos individuales. El algoritmo b\u00e1sico es:</p> <pre><code>Bucle {\n    Mover a una nueva ubicaci\u00f3n\n    Dibujar un objeto\n    Esperar un poco\n    Borrar el objeto\n}\n</code></pre>"},{"location":"animaciones/#animaciones-con-texto","title":"Animaciones con Texto","text":"<p>Para empezar, podemos desarrollar animaciones basadas en texto, que son sencillas de implementar pero ilustran perfectamente los principios b\u00e1sicos.</p>"},{"location":"animaciones/#ejemplo-basico-de-animacion","title":"Ejemplo B\u00e1sico de Animaci\u00f3n","text":"<p>Este es un programa simple que muestra un car\u00e1cter movi\u00e9ndose de izquierda a derecha en la pantalla:</p> <pre><code>'QBasic Animaci\u00f3n #1\n'Escrito por Peter Smith\n\nCOLOR , 1 'Establecer el color de fondo a AZUL\n\nCLS       'Limpiar la pantalla a este color\n\nCOLOR 15\nPRINT \"Primera Animaci\u00f3n de Peter\"\n\nFOR p = 1 TO 79\n    GOSUB 1000 'Dibujar el objeto\n    GOSUB 2000 'Esperar un poco...\n    GOSUB 3000 'Borrar el objeto\nNEXT p\n\nCOLOR 7\nEND\n\n1000 'Dibujar el objeto\nLOCATE 6, p\nCOLOR 14\nPRINT CHR$(219)\nRETURN\n\n2000 'Pausa\nFOR t = 1 TO 500\nNEXT t\nRETURN\n\n3000 'Borrar el objeto\nLOCATE 6, p\nCOLOR 1\nPRINT CHR$(219)\nRETURN\n</code></pre> <p>En este ejemplo:</p> <ul> <li>Utilizamos <code>COLOR , 1</code> para establecer el fondo azul</li> <li>El bucle <code>FOR</code> mueve nuestro objeto a trav\u00e9s de la pantalla</li> <li>La subrutina 1000 dibuja el objeto en su nueva posici\u00f3n</li> <li>La subrutina 2000 crea una pausa para controlar la velocidad</li> <li>La subrutina 3000 borra el objeto antes de moverlo a una nueva posici\u00f3n</li> </ul>"},{"location":"animaciones/#explicacion-del-codigo","title":"Explicaci\u00f3n del C\u00f3digo","text":"<ol> <li> <p>Dibujar el objeto: Utilizamos <code>LOCATE</code> para posicionar el cursor y <code>PRINT CHR$(219)</code> para dibujar un bloque s\u00f3lido. El color 14 es amarillo brillante.</p> </li> <li> <p>Pausa: Un simple bucle de retardo que controla la velocidad de la animaci\u00f3n. Cuanto mayor sea el valor final del bucle, m\u00e1s lenta ser\u00e1 la animaci\u00f3n.</p> </li> <li> <p>Borrar el objeto: Dibujamos el mismo car\u00e1cter pero en el color de fondo (1, azul), lo que efectivamente \"borra\" el objeto.</p> </li> </ol>"},{"location":"animaciones/#mejorando-la-animacion","title":"Mejorando la Animaci\u00f3n","text":"<p>Podemos mejorar esta animaci\u00f3n b\u00e1sica de varias maneras:</p>"},{"location":"animaciones/#movimiento-en-dos-dimensiones","title":"Movimiento en Dos Dimensiones","text":"<pre><code>'Animaci\u00f3n en 2D\nFOR y = 1 TO 20\n    FOR x = 1 TO 79\n        LOCATE y, x\n        COLOR 14\n        PRINT CHR$(219)\n\n        FOR t = 1 TO 100: NEXT t\n\n        LOCATE y, x\n        COLOR 1\n        PRINT CHR$(219)\n    NEXT x\nNEXT y\n</code></pre> <p>Este c\u00f3digo mueve el bloque a trav\u00e9s de la pantalla en un patr\u00f3n de izquierda a derecha, de arriba a abajo.</p>"},{"location":"animaciones/#anadiendo-multiples-objetos","title":"A\u00f1adiendo M\u00faltiples Objetos","text":"<pre><code>'Animaci\u00f3n con m\u00faltiples objetos\nDIM x(3), y(3), dx(3), dy(3)\n\n'Inicializar posiciones y direcciones\nFOR i = 1 TO 3\n    x(i) = INT(RND * 78) + 1\n    y(i) = INT(RND * 20) + 1\n    dx(i) = IIF(RND &lt; 0.5, -1, 1)\n    dy(i) = IIF(RND &lt; 0.5, -1, 1)\nNEXT i\n\nDO\n    'Borrar objetos en posici\u00f3n anterior\n    FOR i = 1 TO 3\n        LOCATE y(i), x(i)\n        COLOR 1\n        PRINT CHR$(219)\n    NEXT i\n\n    'Actualizar posiciones\n    FOR i = 1 TO 3\n        x(i) = x(i) + dx(i)\n        y(i) = y(i) + dy(i)\n\n        'Rebotar en los bordes\n        IF x(i) &lt;= 1 OR x(i) &gt;= 79 THEN dx(i) = -dx(i)\n        IF y(i) &lt;= 1 OR y(i) &gt;= 22 THEN dy(i) = -dy(i)\n    NEXT i\n\n    'Dibujar objetos en nueva posici\u00f3n\n    FOR i = 1 TO 3\n        LOCATE y(i), x(i)\n        COLOR 14\n        PRINT CHR$(219)\n    NEXT i\n\n    'Pausa\n    FOR t = 1 TO 500: NEXT t\nLOOP UNTIL INKEY$ &lt;&gt; \"\"\n</code></pre> <p>Este ejemplo crea tres objetos que se mueven independientemente y rebotan en los bordes de la pantalla.</p>"},{"location":"animaciones/#animacion-con-graficos","title":"Animaci\u00f3n con Gr\u00e1ficos","text":"<p>Para animaciones m\u00e1s avanzadas, podemos usar los comandos gr\u00e1ficos de QBasic como <code>CIRCLE</code>, <code>LINE</code>, <code>PSET</code>, <code>GET</code> y <code>PUT</code>.</p>"},{"location":"animaciones/#usando-get-y-put","title":"Usando GET y PUT","text":"<pre><code>SCREEN 13\nDIM sprite(50)\n\n'Crear sprite\nCIRCLE (10, 10), 5, 14\nPAINT (10, 10), 14, 14\n\n'Guardar en array\nGET (5, 5)-(15, 15), sprite\n\n'Animar\nCLS\nFOR x = 0 TO 310\n    PUT (x, 100), sprite, XOR  'Dibujar\n    FOR t = 1 TO 100: NEXT t   'Pausa\n    PUT (x, 100), sprite, XOR  'Borrar\nNEXT x\n</code></pre> <p>Este c\u00f3digo mueve un c\u00edrculo amarillo a trav\u00e9s de la pantalla en modo gr\u00e1fico.</p>"},{"location":"animaciones/#tecnicas-avanzadas","title":"T\u00e9cnicas Avanzadas","text":""},{"location":"animaciones/#doble-bufer","title":"Doble B\u00fafer","text":"<p>Para eliminar el parpadeo, podemos usar la t\u00e9cnica de doble b\u00fafer:</p> <pre><code>SCREEN 9, , 0, 0  'Activar p\u00e1gina 0 (invisible)\nCLS\n\n'Dibujar en p\u00e1gina invisible\nCIRCLE (100, 100), 50, 14\nPAINT (100, 100), 14, 14\n\n'Mostrar p\u00e1gina invisible\nSCREEN 9, , 1, 0\n</code></pre>"},{"location":"animaciones/#animacion-con-sprites-multiples","title":"Animaci\u00f3n con Sprites M\u00faltiples","text":"<pre><code>SCREEN 13\nDIM sprite1(50), sprite2(50), sprite3(50)\n\n'Crear sprites\nCIRCLE (10, 10), 5, 14\nPAINT (10, 10), 14, 14\nGET (5, 5)-(15, 15), sprite1\n\nCIRCLE (10, 10), 5, 12\nPAINT (10, 10), 12, 12\nGET (5, 5)-(15, 15), sprite2\n\nCIRCLE (10, 10), 5, 10\nPAINT (10, 10), 10, 10\nGET (5, 5)-(15, 15), sprite3\n\n'Animar cambiando los sprites\nCLS\nFOR x = 0 TO 310\n    SELECT CASE x MOD 3\n        CASE 0: PUT (x, 100), sprite1, PSET\n        CASE 1: PUT (x, 100), sprite2, PSET\n        CASE 2: PUT (x, 100), sprite3, PSET\n    END SELECT\n\n    FOR t = 1 TO 100: NEXT t\n    CLS\nNEXT x\n</code></pre> <p>Este ejemplo alterna entre tres sprites diferentes para crear una animaci\u00f3n m\u00e1s compleja.</p>"},{"location":"animaciones/#optimizacion-de-la-velocidad","title":"Optimizaci\u00f3n de la Velocidad","text":"<p>Para mejorar el rendimiento de las animaciones:</p> <ol> <li>Usar tipos de datos enteros cuando sea posible (DEFINT A-Z)</li> <li>Minimizar la redefinici\u00f3n de sprites en cada frame</li> <li>Optimizar las rutinas de pausa (WAIT &amp;H3DA, 8 para sincronizar con el refresco vertical)</li> <li>Utilizar el modo XOR para dibujar/borrar sprites cuando sea apropiado</li> <li>Limitar la zona de redibujado a solo lo que ha cambiado</li> </ol>"},{"location":"animaciones/#conclusion","title":"Conclusi\u00f3n","text":"<p>La animaci\u00f3n en QBasic sigue los mismos principios fundamentales que cualquier otra forma de animaci\u00f3n: mostrar una secuencia de im\u00e1genes est\u00e1ticas lo suficientemente r\u00e1pido para crear la ilusi\u00f3n de movimiento. Desde simples animaciones de texto hasta complejas animaciones gr\u00e1ficas con m\u00faltiples sprites, QBasic ofrece herramientas vers\u00e1tiles para crear experiencias visuales din\u00e1micas.</p> <p>Las t\u00e9cnicas presentadas aqu\u00ed pueden combinarse y extenderse para crear animaciones m\u00e1s complejas, juegos interactivos y presentaciones visuales atractivas.</p>"},{"location":"archivos/","title":"Manejo de Archivos","text":"<p>QBasic ofrece un conjunto completo de instrucciones para trabajar con archivos, permitiendo leer y escribir datos en almacenamiento permanente. Esta funcionalidad es esencial para crear programas que puedan guardar informaci\u00f3n entre sesiones.</p>"},{"location":"archivos/#conceptos-basicos","title":"Conceptos B\u00e1sicos","text":""},{"location":"archivos/#tipos-de-acceso-a-archivos","title":"Tipos de Acceso a Archivos","text":"<p>QBasic soporta varios modos de acceso a archivos:</p> <ul> <li>Secuencial: Lectura/escritura lineal del archivo desde el principio</li> <li>Aleatorio: Acceso directo a registros espec\u00edficos en cualquier posici\u00f3n</li> <li>Binario: Lectura/escritura de datos sin formato</li> </ul>"},{"location":"archivos/#canales-de-archivo-file-handles","title":"Canales de Archivo (File Handles)","text":"<p>Cada archivo abierto en QBasic usa un n\u00famero de canal. Puedes especificar un n\u00famero o usar <code>FREEFILE</code> para obtener el siguiente disponible.</p>"},{"location":"archivos/#trabajando-con-archivos-secuenciales","title":"Trabajando con Archivos Secuenciales","text":""},{"location":"archivos/#abrir-y-cerrar-archivos","title":"Abrir y Cerrar Archivos","text":"<pre><code>' Abrir un archivo para OUTPUT (escritura)\nOPEN \"datos.txt\" FOR OUTPUT AS #1\n\n' Escribir algunos datos\nPRINT #1, \"Hola Mundo\"\nPRINT #1, 123, 456, \"texto\"\n\n' Cerrar archivo\nCLOSE #1\n\n' Abrir para INPUT (lectura)\nOPEN \"datos.txt\" FOR INPUT AS #1\n\n' Leer datos\nINPUT #1, texto$\nINPUT #1, a, b, c$\n\n' Cerrar archivo\nCLOSE #1\n</code></pre> <p>Tambi\u00e9n puedes usar <code>FREEFILE</code> para obtener el siguiente canal disponible:</p> <pre><code>fileNum% = FREEFILE\nOPEN \"datos.txt\" FOR OUTPUT AS #fileNum%\n</code></pre>"},{"location":"archivos/#modos-de-apertura","title":"Modos de Apertura","text":"<ul> <li><code>OUTPUT</code>: Crea un nuevo archivo (borra si existe)</li> <li><code>INPUT</code>: Abre para lectura</li> <li><code>APPEND</code>: A\u00f1ade al final de un archivo existente</li> </ul>"},{"location":"archivos/#lectura-y-escritura","title":"Lectura y Escritura","text":""},{"location":"archivos/#print","title":"PRINT","text":"<p>Escribe datos a un archivo secuencial:</p> <pre><code>PRINT #1, \"Texto\"\nPRINT #1, variable\nPRINT #1, a; b; c       ' Separados por espacios\nPRINT #1, a, b, c       ' Separados por tabulaciones\n</code></pre>"},{"location":"archivos/#input","title":"INPUT","text":"<p>Lee datos formateados de un archivo secuencial:</p> <pre><code>INPUT #1, a$           ' Lee texto hasta coma o fin de l\u00ednea\nINPUT #1, a%, b#, c$   ' Lee m\u00faltiples variables\n</code></pre>"},{"location":"archivos/#line-input","title":"LINE INPUT","text":"<p>Lee una l\u00ednea completa (incluyendo comas, comillas, etc.):</p> <pre><code>LINE INPUT #1, texto$  ' Lee toda la l\u00ednea\n</code></pre>"},{"location":"archivos/#eof","title":"EOF","text":"<p>Comprueba si se ha llegado al final del archivo:</p> <pre><code>OPEN \"datos.txt\" FOR INPUT AS #1\n\nDO WHILE NOT EOF(1)\n    LINE INPUT #1, texto$\n    PRINT texto$\nLOOP\n\nCLOSE #1\n</code></pre>"},{"location":"archivos/#ejemplo-guardar-y-cargar-un-registro","title":"Ejemplo: Guardar y Cargar un Registro","text":"<pre><code>TYPE Persona\n    Nombre AS STRING * 30\n    Edad AS INTEGER\n    Salario AS DOUBLE\nEND TYPE\n\nDIM p AS Persona\n\n' Guardar registros\nSUB GuardarDatos(archivo$)\n    fileNum% = FREEFILE\n    OPEN archivo$ FOR OUTPUT AS #fileNum%\n\n    p.Nombre = \"Juan P\u00e9rez\"\n    p.Edad = 35\n    p.Salario = 45000.5\n\n    PRINT #fileNum%, p.Nombre\n    PRINT #fileNum%, p.Edad\n    PRINT #fileNum%, p.Salario\n\n    CLOSE #fileNum%\nEND SUB\n\n' Cargar registros\nSUB CargarDatos(archivo$)\n    fileNum% = FREEFILE\n    OPEN archivo$ FOR INPUT AS #fileNum%\n\n    LINE INPUT #fileNum%, p.Nombre\n    INPUT #fileNum%, p.Edad\n    INPUT #fileNum%, p.Salario\n\n    CLOSE #fileNum%\n\n    PRINT \"Nombre: \"; p.Nombre\n    PRINT \"Edad: \"; p.Edad\n    PRINT \"Salario: \"; p.Salario\nEND SUB\n</code></pre>"},{"location":"archivos/#archivos-de-acceso-aleatorio","title":"Archivos de Acceso Aleatorio","text":"<p>Los archivos de acceso aleatorio permiten leer y escribir registros en cualquier posici\u00f3n del archivo.</p>"},{"location":"archivos/#definicion-de-estructura","title":"Definici\u00f3n de Estructura","text":"<pre><code>TYPE Empleado\n    ID AS INTEGER\n    Nombre AS STRING * 30\n    Departamento AS STRING * 20\n    Salario AS SINGLE\nEND TYPE\n\nDIM E AS Empleado\n</code></pre>"},{"location":"archivos/#abrir-y-cerrar-archivos-aleatorios","title":"Abrir y Cerrar Archivos Aleatorios","text":"<pre><code>' Abrir archivo aleatorio\nOPEN \"empleados.dat\" FOR RANDOM AS #1 LEN = LEN(E)\n\n' Cerrar archivo\nCLOSE #1\n</code></pre>"},{"location":"archivos/#lectura-y-escritura_1","title":"Lectura y Escritura","text":""},{"location":"archivos/#put","title":"PUT","text":"<p>Escribe un registro en la posici\u00f3n especificada:</p> <pre><code>E.ID = 101\nE.Nombre = \"Juan P\u00e9rez\"\nE.Departamento = \"Contabilidad\"\nE.Salario = 45000!\n\nPUT #1, E.ID, E  ' Guarda en la posici\u00f3n E.ID\n</code></pre>"},{"location":"archivos/#get","title":"GET","text":"<p>Lee un registro de la posici\u00f3n especificada:</p> <pre><code>GET #1, 101, E   ' Lee el registro en posici\u00f3n 101\nPRINT E.Nombre, E.Departamento, E.Salario\n</code></pre>"},{"location":"archivos/#ejemplo-base-de-datos-simple","title":"Ejemplo: Base de Datos Simple","text":"<pre><code>CONST MAX_EMPLEADOS = 100\n\nTYPE Empleado\n    ID AS INTEGER\n    Nombre AS STRING * 30\n    Departamento AS STRING * 20\n    Salario AS SINGLE\nEND TYPE\n\nDIM E AS Empleado\n\n' Crear archivo si no existe\nSUB InicializarBD\n    OPEN \"empleados.dat\" FOR RANDOM AS #1 LEN = LEN(E)\n    CLOSE #1\nEND SUB\n\n' A\u00f1adir un empleado\nSUB AgregarEmpleado(id%, nombre$, departamento$, salario!)\n    OPEN \"empleados.dat\" FOR RANDOM AS #1 LEN = LEN(E)\n\n    E.ID = id%\n    E.Nombre = nombre$\n    E.Departamento = departamento$\n    E.Salario = salario!\n\n    PUT #1, id%, E\n\n    CLOSE #1\nEND SUB\n\n' Buscar un empleado\nSUB BuscarEmpleado(id%)\n    OPEN \"empleados.dat\" FOR RANDOM AS #1 LEN = LEN(E)\n\n    GET #1, id%, E\n\n    IF E.ID = id% THEN\n        PRINT \"ID: \"; E.ID\n        PRINT \"Nombre: \"; RTRIM$(E.Nombre)\n        PRINT \"Departamento: \"; RTRIM$(E.Departamento)\n        PRINT \"Salario: \"; E.Salario\n    ELSE\n        PRINT \"Empleado no encontrado\"\n    END IF\n\n    CLOSE #1\nEND SUB\n</code></pre>"},{"location":"archivos/#archivos-binarios","title":"Archivos Binarios","text":"<p>Los archivos binarios permiten leer y escribir datos en su formato \"crudo\", sin conversi\u00f3n.</p> <pre><code>' Escribir matriz en archivo binario\nSUB GuardarMatrizBinaria(matriz%(), archivo$)\n    fileNum% = FREEFILE\n    OPEN archivo$ FOR BINARY AS #fileNum%\n\n    filas% = UBOUND(matriz, 1)\n    columnas% = UBOUND(matriz, 2)\n\n    ' Guardar dimensiones\n    PUT #fileNum%, , filas%\n    PUT #fileNum%, , columnas%\n\n    ' Guardar datos\n    FOR i = 1 TO filas%\n        FOR j = 1 TO columnas%\n            PUT #fileNum%, , matriz%(i, j)\n        NEXT j\n    NEXT i\n\n    CLOSE #fileNum%\nEND SUB\n\n' Leer matriz desde archivo binario\nSUB CargarMatrizBinaria(matriz%(), archivo$)\n    fileNum% = FREEFILE\n    OPEN archivo$ FOR BINARY AS #fileNum%\n\n    ' Leer dimensiones\n    GET #fileNum%, , filas%\n    GET #fileNum%, , columnas%\n\n    REDIM matriz%(filas%, columnas%)\n\n    ' Leer datos\n    FOR i = 1 TO filas%\n        FOR j = 1 TO columnas%\n            GET #fileNum%, , matriz%(i, j)\n        NEXT j\n    NEXT i\n\n    CLOSE #fileNum%\nEND SUB\n</code></pre>"},{"location":"archivos/#funciones-y-comandos-adicionales","title":"Funciones y Comandos Adicionales","text":""},{"location":"archivos/#loc-y-lof","title":"LOC y LOF","text":"<ul> <li><code>LOC(n)</code>: Devuelve la posici\u00f3n actual en el archivo</li> <li><code>LOF(n)</code>: Devuelve el tama\u00f1o del archivo en bytes</li> </ul> <pre><code>PRINT \"Tama\u00f1o del archivo: \"; LOF(1); \" bytes\"\nPRINT \"Posici\u00f3n actual: \"; LOC(1)\n</code></pre>"},{"location":"archivos/#seek","title":"SEEK","text":"<p>Cambia la posici\u00f3n actual en el archivo:</p> <pre><code>SEEK #1, 1   ' Posiciona al inicio del archivo\n</code></pre>"},{"location":"archivos/#kill","title":"KILL","text":"<p>Elimina un archivo:</p> <pre><code>KILL \"archivo.txt\"\n</code></pre>"},{"location":"archivos/#name","title":"NAME","text":"<p>Renombra un archivo:</p> <pre><code>NAME \"viejo.txt\" AS \"nuevo.txt\"\n</code></pre>"},{"location":"archivos/#mkdir-y-rmdir","title":"MKDIR y RMDIR","text":"<p>Crea y elimina directorios:</p> <pre><code>MKDIR \"datos\"\nRMDIR \"datos\"\n</code></pre>"},{"location":"archivos/#chdir","title":"CHDIR","text":"<p>Cambia el directorio actual:</p> <pre><code>CHDIR \"c:\\proyectos\"\n</code></pre>"},{"location":"archivos/#tecnicas-avanzadas","title":"T\u00e9cnicas Avanzadas","text":""},{"location":"archivos/#encriptacion-simple-de-archivos","title":"Encriptaci\u00f3n Simple de Archivos","text":"<pre><code>' Encripta/desencripta un archivo con XOR\nSUB EncriptarArchivo(origen$, destino$, clave%)\n    OPEN origen$ FOR BINARY AS #1\n    OPEN destino$ FOR BINARY AS #2\n\n    tama\u00f1o&amp; = LOF(1)\n\n    FOR i&amp; = 1 TO tama\u00f1o&amp;\n        GET #1, , b%\n        b% = b% XOR clave%\n        PUT #2, , b%\n    NEXT i&amp;\n\n    CLOSE #1, #2\nEND SUB\n</code></pre>"},{"location":"archivos/#guardado-de-sprites-en-archivos","title":"Guardado de Sprites en Archivos","text":"<pre><code>' Guardar array de sprite en archivo\nSUB GuardarSprite(sprite%(), archivo$)\n    fileNum% = FREEFILE\n    OPEN archivo$ FOR BINARY AS #fileNum%\n\n    ' Obtener tama\u00f1o del sprite\n    tama\u00f1o% = UBOUND(sprite)\n\n    ' Guardar tama\u00f1o\n    PUT #fileNum%, , tama\u00f1o%\n\n    ' Guardar datos del sprite\n    FOR i = 0 TO tama\u00f1o%\n        PUT #fileNum%, , sprite%(i)\n    NEXT i\n\n    CLOSE #fileNum%\nEND SUB\n\n' Cargar array de sprite desde archivo\nSUB CargarSprite(sprite%(), archivo$)\n    fileNum% = FREEFILE\n    OPEN archivo$ FOR BINARY AS #fileNum%\n\n    ' Leer tama\u00f1o\n    GET #fileNum%, , tama\u00f1o%\n\n    ' Dimensionar array\n    REDIM sprite%(tama\u00f1o%)\n\n    ' Leer datos\n    FOR i = 0 TO tama\u00f1o%\n        GET #fileNum%, , sprite%(i)\n    NEXT i\n\n    CLOSE #fileNum%\nEND SUB\n</code></pre>"},{"location":"archivos/#manejo-de-errores","title":"Manejo de Errores","text":"<p>Es importante manejar posibles errores al trabajar con archivos:</p> <pre><code>ON ERROR GOTO ManejadorErrores\n\nOPEN \"datos.txt\" FOR INPUT AS #1\n' C\u00f3digo para procesar el archivo\nCLOSE #1\nEND\n\nManejadorErrores:\n    IF ERR = 53 THEN ' Archivo no encontrado\n        PRINT \"El archivo no existe\"\n    ELSEIF ERR = 70 THEN ' Permiso denegado\n        PRINT \"No se puede acceder al archivo\"\n    ELSE\n        PRINT \"Error: \"; ERR\n    END IF\n    RESUME Next\n</code></pre>"},{"location":"archivos/#recomendaciones-de-buenas-practicas","title":"Recomendaciones de Buenas Pr\u00e1cticas","text":"<ol> <li>Siempre cierra tus archivos: Usar <code>CLOSE</code> para cada archivo abierto</li> <li>Comprueba si los archivos existen antes de intentar leerlos</li> <li>Usa FREEFILE para obtener autom\u00e1ticamente n\u00fameros de canal</li> <li>Maneja errores relacionados con los archivos</li> <li>Libera recursos abriendo archivos solo cuando sea necesario</li> <li>Haz copias de seguridad antes de sobrescribir datos importantes</li> </ol>"},{"location":"buenas-practicas/","title":"Buenas Pr\u00e1cticas en QBasic","text":""},{"location":"buenas-practicas/#escribiendo-codigo-comprensible","title":"Escribiendo C\u00f3digo Comprensible","text":"<p>Siempre es un desaf\u00edo escribir c\u00f3digo robusto, r\u00e1pido y optimizado, mientras se mantiene lo suficientemente estructurado para ser legible por ti y por otros programadores en el futuro. Aunque QBasic es considerado un lenguaje relativamente simple, los programas pueden volverse complejos r\u00e1pidamente si no se aplican buenas pr\u00e1cticas de programaci\u00f3n.</p>"},{"location":"buenas-practicas/#nomenclatura","title":"Nomenclatura","text":"<p>Elegir nombres adecuados para los elementos de tu c\u00f3digo puede hacerlo mucho m\u00e1s comprensible. Los nombres deben indicar exactamente qu\u00e9 es el elemento:</p> <ul> <li>Para funciones o procedimientos: Comienza el nombre con un verbo, como en \"ObtenerEspacioLibre\" o \"DibujarBorde\".</li> <li>Para variables: El nombre debe indicar lo que contiene, como en \"EspacioLibreDisco\" o \"ContadorFilas\".</li> <li>Prefijos de tipo: Puedes a\u00f1adir un prefijo de tipo como \"n\" o \"ent\" para variables enteras (por ejemplo, \"nIndiceArray\"), aunque esto no siempre es necesario.</li> </ul> <p>La capitalizaci\u00f3n de la primera letra de cada palabra en el nombre puede hacerlo m\u00e1s legible. Evita usar una sola letra para los nombres de variables, excepto para \u00edndices de bucles (como <code>i</code>, <code>j</code>, <code>k</code>).</p> <pre><code>' Mal ejemplo\nFOR a = 1 TO 10\n  b = b + a\nNEXT a\n\n' Buen ejemplo\nFOR indice = 1 TO NumeroElementos\n  SumaTotal = SumaTotal + indice\nNEXT indice\n</code></pre>"},{"location":"buenas-practicas/#constantes-con-nombre","title":"Constantes con Nombre","text":"<p>Utiliza constantes con nombre en lugar de valores literales. Por ejemplo, en lugar de escribir:</p> <pre><code>FOR i = 1 TO 10\n  ' c\u00f3digo\nNEXT i\n</code></pre> <p>Es mejor escribir:</p> <pre><code>CONST CantidadFilas = 10\nFOR i = 1 TO CantidadFilas\n  ' c\u00f3digo\nNEXT i\n</code></pre> <p>Usar constantes con nombre tiene dos ventajas principales:</p> <ol> <li>Es m\u00e1s f\u00e1cil entender qu\u00e9 representa el valor.</li> <li>Los cambios futuros en el c\u00f3digo ser\u00e1n m\u00e1s sencillos, ya que solo necesitas modificar el valor en un lugar.</li> </ol>"},{"location":"buenas-practicas/#comentarios","title":"Comentarios","text":"<p>Los comentarios son lo que la mayor\u00eda de los programadores dejan para el futuro, y ese es el error, \u00a1porque luego no lo har\u00e1n! Siempre a\u00f1ade comentarios mientras est\u00e1s programando. Describe todo en tu c\u00f3digo siguiendo estas reglas:</p> <ol> <li>A\u00f1ade comentarios antes o junto a las declaraciones de variables para describir qu\u00e9 son y/o c\u00f3mo se utilizan en el c\u00f3digo.</li> </ol> <p><code>qbasic    DIM CantidadElementos AS INTEGER  ' Cantidad total de elementos en el array    DIM Matriz(100, 100) AS INTEGER   ' Matriz que almacena los valores de altura del terreno</code></p> <ol> <li>A\u00f1ade comentarios antes de cada bloque para describir su prop\u00f3sito.</li> </ol> <p><code>qbasic    ' Calcular el promedio de los elementos    SumaTotal = 0    FOR i = 1 TO NumeroElementos      SumaTotal = SumaTotal + Valores(i)    NEXT i    Promedio = SumaTotal / NumeroElementos</code></p> <ol> <li>Comenta las partes complicadas del c\u00f3digo. Esto es muy importante, porque generalmente utilizas algunos trucos de codificaci\u00f3n para hacer el c\u00f3digo mejor y m\u00e1s r\u00e1pido, pero m\u00e1s tarde no entender\u00e1s c\u00f3mo funciona.</li> </ol> <p><code>qbasic    ' Usamos XOR para intercambiar variables sin usar una variable temporal    a = a XOR b    b = a XOR b    a = a XOR b</code></p> <ol> <li>Escribe un bloque de comentarios al principio de cada procedimiento, describe sus entradas y salidas, qu\u00e9 hace y/o c\u00f3mo funciona. No entres en detalles de la rutina, sin embargo \u2013 deber\u00edan describirse dentro del procedimiento.</li> </ol> <p><code>qbasic    ' ******************************************    ' SUB DibujarCuadro(x1, y1, x2, y2, color)    ' Entradas: x1,y1 - Coordenada superior izquierda    '           x2,y2 - Coordenada inferior derecha    '           color - Color del cuadro (1-15)    ' Salida: Ninguna    ' Funci\u00f3n: Dibuja un cuadro en la pantalla usando caracteres ASCII    ' ******************************************    SUB DibujarCuadro(x1, y1, x2, y2, color)</code></p> <ol> <li>Algunos programadores quieren tener un historial de su trabajo. Pueden querer a\u00f1adir un bloque de comentarios al principio de los procedimientos y m\u00f3dulos con informaci\u00f3n como la fecha de la \u00faltima actualizaci\u00f3n, correcciones de errores, etc.</li> </ol>"},{"location":"buenas-practicas/#formato","title":"Formato","text":"<p>El formato adecuado del c\u00f3digo tambi\u00e9n lo hace m\u00e1s comprensible. Algunas formas comunes de formateo adecuado son:</p> <ol> <li>Indenta los bloques anidados. Esto es realmente necesario para distinguir bloques anidados entre s\u00ed. Por ejemplo, si tienes tres bucles FOR anidados con cuatro bloques IF dentro de ellos, sin indentar el c\u00f3digo te confundir\u00e1s f\u00e1cilmente con los bloques.</li> </ol> <p>```qbasic    ' Mal ejemplo    FOR i = 1 TO 10    FOR j = 1 TO 10    IF Matriz(i, j) &gt; 0 THEN    PRINT \"Positivo\"    ELSE    PRINT \"No positivo\"    END IF    NEXT j    NEXT i</p> <p>' Buen ejemplo    FOR i = 1 TO 10      FOR j = 1 TO 10        IF Matriz(i, j) &gt; 0 THEN          PRINT \"Positivo\"        ELSE          PRINT \"No positivo\"        END IF      NEXT j    NEXT i    ```</p> <ol> <li>Estructura tu c\u00f3digo en p\u00e1rrafos. Mant\u00e9n l\u00edneas relacionadas juntas y deja un espacio entre dos p\u00e1rrafos de c\u00f3digo relacionado. Si no has hecho algo as\u00ed en tu c\u00f3digo, int\u00e9ntalo. Entonces ver\u00e1s c\u00f3mo tu c\u00f3digo se vuelve mucho m\u00e1s comprensible con este peque\u00f1o consejo.</li> </ol> <p>```qbasic    ' Inicializaci\u00f3n de variables    x = 0    y = 0    contador = 0</p> <p>' Procesamiento principal    INPUT \"Ingrese un valor: \", valor    WHILE valor &gt; 0      suma = suma + valor      contador = contador + 1      INPUT \"Ingrese otro valor (0 para terminar): \", valor    WEND</p> <p>' Mostrar resultados    PRINT \"La suma es: \"; suma    IF contador &gt; 0 THEN      PRINT \"El promedio es: \"; suma / contador    ELSE      PRINT \"No se ingresaron valores positivos\"    END IF    ```</p> <ol> <li>Declara todas las variables al principio del m\u00f3dulo o procedimiento. Esto facilita encontrar la declaraci\u00f3n de cada variable. No declarar las variables es un gran error que hace que tu c\u00f3digo sea menos optimizado y menos estructurado.</li> </ol> <p>```qbasic    SUB ProcesarDatos      ' Declaraci\u00f3n de variables      DIM i AS INTEGER      DIM suma AS SINGLE      DIM promedio AS SINGLE      DIM valor AS INTEGER      DIM contador AS INTEGER</p> <pre><code> ' C\u00f3digo del procedimiento...\n</code></pre> <p>END SUB    ```</p>"},{"location":"buenas-practicas/#tecnicas-de-codificacion","title":"T\u00e9cnicas de Codificaci\u00f3n","text":"<p>Podemos llamarlo el arte de programar: codificar de manera que facilite los cambios futuros. \u00bfC\u00f3mo debemos organizar nuestro c\u00f3digo? A continuaci\u00f3n, se discuten algunos de los conceptos m\u00e1s importantes de la programaci\u00f3n.</p>"},{"location":"buenas-practicas/#programacion-modular","title":"Programaci\u00f3n Modular","text":"<p>Siempre escribe tu c\u00f3digo de manera modular. Esto es muy importante por varias razones:</p> <ol> <li> <p>Reutilizaci\u00f3n: Los m\u00f3dulos independientes pueden utilizarse en m\u00e1s de un proyecto. Supongamos que has escrito un programa que necesita algunos c\u00e1lculos financieros. Si colocas el c\u00f3digo que realiza estos c\u00e1lculos en un m\u00f3dulo independiente, puedes utilizarlo en otro programa sin hacer cambios.</p> </li> <li> <p>Organizaci\u00f3n: Dividir tu c\u00f3digo en partes m\u00e1s peque\u00f1as hace que tu proyecto est\u00e9 m\u00e1s organizado. Un proyecto bien organizado tiene un gran potencial para ser ampliado en cualquier momento.</p> </li> <li> <p>Flexibilidad de enfoque: La programaci\u00f3n modular facilita tanto la programaci\u00f3n de arriba hacia abajo como de abajo hacia arriba:</p> </li> <li>Los programadores que prefieren trabajar de arriba hacia abajo pueden escribir las partes principales del c\u00f3digo en el m\u00f3dulo principal, mientras declaran procedimientos que se codificar\u00e1n en otros m\u00f3dulos m\u00e1s tarde.</li> <li> <p>Quienes prefieren trabajar de abajo hacia arriba pueden escribir m\u00f3dulos independientes uno por uno, y como escriben partes relacionadas juntas, es m\u00e1s f\u00e1cil seguir el rastro de su c\u00f3digo.</p> </li> <li> <p>Trabajo en equipo: La programaci\u00f3n modular tambi\u00e9n facilita la programaci\u00f3n de un proyecto grande en equipo.</p> </li> </ol> <p>En QBasic, puedes implementar la programaci\u00f3n modular de varias maneras:</p> <pre><code>' Archivo: PRINCIPAL.BAS\n' M\u00f3dulo principal del programa\n\n' Inclusi\u00f3n de otros m\u00f3dulos usando $INCLUDE\n'$INCLUDE: 'UTILIDAD.BI'\n'$INCLUDE: 'GRAFICO.BI'\n\n' Declaraciones de variables globales\nDIM SHARED configuracion AS configuracionType\n\n' Programa principal\nSUB Main\n  InicializarPrograma\n  MostrarMenuPrincipal\n  FinalizarPrograma\nEND SUB\n\n' Llamada al programa principal\nMain\nEND\n</code></pre> <pre><code>' Archivo: UTILIDAD.BI\n' M\u00f3dulo de utilidades con funciones comunes\n\n' Tipo de datos para configuraci\u00f3n\nTYPE configuracionType\n  nombreArchivo AS STRING * 64\n  modoGrafico AS INTEGER\n  colorTexto AS INTEGER\nEND TYPE\n\n' Funciones de utilidad\nSUB InicializarPrograma\n  ' C\u00f3digo de inicializaci\u00f3n\nEND SUB\n\nFUNCTION LeerArchivo$(nombreArchivo$)\n  ' C\u00f3digo para leer archivos\nEND FUNCTION\n\nSUB GuardarArchivo(nombreArchivo$, datos$)\n  ' C\u00f3digo para guardar archivos\nEND SUB\n</code></pre> <p>Es importante destacar que la mayor\u00eda de las ventajas de la programaci\u00f3n modular est\u00e1n asociadas con que los m\u00f3dulos sean independientes. Por supuesto, al menos un m\u00f3dulo en cada proyecto no puede ser independiente, pero si todos los m\u00f3dulos dependen de otros, entonces hay poca ventaja en la programaci\u00f3n modular.</p>"},{"location":"buenas-practicas/#programacion-procedural","title":"Programaci\u00f3n Procedural","text":"<p>En la secci\u00f3n anterior, hablamos sobre el uso de m\u00f3dulos. Para estar lo suficientemente estructurado, el c\u00f3digo en cada m\u00f3dulo debe dividirse en procedimientos. A diferencia de los m\u00f3dulos en un proyecto, los procedimientos en un m\u00f3dulo pueden usar otros procedimientos y, de hecho, es por eso que se colocan en un mismo m\u00f3dulo.</p> <p>Cada procedimiento debe tener una sola tarea. Esto facilita la codificaci\u00f3n de procedimientos, ya que es m\u00e1s f\u00e1cil aplicar los cambios en el c\u00f3digo. Cambias un procedimiento y los otros que lo utilizan funcionar\u00e1n de la manera que deseas. Esta es la principal ventaja de la programaci\u00f3n procedural.</p> <p>En QBasic, los procedimientos se implementan mediante:</p> <ol> <li>SUB: Para procedimientos que no devuelven un valor</li> </ol> <p><code>qbasic    SUB DibujarCuadro (x1, y1, x2, y2, color)      ' Dibujar un cuadro en la pantalla      LINE (x1, y1)-(x2, y2), color, B    END SUB</code></p> <ol> <li>FUNCTION: Para procedimientos que devuelven un valor</li> </ol> <p><code>qbasic    FUNCTION CalcularArea (ancho, alto)      CalcularArea = ancho * alto    END FUNCTION</code></p> <p>Algunas buenas pr\u00e1cticas para procedimientos en QBasic:</p> <ol> <li> <p>Nombres descriptivos: Utiliza nombres que describan claramente lo que hace el procedimiento.</p> </li> <li> <p>Par\u00e1metros claros: Define claramente los par\u00e1metros de entrada y salida.</p> </li> <li> <p>Tama\u00f1o adecuado: Un procedimiento no debe ser demasiado largo. Si es muy extenso, considera dividirlo en procedimientos m\u00e1s peque\u00f1os.</p> </li> <li> <p>Cohesi\u00f3n: Cada procedimiento debe realizar una tarea \u00fanica y bien definida.</p> </li> <li> <p>Bajo acoplamiento: Minimiza las dependencias entre procedimientos.</p> </li> </ol> <p>Ejemplo de una estructura procedural bien organizada:</p> <pre><code>' Programa principal\nSUB Main\n  ' Variables locales\n  DIM opcion AS INTEGER\n\n  ' Inicializaci\u00f3n\n  InicializarPrograma\n\n  ' Bucle principal\n  DO\n    opcion = MostrarMenu()\n    ProcesarOpcion opcion\n  LOOP UNTIL opcion = 0\n\n  ' Finalizaci\u00f3n\n  FinalizarPrograma\nEND SUB\n\n' Muestra el men\u00fa principal y devuelve la opci\u00f3n seleccionada\nFUNCTION MostrarMenu()\n  CLS\n  PRINT \"MEN\u00da PRINCIPAL\"\n  PRINT \"==============\"\n  PRINT \"1. Ingresar datos\"\n  PRINT \"2. Procesar informaci\u00f3n\"\n  PRINT \"3. Mostrar resultados\"\n  PRINT \"0. Salir\"\n  PRINT\n  INPUT \"Seleccione una opci\u00f3n: \", opcion\n  MostrarMenu = opcion\nEND FUNCTION\n\n' Procesa la opci\u00f3n seleccionada\nSUB ProcesarOpcion(opcion)\n  SELECT CASE opcion\n    CASE 1: IngresarDatos\n    CASE 2: ProcesarInformacion\n    CASE 3: MostrarResultados\n    CASE 0: ' No hacer nada, salir\n    CASE ELSE: MostrarError \"Opci\u00f3n no v\u00e1lida\"\n  END SELECT\nEND SUB\n</code></pre>"},{"location":"buenas-practicas/#combinando-modulos-y-procedimientos","title":"Combinando M\u00f3dulos y Procedimientos","text":"<p>Un proyecto QBasic bien estructurado combina tanto la programaci\u00f3n modular como la procedural:</p> <ol> <li> <p>Define m\u00f3dulos para \u00e1reas funcionales: Gr\u00e1ficos, entrada/salida, c\u00e1lculos, interfaz de usuario, etc.</p> </li> <li> <p>Dentro de cada m\u00f3dulo, define procedimientos espec\u00edficos: Cada procedimiento realiza una tarea concreta dentro del \u00e1mbito del m\u00f3dulo.</p> </li> <li> <p>Establece interfaces claras entre m\u00f3dulos: Define c\u00f3mo interact\u00faan los m\u00f3dulos entre s\u00ed, minimizando dependencias.</p> </li> </ol> <p>Esta aproximaci\u00f3n estructurada te permitir\u00e1:</p> <ul> <li>Mantener tu c\u00f3digo organizado y f\u00e1cil de entender</li> <li>Reutilizar componentes en otros proyectos</li> <li>Facilitar modificaciones y ampliaciones futuras</li> <li>Trabajar en equipo de manera m\u00e1s eficiente en proyectos grandes</li> </ul>"},{"location":"buenas-practicas/#optimizacion-de-codigo","title":"Optimizaci\u00f3n de C\u00f3digo","text":"<p>// ... existing content ...</p>"},{"location":"estandares/","title":"Est\u00e1ndares","text":"<p>Convenciones hist\u00f3ricas y de estilo.</p>"},{"location":"estructuras-control/","title":"Estructuras de Control","text":"<p>Las estructuras de control permiten alterar el flujo de ejecuci\u00f3n de un programa. QBasic ofrece diversas estructuras para toma de decisiones y bucles.</p>"},{"location":"estructuras-control/#estructuras-condicionales","title":"Estructuras Condicionales","text":""},{"location":"estructuras-control/#if-then-else","title":"IF-THEN-ELSE","text":"<p>La estructura <code>IF-THEN-ELSE</code> permite ejecutar c\u00f3digo basado en una condici\u00f3n:</p> <pre><code>' Forma simple de una l\u00ednea\nIF edad &gt;= 18 THEN PRINT \"Mayor de edad\"\n\n' Forma de bloque\nIF nota &gt;= 5 THEN\n    PRINT \"Aprobado\"\nELSE\n    PRINT \"Suspendido\"\nEND IF\n\n' Forma m\u00faltiple con ELSEIF\nIF nota &lt; 5 THEN\n    PRINT \"Suspendido\"\nELSEIF nota &lt; 7 THEN\n    PRINT \"Aprobado\"\nELSEIF nota &lt; 9 THEN\n    PRINT \"Notable\"\nELSE\n    PRINT \"Sobresaliente\"\nEND IF\n</code></pre>"},{"location":"estructuras-control/#select-case","title":"SELECT CASE","text":"<p>La estructura <code>SELECT CASE</code> es \u00fatil cuando hay m\u00faltiples condiciones sobre una misma variable:</p> <pre><code>SELECT CASE opcion\n    CASE 1\n        PRINT \"Seleccionaste la opci\u00f3n 1\"\n    CASE 2\n        PRINT \"Seleccionaste la opci\u00f3n 2\"\n    CASE 3, 4\n        PRINT \"Seleccionaste la opci\u00f3n 3 o 4\"\n    CASE 5 TO 10\n        PRINT \"Seleccionaste un n\u00famero entre 5 y 10\"\n    CASE IS &gt; 10\n        PRINT \"Seleccionaste un n\u00famero mayor que 10\"\n    CASE ELSE\n        PRINT \"Opci\u00f3n no v\u00e1lida\"\nEND SELECT\n</code></pre>"},{"location":"estructuras-control/#bucles","title":"Bucles","text":""},{"location":"estructuras-control/#for-next","title":"FOR-NEXT","text":"<p>El bucle <code>FOR-NEXT</code> permite repetir c\u00f3digo un n\u00famero espec\u00edfico de veces:</p> <pre><code>' Bucle b\u00e1sico de 1 a 10\nFOR i = 1 TO 10\n    PRINT i;\nNEXT i\n\n' Con incremento personalizado\nFOR i = 0 TO 100 STEP 10\n    PRINT i;\nNEXT i\n\n' Con decremento\nFOR i = 10 TO 1 STEP -1\n    PRINT i;\nNEXT i\n</code></pre> <p>Se pueden anidar bucles <code>FOR-NEXT</code>:</p> <pre><code>FOR i = 1 TO 5\n    FOR j = 1 TO 3\n        PRINT i; \",\"; j\n    NEXT j\nNEXT i\n</code></pre>"},{"location":"estructuras-control/#while-wend","title":"WHILE-WEND","text":"<p>El bucle <code>WHILE-WEND</code> repite c\u00f3digo mientras una condici\u00f3n sea verdadera:</p> <pre><code>contador = 1\nWHILE contador &lt;= 5\n    PRINT contador\n    contador = contador + 1\nWEND\n</code></pre>"},{"location":"estructuras-control/#do-loop","title":"DO-LOOP","text":"<p>M\u00e1s flexible que <code>WHILE-WEND</code>, el bucle <code>DO-LOOP</code> tiene varias formas:</p> <pre><code>' Eval\u00faa la condici\u00f3n al inicio (como WHILE-WEND)\ncontador = 1\nDO WHILE contador &lt;= 5\n    PRINT contador\n    contador = contador + 1\nLOOP\n\n' Eval\u00faa la condici\u00f3n al final\ncontador = 1\nDO\n    PRINT contador\n    contador = contador + 1\nLOOP WHILE contador &lt;= 5\n\n' Con UNTIL (hasta que)\ncontador = 1\nDO UNTIL contador &gt; 5\n    PRINT contador\n    contador = contador + 1\nLOOP\n\n' UNTIL al final\ncontador = 1\nDO\n    PRINT contador\n    contador = contador + 1\nLOOP UNTIL contador &gt; 5\n</code></pre>"},{"location":"estructuras-control/#control-de-flujo-adicional","title":"Control de Flujo Adicional","text":""},{"location":"estructuras-control/#goto","title":"GOTO","text":"<p>Salta a una etiqueta espec\u00edfica:</p> <pre><code>PRINT \"Inicio\"\nGOTO Saltar\nPRINT \"Esto no se imprimir\u00e1\"\nSaltar:\nPRINT \"Despu\u00e9s del salto\"\n</code></pre> <p>Nota: El uso de <code>GOTO</code> generalmente se desaconseja en favor de estructuras de control m\u00e1s estructuradas.</p>"},{"location":"estructuras-control/#gosub-return","title":"GOSUB-RETURN","text":"<p>Llama a una subrutina y regresa:</p> <pre><code>PRINT \"Programa principal\"\nGOSUB Subrutina\nPRINT \"De vuelta en el programa principal\"\nEND\n\nSubrutina:\nPRINT \"Esta es una subrutina\"\nRETURN\n</code></pre> <p>Nota: En QBasic moderno, es preferible usar <code>SUB</code> y <code>FUNCTION</code> en lugar de <code>GOSUB</code>.</p>"},{"location":"estructuras-control/#exit","title":"EXIT","text":"<p>Sale de un bucle antes de tiempo:</p> <pre><code>FOR i = 1 TO 100\n    PRINT i\n    IF i = 10 THEN EXIT FOR\nNEXT i\n\nDO\n    INPUT \"Introduce un n\u00famero (0 para salir): \", num\n    IF num = 0 THEN EXIT DO\n    PRINT \"El cuadrado es:\"; num * num\nLOOP\n</code></pre>"},{"location":"estructuras-control/#ejemplo-combinado","title":"Ejemplo Combinado","text":"<p>Este ejemplo muestra varias estructuras de control trabajando juntas:</p> <pre><code>CLS\nINPUT \"\u00bfCu\u00e1ntos n\u00fameros quieres procesar? \", cantidad\n\nFOR i = 1 TO cantidad\n    PRINT \"N\u00famero\"; i\n    INPUT \"Introduce un valor: \", valor\n\n    IF valor &lt; 0 THEN\n        PRINT \"El valor es negativo\"\n    ELSEIF valor = 0 THEN\n        PRINT \"El valor es cero\"\n    ELSE\n        ' Procesar n\u00fameros positivos\n        SELECT CASE valor\n            CASE 1 TO 10\n                PRINT \"Valor entre 1 y 10\"\n            CASE 11 TO 100\n                PRINT \"Valor entre 11 y 100\"\n            CASE ELSE\n                PRINT \"Valor mayor que 100\"\n        END SELECT\n\n        ' Mostrar todos los divisores\n        PRINT \"Divisores:\";\n        divisores = 0\n\n        j = 1\n        DO WHILE j &lt;= valor\n            IF valor MOD j = 0 THEN\n                PRINT j;\n                divisores = divisores + 1\n            END IF\n            j = j + 1\n        LOOP\n\n        PRINT\n        PRINT \"Total de divisores:\"; divisores\n    END IF\n\n    PRINT\nNEXT i\n\nPRINT \"Programa finalizado\"\n</code></pre>"},{"location":"faq/","title":"Preguntas Frecuentes (FAQ)","text":"<p>Esta secci\u00f3n responde a las preguntas m\u00e1s comunes sobre QBasic, su instalaci\u00f3n, uso y compatibilidad.</p>"},{"location":"faq/#preguntas-generales","title":"Preguntas Generales","text":""},{"location":"faq/#que-es-qbasic","title":"\u00bfQu\u00e9 es QBasic?","text":"<p>QBasic es un entorno de desarrollo integrado (IDE) y lenguaje de programaci\u00f3n basado en BASIC, incluido con MS-DOS 5.0 y versiones posteriores. Es una versi\u00f3n simplificada de Microsoft QuickBASIC, destinada principalmente a principiantes y programadores aficionados.</p>"},{"location":"faq/#cual-es-la-diferencia-entre-qbasic-y-quickbasic","title":"\u00bfCu\u00e1l es la diferencia entre QBasic y QuickBASIC?","text":"<p>QBasic es una versi\u00f3n limitada y gratuita de QuickBASIC 4.5, con las siguientes diferencias principales:</p> <ul> <li>QBasic no incluye un compilador (s\u00f3lo int\u00e9rprete)</li> <li>QBasic no puede crear archivos ejecutables (.EXE)</li> <li>QBasic tiene menos bibliotecas y funcionalidades avanzadas</li> <li>QBasic ven\u00eda incluido gratis con MS-DOS, mientras que QuickBASIC era un producto comercial</li> </ul>"},{"location":"faq/#puede-qbasic-funcionar-en-windows-1011","title":"\u00bfPuede QBasic funcionar en Windows 10/11?","text":"<p>QBasic no funciona nativamente en Windows moderno, pero puede ejecutarse utilizando:</p> <ul> <li>Emuladores de DOS como DOSBox</li> <li>M\u00e1quinas virtuales con MS-DOS</li> <li>Alternativas modernas como QB64 que son compatibles con la sintaxis de QBasic</li> </ul>"},{"location":"faq/#instalacion-y-configuracion","title":"Instalaci\u00f3n y Configuraci\u00f3n","text":""},{"location":"faq/#donde-puedo-obtener-qbasic","title":"\u00bfD\u00f3nde puedo obtener QBasic?","text":"<p>QBasic ven\u00eda incluido con MS-DOS 5.0-6.22. Puedes encontrar copias archivadas en:</p> <ul> <li>WinWorld PC - QBasic 1.x</li> <li>Archive.org - Microsoft QuickBasic</li> </ul>"},{"location":"faq/#como-puedo-ejecutar-qbasic-en-mi-computadora-moderna","title":"\u00bfC\u00f3mo puedo ejecutar QBasic en mi computadora moderna?","text":"<p>La forma m\u00e1s com\u00fan es utilizando DOSBox:</p> <ol> <li>Instala DOSBox desde dosbox.com</li> <li>Crea una carpeta para QBasic</li> <li>Copia los archivos de QBasic (QBASIC.EXE, QBASIC.HLP)</li> <li>Configura DOSBox para montar esa carpeta</li> <li>Ejecuta <code>QBASIC.EXE</code> desde DOSBox</li> </ol> <p>Tambi\u00e9n puedes usar QB64, una versi\u00f3n moderna de QBasic compatible con sistemas actuales.</p>"},{"location":"faq/#cuales-son-los-requisitos-de-sistema-para-qbasic-original","title":"\u00bfCu\u00e1les son los requisitos de sistema para QBasic original?","text":"<p>QBasic original requiere:</p> <ul> <li>DOS 5.0 o superior</li> <li>512 KB de RAM (se recomiendan 640 KB)</li> <li>Disco duro con al menos 1.5 MB de espacio libre</li> <li>Procesador 8088 o superior (funciona mejor con 286 o superior)</li> </ul>"},{"location":"faq/#programacion-en-qbasic","title":"Programaci\u00f3n en QBasic","text":""},{"location":"faq/#como-puedo-comenzar-a-programar-en-qbasic","title":"\u00bfC\u00f3mo puedo comenzar a programar en QBasic?","text":"<ol> <li>Inicia QBasic desde DOSBox o tu entorno preferido</li> <li>Escribe un programa simple, por ejemplo:</li> </ol> <p><code>qbasic    PRINT \"Hola Mundo\"</code></p> <ol> <li>Presiona F5 para ejecutar el programa</li> <li>Utiliza el men\u00fa File &gt; Save para guardar tu programa</li> </ol>"},{"location":"faq/#hay-un-limite-en-el-tamano-de-los-programas-en-qbasic","title":"\u00bfHay un l\u00edmite en el tama\u00f1o de los programas en QBasic?","text":"<p>S\u00ed, QBasic tiene un l\u00edmite aproximado de 160 KB para el c\u00f3digo fuente. Si necesitas crear programas m\u00e1s grandes, considera usar:</p> <ul> <li>M\u00faltiples m\u00f3dulos de c\u00f3digo</li> <li>QuickBASIC en lugar de QBasic</li> <li>Una implementaci\u00f3n moderna como QB64</li> </ul>"},{"location":"faq/#como-puedo-depurar-mi-programa-en-qbasic","title":"\u00bfC\u00f3mo puedo depurar mi programa en QBasic?","text":"<p>QBasic ofrece herramientas b\u00e1sicas de depuraci\u00f3n:</p> <ul> <li>F8 para ejecutar el programa paso a paso</li> <li>F9 para establecer/quitar puntos de interrupci\u00f3n</li> <li>F10 para ejecutar una subrutina completa</li> <li>Puedes agregar la instrucci\u00f3n <code>PRINT</code> para mostrar valores durante la ejecuci\u00f3n</li> <li>Utiliza la ventana Watch para monitorear variables (Alt+F5, Add)</li> </ul>"},{"location":"faq/#qbasic-soporta-graficos","title":"\u00bfQBasic soporta gr\u00e1ficos?","text":"<p>S\u00ed, QBasic incluye comandos para gr\u00e1ficos b\u00e1sicos:</p> <ul> <li><code>SCREEN</code> para establecer el modo gr\u00e1fico</li> <li><code>LINE</code>, <code>CIRCLE</code>, <code>PSET</code> para dibujar formas b\u00e1sicas</li> <li><code>PUT</code> y <code>GET</code> para manipular \u00e1reas de la pantalla</li> <li><code>PAINT</code> para rellenar \u00e1reas</li> <li>Consulta la secci\u00f3n Gr\u00e1ficos para m\u00e1s detalles</li> </ul>"},{"location":"faq/#preguntas-tecnicas-avanzadas","title":"Preguntas T\u00e9cnicas Avanzadas","text":""},{"location":"faq/#como-crear-un-archivo-exe","title":"\u00bfC\u00f3mo crear un archivo EXE?","text":"<p>Para convertir un programa BASIC en un archivo EXE que se ejecute sin necesidad de otro programa, necesitas un compilador. Hay varios disponibles, comerciales y shareware. Normalmente un compilador tiene m\u00e1s caracter\u00edsticas que un int\u00e9rprete, incluyendo la posibilidad de crear TSRs e incorporar c\u00f3digo ensamblador en el programa BASIC.</p>"},{"location":"faq/#como-implementar-soporte-para-raton","title":"\u00bfC\u00f3mo implementar soporte para rat\u00f3n?","text":"<p>Para esto, se deben realizar llamadas al controlador del rat\u00f3n. Puedes crear tu propio cursor de rat\u00f3n en modo texto y hacer que los botones en la pantalla funcionen mediante llamadas a interrupciones del sistema.</p> <pre><code>' Ejemplo simplificado de inicializaci\u00f3n del rat\u00f3n\nSUB InitMouse (present%)\n    DEF SEG = 0\n    present% = 0\n    INT86old 51, 0, 0, 0, 0, 0, 0, present%, 0\nEND SUB\n</code></pre>"},{"location":"faq/#como-leer-un-directorio-del-disco","title":"\u00bfC\u00f3mo leer un directorio del disco?","text":"<p>Para hacer esto, es necesario llamar a interrupciones BIOS. Se pueden implementar rutinas para listar archivos y directorios mediante la interrupci\u00f3n 21h.</p> <pre><code>' Ejemplo simplificado para listar archivos\nSUB ListFiles (path$)\n    DIM DTA AS STRING * 43\n    DEF SEG = VARSEG(DTA)\n    POKE VARPTR(DTA) + 21, 0  ' Atributos de archivo normales\n    ' C\u00f3digo para llamar INT 21h, funci\u00f3n 4Eh\nEND SUB\n</code></pre>"},{"location":"faq/#como-mostrar-archivos-bmp-o-gif","title":"\u00bfC\u00f3mo mostrar archivos BMP o GIF?","text":"<p>Para cargar im\u00e1genes BMP, debes leer la cabecera del archivo, decodificar la informaci\u00f3n y enviarla a la pantalla. Existen rutinas espec\u00edficas para diferentes formatos de archivo:</p> <pre><code>' Ejemplo parcial para cargar un BMP\nSUB LoadBMP (filename$)\n    OPEN filename$ FOR BINARY AS #1\n    ' Leer cabecera BMP\n    ' Decodificar datos\n    ' Mostrar en pantalla\n    CLOSE #1\nEND SUB\n</code></pre>"},{"location":"faq/#como-capturar-ctrl-break-y-ctrl-alt-del","title":"\u00bfC\u00f3mo capturar CTRL-BREAK y CTRL-ALT-DEL?","text":"<p>Esto se hace utilizando la sentencia <code>ON KEY x GOSUB</code>, as\u00ed:</p> <pre><code>KEY 15, CHR$(&amp;H04) + CHR$(70)           'CTRL-BREAK\nKEY 16, CHR$(&amp;H04) + CHR$(&amp;H08) + CHR$(83) 'CTRL-ALT-DEL\nON KEY(15) GOSUB 100\nON KEY(16) GOSUB 200\n\nDO\n  ' C\u00f3digo principal\nLOOP\n\n100 PRINT \"CTRL-BREAK presionado.\"\nRETURN\n\n200 PRINT \"CTRL-ALT-DEL presionado.\"\nRETURN\n</code></pre> <p>Otra forma de deshabilitar CTRL-BREAK es:</p> <pre><code>' DESHABILITAR CTRL-BREAK:                                              \nDIM brk$(3)\n' Primero guardar los vectores actuales:                                  \nDEF SEG=0: FOR i=108 TO 111: brk$(i-108)=STR$(PEEK(i)): NEXT       \n' Luego insertar nuevos vectores de interrupci\u00f3n:                                 \nPOKE 108,83: POKE 109,255: POKE 110,0: POKE 111,240: DEF SEG       \n\n' RESTAURAR CTRL-BREAK:                                              \nDEF SEG=0: FOR i=108 TO 111: POKE i,VAL(brk$(i-108)): NEXT: DEF SEG\n</code></pre>"},{"location":"faq/#como-devolver-un-codigo-de-error-errorlevel-desde-mi-programa","title":"\u00bfC\u00f3mo devolver un c\u00f3digo de error (Errorlevel) desde mi programa?","text":"<p>Debes DECLARAR una rutina no documentada en la biblioteca LIB/QLB predeterminada:</p> <pre><code>DECLARE SUB SalirConCodigo ALIAS \"_EXIT\" (N AS INTEGER)\n' Usar CALL SalirConCodigo(valorRetorno%) en lugar de END o SYSTEM\n</code></pre> <p>El valor pasado debe estar entre 0 y 255, inclusive.</p>"},{"location":"faq/#como-usar-la-soundblaster","title":"\u00bfC\u00f3mo usar la SoundBlaster?","text":"<p>Para utilizar la SoundBlaster, debes hacer llamadas directas al hardware o utilizar rutinas de acceso:</p> <pre><code>' Reproducir un sonido simple en SB\nSUB PlaySound (frequency%, duration%)\n    OUT &amp;H220, &amp;H10 ' Puerto y comando espec\u00edficos para SoundBlaster\n    ' M\u00e1s c\u00f3digo para configurar tono y duraci\u00f3n\nEND SUB\n</code></pre>"},{"location":"faq/#como-leer-un-archivo-dbf","title":"\u00bfC\u00f3mo leer un archivo .DBF?","text":"<p>Los archivos DBF (dBase III+ o IV) tienen una estructura espec\u00edfica con cabecera y registros. Puedes leerlos abriendo el archivo en modo binario y procesando sus estructuras internas.</p>"},{"location":"faq/#como-controlar-com3","title":"\u00bfC\u00f3mo controlar COM3?","text":"<p>Para usar COM3, a veces es necesario intercambiar los puertos COM2 y COM3:</p> <pre><code>' Ejemplo para intercambiar COM2 y COM3\nSUB SwapCOM23\n    DEF SEG = 0\n    SWAP PEEK(&amp;H0402), PEEK(&amp;H0404)\n    SWAP PEEK(&amp;H0403), PEEK(&amp;H0405)\nEND SUB\n</code></pre>"},{"location":"faq/#como-convertir-un-numero-a-binario-y-extraer-un-bit","title":"\u00bfC\u00f3mo convertir un n\u00famero a binario y extraer un bit?","text":"<pre><code>' Convertir a binario\nFUNCTION Binary$ (n%)\n    DIM b$(16)\n    FOR i% = 15 TO 0 STEP -1\n        IF n% AND 2^i% THEN\n            b$(i%) = \"1\"\n        ELSE\n            b$(i%) = \"0\"\n        END IF\n    NEXT\n    Binary$ = \"\"\n    FOR i% = 15 TO 0 STEP -1\n        Binary$ = Binary$ + b$(i%)\n    NEXT\nEND FUNCTION\n\n' Extraer un bit espec\u00edfico (0-15)\nFUNCTION GetBit% (n%, bit%)\n    GetBit% = SGN(n% AND 2^bit%)\nEND FUNCTION\n</code></pre>"},{"location":"faq/#como-hacer-un-cronometraje-preciso-en-basic","title":"\u00bfC\u00f3mo hacer un cronometraje preciso en BASIC?","text":"<p>Para cronometraje preciso, puedes acceder directamente al reloj del sistema:</p> <pre><code>' Cronometraje preciso\nFUNCTION PreciseTimer#\n    DEF SEG = &amp;H40\n    low% = PEEK(&amp;H6C)\n    high% = PEEK(&amp;H6D)\n    overf% = PEEK(&amp;H6E)\n    PreciseTimer# = (65536# * overf% + 256# * high% + low%) / 18.2\nEND FUNCTION\n</code></pre>"},{"location":"faq/#como-hacer-una-verificacion-crc","title":"\u00bfC\u00f3mo hacer una verificaci\u00f3n CRC?","text":"<p>El c\u00f3digo CRC (Cyclic Redundancy Check) permite verificar la integridad de los datos:</p> <pre><code>' Funci\u00f3n CRC-16 simplificada\nFUNCTION CRC16% (data$)\n    DIM i%, j%\n    DIM crc%\n    crc% = 0\n    FOR i% = 1 TO LEN(data$)\n        crc% = crc% XOR (ASC(MID$(data$, i%, 1)) * 256)\n        FOR j% = 0 TO 7\n            IF (crc% AND &amp;H8000) THEN\n                crc% = ((crc% * 2) XOR &amp;H1021)\n            ELSE\n                crc% = crc% * 2\n            END IF\n        NEXT j%\n    NEXT i%\n    CRC16% = crc% AND &amp;HFFFF\nEND FUNCTION\n</code></pre>"},{"location":"faq/#como-reiniciar-la-computadora-desde-un-programa-basic","title":"\u00bfC\u00f3mo reiniciar la computadora desde un programa BASIC?","text":"<p>Esto se hace mediante una instrucci\u00f3n de salida directa al hardware:</p> <pre><code>' Reiniciar la computadora\nOUT &amp;H64, &amp;HFE\n</code></pre>"},{"location":"faq/#como-imprimir-graficos-con-basic","title":"\u00bfC\u00f3mo imprimir gr\u00e1ficos con BASIC?","text":"<p>Para imprimir gr\u00e1ficos, es necesario enviar comandos espec\u00edficos a la impresora:</p> <pre><code>' Ejemplo simplificado para imprimir gr\u00e1ficos\nSUB PrintGraphics (filename$)\n    ' Inicializar la impresora en modo gr\u00e1fico\n    LPRINT CHR$(27) + \"G\";  ' Comando ESC G para modo gr\u00e1fico en algunas impresoras\n    ' Cargar y enviar datos gr\u00e1ficos\nEND SUB\n</code></pre>"},{"location":"faq/#como-hacer-una-entrada-de-texto-controlada-en-basic","title":"\u00bfC\u00f3mo hacer una entrada de texto controlada en BASIC?","text":"<p>Para entrada de texto con control completo, necesitas implementar tu propia rutina:</p> <pre><code>FUNCTION Edit$ (row%, col%, length%, text$)\n    ' Implementaci\u00f3n de edici\u00f3n de texto con control completo\n    ' Manejo de teclas de cursor, inserci\u00f3n/sobreescritura, etc.\nEND FUNCTION\n</code></pre>"},{"location":"faq/#como-leer-y-escribir-directamente-en-la-pantalla-de-texto","title":"\u00bfC\u00f3mo leer y escribir directamente en la pantalla de texto?","text":"<p>Los caracteres se almacenan en la memoria de video usando dos bytes por car\u00e1cter:</p> <pre><code>' Acceso directo a la memoria de video\nDEF SEG = &amp;HB800\nPOKE 0, 65      ' Colocar una A en la esquina superior izquierda\nPOKE 1, 1       ' Colorearla de azul\nX = PEEK(157)   ' Obtener valor ASCII del car\u00e1cter en la esquina superior derecha\n</code></pre>"},{"location":"faq/#como-convertir-un-archivo-basic-interpretado-a-formato-ascii","title":"\u00bfC\u00f3mo convertir un archivo BASIC interpretado a formato ASCII?","text":"<p>GW-BASIC guarda los archivos en formato comprimido, a menos que especifiques <code>,A</code> despu\u00e9s del nombre del archivo. Si no tienes GW-BASIC, puedes usar RB versi\u00f3n 1.58 para convertir los archivos a ASCII.</p>"},{"location":"faq/#compatibilidad-y-alternativas","title":"Compatibilidad y Alternativas","text":""},{"location":"faq/#que-alternativas-modernas-existen-para-qbasic","title":"\u00bfQu\u00e9 alternativas modernas existen para QBasic?","text":"<p>Varias alternativas modernas mantienen la compatibilidad con QBasic:</p> <ul> <li>QB64 - Muy compatible con QBasic pero con capacidades modernas</li> <li>FreeBASIC - Compatible con sintaxis QBasic pero m\u00e1s cercano a C/C++</li> <li>SmallBASIC - Int\u00e9rprete BASIC liviano con sintaxis similar</li> </ul>"},{"location":"faq/#puedo-convertir-mis-programas-de-qbasic-a-otros-lenguajes","title":"\u00bfPuedo convertir mis programas de QBasic a otros lenguajes?","text":"<p>No existe una herramienta autom\u00e1tica completa para convertir c\u00f3digo QBasic a lenguajes modernos, pero:</p> <ul> <li>QB64 permite usar c\u00f3digo QBasic original y compilarlo para sistemas modernos</li> <li>Existen gu\u00edas para migrar manualmente de QBasic a Python, JavaScript y otros lenguajes</li> <li>Las estructuras l\u00f3gicas son similares en muchos lenguajes, lo que facilita la conversi\u00f3n manual</li> </ul>"},{"location":"faq/#los-programas-hechos-en-qbasic-funcionan-en-qb64","title":"\u00bfLos programas hechos en QBasic funcionan en QB64?","text":"<p>En general, s\u00ed. QB64 mantiene una alta compatibilidad con QBasic, con algunas excepciones:</p> <ul> <li>Algunas instrucciones espec\u00edficas de hardware pueden comportarse diferente</li> <li>QB64 tiene extensiones y caracter\u00edsticas adicionales que no existen en QBasic</li> <li>Muy raramente, puede haber peque\u00f1as diferencias de comportamiento en algunas funciones</li> </ul>"},{"location":"faq/#recursos-y-comunidad","title":"Recursos y Comunidad","text":""},{"location":"faq/#existen-comunidades-activas-de-qbasic","title":"\u00bfExisten comunidades activas de QBasic?","text":"<p>S\u00ed, aunque m\u00e1s peque\u00f1as que en a\u00f1os anteriores:</p> <ul> <li>QB64 Forum</li> <li>Reddit r/qbasic</li> <li>Pete's QBasic Site</li> <li>QB64 Discord</li> </ul>"},{"location":"faq/#donde-puedo-encontrar-ejemplos-de-codigo-qbasic","title":"\u00bfD\u00f3nde puedo encontrar ejemplos de c\u00f3digo QBasic?","text":"<p>Puedes encontrar ejemplos en:</p> <ul> <li>QBasic.net</li> <li>Pete's QBasic Site</li> <li>Foros de QB64</li> </ul>"},{"location":"faq/#como-puedo-aprender-mas-sobre-qbasic","title":"\u00bfC\u00f3mo puedo aprender m\u00e1s sobre QBasic?","text":"<p>Consulta estos recursos:</p> <ul> <li>La ayuda integrada de QBasic (presiona F1)</li> <li>El libro \"Microsoft QBasic: Programming for the Absolute Beginner\"</li> <li>Tutoriales en QBasic.net</li> <li>Videos tutoriales de QBasic en YouTube</li> <li>La documentaci\u00f3n completa en este sitio</li> </ul>"},{"location":"faq/#codigos-de-error","title":"C\u00f3digos de Error","text":"<p>Los siguientes c\u00f3digos de error pueden aparecer durante la ejecuci\u00f3n de programas en QBasic. Conocerlos te ayudar\u00e1 a depurar y solucionar problemas en tus programas.</p> C\u00f3digo Mensaje C\u00f3digo Mensaje 1 NEXT without FOR 37 Argument-count mismatch 2 Syntax error 38 Array not defined 3 RETURN without GOSUB 40 Variable required 4 Out of DATA 50 FIELD overflow 5 Illegal function call 51 Internal error 6 Overflow 52 Bad file name or number 7 Out of memory 53 File not found 8 Label not defined 54 Bad file mode 9 Subscript out of range 55 File already open 10 Duplicate definition 56 FIELD statement active 11 Division by zero 57 Device I/O error 12 Illegal in direct mode 58 File already exists 13 Type mismatch 59 Bad record length 14 Out of string space 61 Disk full 16 String formula too complex 62 Input past end of file 17 Cannot continue 63 Bad record number 18 Function not defined 64 Bad file name 19 No RESUME 67 Too many files 20 RESUME without error 68 Device unavailable 24 Device timeout 69 Communication-buffer overflow 25 Device fault 70 Permission denied 26 FOR without NEXT 71 Disk not ready 27 Out of paper 72 Disk-media error 29 WHILE without WEND 73 Feature unavailable 30 WEND without WHILE 74 Rename across disks 33 Duplicate label 75 Path/File access error 35 Subprogram not defined 76 Path not found"},{"location":"faq/#manejo-de-errores","title":"Manejo de Errores","text":"<p>Para controlar estos errores en tus programas, puedes utilizar las sentencias <code>ON ERROR GOTO</code>:</p> <pre><code>ON ERROR GOTO ErrorHandler\n\n' C\u00f3digo principal del programa\nEND\n\nErrorHandler:\n  SELECT CASE ERR\n    CASE 53\n      PRINT \"Error: Archivo no encontrado\"\n    CASE 61\n      PRINT \"Error: Disco lleno\"\n    CASE ELSE\n      PRINT \"Error #\"; ERR; \" en l\u00ednea\"; ERL\n  END SELECT\nRESUME NEXT\n</code></pre>"},{"location":"funciones/","title":"Funciones","text":"<p>QBasic ofrece dos tipos de funciones: las incorporadas (built-in) y las definidas por el usuario. Las funciones permiten reutilizar c\u00f3digo y modularizar la l\u00f3gica del programa.</p>"},{"location":"funciones/#funciones-incorporadas","title":"Funciones Incorporadas","text":"<p>QBasic incluye numerosas funciones predefinidas para operaciones matem\u00e1ticas, manipulaci\u00f3n de cadenas y otras tareas comunes.</p>"},{"location":"funciones/#funciones-matematicas","title":"Funciones Matem\u00e1ticas","text":"Funci\u00f3n Descripci\u00f3n Ejemplo <code>ABS(x)</code> Valor absoluto <code>ABS(-5)</code> devuelve <code>5</code> <code>INT(x)</code> Parte entera <code>INT(3.7)</code> devuelve <code>3</code> <code>FIX(x)</code> Trunca hacia cero <code>FIX(-3.7)</code> devuelve <code>-3</code> <code>SGN(x)</code> Signo (-1, 0, 1) <code>SGN(-5)</code> devuelve <code>-1</code> <code>SQR(x)</code> Ra\u00edz cuadrada <code>SQR(16)</code> devuelve <code>4</code> <code>RND</code> N\u00famero aleatorio entre 0 y 1 <code>RND</code>"},{"location":"funciones/#funciones-trigonometricas","title":"Funciones Trigonom\u00e9tricas","text":"Funci\u00f3n Descripci\u00f3n Ejemplo <code>SIN(x)</code> Seno (x en radianes) <code>SIN(0)</code> devuelve <code>0</code> <code>COS(x)</code> Coseno <code>COS(0)</code> devuelve <code>1</code> <code>TAN(x)</code> Tangente <code>TAN(0)</code> devuelve <code>0</code> <code>ATN(x)</code> Arcotangente <code>ATN(1)</code> devuelve <code>0.785398</code> <p>Para convertir entre grados y radianes:</p> <pre><code>radianes = grados * 3.14159 / 180\ngrados = radianes * 180 / 3.14159\n</code></pre>"},{"location":"funciones/#funciones-logaritmicas-y-exponenciales","title":"Funciones Logar\u00edtmicas y Exponenciales","text":"Funci\u00f3n Descripci\u00f3n Ejemplo <code>LOG(x)</code> Logaritmo natural <code>LOG(2.71828)</code> devuelve <code>1</code> <code>EXP(x)</code> Exponencial (e^x) <code>EXP(1)</code> devuelve <code>2.71828</code>"},{"location":"funciones/#funciones-de-cadena","title":"Funciones de Cadena","text":"Funci\u00f3n Descripci\u00f3n Ejemplo <code>LEN(s$)</code> Longitud de la cadena <code>LEN(\"QBasic\")</code> devuelve <code>6</code> <code>LEFT$(s$, n)</code> n caracteres desde la izquierda <code>LEFT$(\"QBasic\", 1)</code> devuelve <code>\"Q\"</code> <code>RIGHT$(s$, n)</code> n caracteres desde la derecha <code>RIGHT$(\"QBasic\", 5)</code> devuelve <code>\"Basic\"</code> <code>MID$(s$, start, len)</code> Subcadena <code>MID$(\"QBasic\", 2, 3)</code> devuelve <code>\"Bas\"</code> <code>INSTR([start,] s1$, s2$)</code> Posici\u00f3n de s2$ en s1$ <code>INSTR(\"QBasic\", \"as\")</code> devuelve <code>3</code> <code>UCASE$(s$)</code> Convierte a may\u00fasculas <code>UCASE$(\"QBasic\")</code> devuelve <code>\"QBASIC\"</code> <code>LCASE$(s$)</code> Convierte a min\u00fasculas <code>LCASE$(\"QBasic\")</code> devuelve <code>\"qbasic\"</code> <code>LTRIM$(s$)</code> Elimina espacios a la izquierda <code>LTRIM$(\"  QB  \")</code> devuelve <code>\"QB  \"</code> <code>RTRIM$(s$)</code> Elimina espacios a la derecha <code>RTRIM$(\"  QB  \")</code> devuelve <code>\"  QB\"</code> <code>SPACE$(n)</code> Genera n espacios <code>SPACE$(3)</code> devuelve <code>\"   \"</code> <code>STRING$(n, c)</code> Genera n caracteres c <code>STRING$(3, \"X\")</code> devuelve <code>\"XXX\"</code>"},{"location":"funciones/#funciones-de-conversion","title":"Funciones de Conversi\u00f3n","text":"Funci\u00f3n Descripci\u00f3n Ejemplo <code>STR$(n)</code> Convierte n\u00famero a cadena <code>STR$(123)</code> devuelve <code>\" 123\"</code> <code>VAL(s$)</code> Convierte cadena a n\u00famero <code>VAL(\"123\")</code> devuelve <code>123</code> <code>ASC(s$)</code> Valor ASCII del primer car\u00e1cter <code>ASC(\"A\")</code> devuelve <code>65</code> <code>CHR$(n)</code> Car\u00e1cter del valor ASCII <code>CHR$(65)</code> devuelve <code>\"A\"</code> <code>HEX$(n)</code> Convierte a hexadecimal <code>HEX$(255)</code> devuelve <code>\"FF\"</code> <code>OCT$(n)</code> Convierte a octal <code>OCT$(8)</code> devuelve <code>\"10\"</code>"},{"location":"funciones/#funciones-definidas-por-el-usuario","title":"Funciones Definidas por el Usuario","text":""},{"location":"funciones/#funcion-function","title":"Funci\u00f3n FUNCTION","text":"<p>Se define una funci\u00f3n con la palabra clave <code>FUNCTION</code> y se finaliza con <code>END FUNCTION</code>:</p> <pre><code>FUNCTION Cuadrado (numero)\n    Cuadrado = numero * numero\nEND FUNCTION\n</code></pre> <p>Para utilizar la funci\u00f3n:</p> <pre><code>PRINT Cuadrado(5)    ' Muestra 25\nx = Cuadrado(3) + 1  ' x = 10\n</code></pre> <p>Las funciones pueden tener m\u00faltiples par\u00e1metros:</p> <pre><code>FUNCTION Hipotenusa (a, b)\n    Hipotenusa = SQR(a * a + b * b)\nEND FUNCTION\n\nPRINT Hipotenusa(3, 4)  ' Muestra 5\n</code></pre>"},{"location":"funciones/#funcion-def-fn","title":"Funci\u00f3n DEF FN","text":"<p>Una forma m\u00e1s simple pero menos flexible de crear funciones:</p> <pre><code>DEF FNCubo(x) = x * x * x\nPRINT FNCubo(3)  ' Muestra 27\n</code></pre>"},{"location":"funciones/#subrutinas","title":"Subrutinas","text":"<p>Las subrutinas, a diferencia de las funciones, no devuelven valores pero pueden modificar los par\u00e1metros pasados por referencia:</p> <pre><code>DECLARE SUB Intercambiar (a AS INTEGER, b AS INTEGER)\n\na% = 5\nb% = 10\nCALL Intercambiar(a%, b%)\nPRINT a%, b%   ' Muestra 10 5\n\nSUB Intercambiar (a AS INTEGER, b AS INTEGER)\n    temp = a\n    a = b\n    b = temp\nEND SUB\n</code></pre> <p>La palabra <code>CALL</code> es opcional:</p> <pre><code>Intercambiar a%, b%   ' Equivalente a CALL Intercambiar(a%, b%)\n</code></pre>"},{"location":"funciones/#parametros-por-valor-vs-por-referencia","title":"Par\u00e1metros por Valor vs. por Referencia","text":"<p>Por defecto, los par\u00e1metros se pasan por referencia. Para pasar por valor, se utilizan par\u00e9ntesis:</p> <pre><code>DECLARE SUB ModificarValor (a AS INTEGER)\nDECLARE SUB IntentarModificar (a AS INTEGER)\n\nx% = 5\nModificarValor x%         ' Pasa por referencia\nPRINT x%                  ' Muestra 10\nIntentarModificar (x%)    ' Pasa por valor\nPRINT x%                  ' Sigue mostrando 10\n\nSUB ModificarValor (a AS INTEGER)\n    a = a * 2\nEND SUB\n\nSUB IntentarModificar (a AS INTEGER)\n    a = a * 2    ' S\u00f3lo modifica la copia local\nEND SUB\n</code></pre>"},{"location":"funciones/#ejemplo-completo","title":"Ejemplo Completo","text":"<pre><code>DECLARE FUNCTION Factorial! (n AS INTEGER)\nDECLARE SUB MostrarTabla (base AS INTEGER, hasta AS INTEGER)\n\nCLS\nINPUT \"Introduce un n\u00famero para calcular su factorial: \", num%\n\nPRINT \"El factorial de\"; num%; \"es\"; Factorial(num%)\nPRINT\nINPUT \"\u00bfQuieres ver una tabla de factoriales? (S/N) \", respuesta$\n\nIF UCASE$(respuesta$) = \"S\" THEN\n    PRINT\n    MostrarTabla num%, 10\nEND IF\n\nFUNCTION Factorial (n AS INTEGER)\n    IF n &lt;= 1 THEN\n        Factorial = 1\n    ELSE\n        Factorial = n * Factorial(n - 1)\n    END IF\nEND FUNCTION\n\nSUB MostrarTabla (base AS INTEGER, hasta AS INTEGER)\n    PRINT \"Tabla de factoriales:\"\n    PRINT \"N\u00famero\", \"Factorial\"\n    PRINT \"------\", \"---------\"\n\n    FOR i = 1 TO hasta\n        PRINT i, Factorial(i)\n    NEXT i\nEND SUB\n</code></pre> <p>Este ejemplo muestra c\u00f3mo se pueden combinar funciones y subrutinas en un programa QBasic completo, incluyendo el uso de recursividad en la funci\u00f3n <code>Factorial</code>.</p>"},{"location":"gestion-memoria/","title":"Gesti\u00f3n de Memoria en QBasic","text":"<p>Autor original: Thav (Raul Carolus)</p> <p>Este art\u00edculo aborda los problemas comunes de memoria en QBasic, especialmente los errores \"Out of stack space\" (Sin espacio en la pila) y \"Out of memory\" (Sin memoria). Entender c\u00f3mo funciona la memoria en QBasic ayudar\u00e1 a evitar estos errores y a optimizar tus programas.</p>"},{"location":"gestion-memoria/#la-pila-de-ejecucion-runtime-stack","title":"La Pila de Ejecuci\u00f3n (Runtime Stack)","text":"<p>Todo programa en QBasic utiliza un espacio en la pila de ejecuci\u00f3n. Esta pila no almacena variables o datos del programa, sino informaci\u00f3n que controla la ejecuci\u00f3n del mismo.</p>"},{"location":"gestion-memoria/#registros-de-activacion","title":"Registros de Activaci\u00f3n","text":"<p>Cada vez que tu programa se ejecuta o llama a una funci\u00f3n o subrutina, se crea un \"registro de activaci\u00f3n\" (Activation Record) que se a\u00f1ade a la pila. Estos registros contienen:</p> <ul> <li>Direcci\u00f3n de retorno: Indica a qu\u00e9 l\u00ednea del programa debe volver cuando la funci\u00f3n o subrutina termine de ejecutarse</li> <li>Par\u00e1metros: Los valores que se pasan a la funci\u00f3n o subrutina</li> <li>Variables de retorno: El espacio para almacenar el valor que devuelve una funci\u00f3n</li> </ul> <p>Por ejemplo, si llamas a una subrutina <code>Compute</code> desde la l\u00ednea 156 de tu programa:</p> <pre><code>CALL Compute(first%, last%)\n</code></pre> <p>Se crea un registro de activaci\u00f3n con:</p> <ul> <li>Direcci\u00f3n de retorno: 157 (la l\u00ednea siguiente a la llamada)</li> <li>Par\u00e1metros: <code>first%</code> y <code>last%</code></li> </ul>"},{"location":"gestion-memoria/#error-out-of-stack-space","title":"Error \"Out of stack space\"","text":"<p>Este error ocurre cuando la pila de ejecuci\u00f3n se llena por completo. La causa m\u00e1s com\u00fan es una funci\u00f3n recursiva (que se llama a s\u00ed misma) sin una condici\u00f3n de salida:</p> <pre><code>SUB BlowStack()\n  CALL BlowStack()  ' Se llama a s\u00ed misma sin condici\u00f3n de salida\nEND SUB\n</code></pre> <p>Este c\u00f3digo agotar\u00e1 r\u00e1pidamente el espacio en la pila, ya que cada llamada a\u00f1ade un nuevo registro de activaci\u00f3n sin eliminar ninguno.</p>"},{"location":"gestion-memoria/#consejos-para-evitar-errores-de-pila","title":"Consejos para evitar errores de pila","text":"<ol> <li>Mant\u00e9n el bucle principal en la secci\u00f3n principal del programa, no en una subrutina.</li> <li>Evita llamar a muchas subrutinas o funciones desde dentro de otras subrutinas o funciones.</li> <li>Evita usar GOSUB - generalmente es considerado una mala pr\u00e1ctica.</li> </ol> <p>Si necesitas m\u00e1s espacio para la pila, puedes usar la instrucci\u00f3n <code>CLEAR</code>, pero recuerda que esto no resolver\u00e1 problemas de \"Out of Memory\" relacionados con las variables.</p>"},{"location":"gestion-memoria/#variables-y-tipos-de-datos","title":"Variables y Tipos de Datos","text":""},{"location":"gestion-memoria/#tipos-basicos-de-datos","title":"Tipos b\u00e1sicos de datos","text":"<ul> <li>Integer (<code>%</code>): 2 bytes, valores entre -32768 y 32767</li> <li>Long (<code>&amp;</code>): 4 bytes, valores entre -2,147,483,648 y 2,147,483,647</li> <li>Single (<code>!</code>): 4 bytes, precisi\u00f3n simple, rango aproximado \u00b11.401298 E-45 a \u00b13.402823 E+38</li> <li>Double (<code>#</code>): 8 bytes, precisi\u00f3n doble, rango aproximado \u00b14.940656 D-324 a \u00b11.7976931 D+308</li> <li>String (<code>$</code>): 4 bytes para el descriptor y 1 byte por cada car\u00e1cter, longitud m\u00e1xima de 32767 bytes</li> </ul>"},{"location":"gestion-memoria/#estructuras-de-datos-avanzadas","title":"Estructuras de datos avanzadas","text":""},{"location":"gestion-memoria/#arrays-arreglos","title":"Arrays (Arreglos)","text":"<p>Los arrays son colecciones de variables del mismo tipo bajo un solo nombre:</p> <pre><code>DIM scores(0 TO 100) AS INTEGER  ' Crea 101 variables INTEGER\n</code></pre> <p>Para acceder a un elemento:</p> <pre><code>scores(57) = 95  ' Asigna 95 al elemento 57 del array\n</code></pre> <p>Tambi\u00e9n puedes usar variables como \u00edndices:</p> <pre><code>scores(topscore) = 100  ' La variable topscore debe ser INTEGER\n</code></pre>"},{"location":"gestion-memoria/#types-tipos-personalizados","title":"Types (Tipos personalizados)","text":"<p>Los tipos personalizados (similares a los \"structs\" en C) permiten agrupar diferentes tipos de datos bajo un solo nombre:</p> <pre><code>TYPE PersonalInfoType\n  theName AS STRING * 10\n  age AS INTEGER\n  address1 AS STRING * 20\n  address2 AS STRING * 20\nEND TYPE\n</code></pre> <p>Para usar un tipo personalizado:</p> <pre><code>DIM info AS PersonalInfoType\n\ninfo.theName = \"John\"\ninfo.age = 23\n</code></pre> <p>Tambi\u00e9n puedes crear arrays de tipos personalizados:</p> <pre><code>DIM info(3000) AS PersonalInfoType\ninfo(55).theName = \"Jane\"\n</code></pre>"},{"location":"gestion-memoria/#tecnicas-de-optimizacion-de-memoria","title":"T\u00e9cnicas de optimizaci\u00f3n de memoria","text":""},{"location":"gestion-memoria/#uso-de-string-1-como-byte","title":"Uso de STRING * 1 como byte","text":"<p>En lugar de usar un INTEGER de 2 bytes para almacenar valores entre 0 y 255, puedes usar <code>STRING * 1</code> que solo ocupa 1 byte:</p> <pre><code>DIM flags AS STRING * 1\nflags = CHR$(65)  ' Almacena el valor ASCII 65 (letra 'A')\nvalue = ASC(flags)  ' Recupera el valor num\u00e9rico (65)\n</code></pre> <p>Esta t\u00e9cnica es \u00fatil para ahorrar memoria en arrays grandes o al trabajar con archivos binarios mediante <code>BSAVE</code> y <code>BLOAD</code>.</p>"},{"location":"gestion-memoria/#uso-de-types-para-variables-globales","title":"Uso de TYPES para variables globales","text":"<p>Si tienes muchas variables globales relacionadas, es mejor agruparlas en un tipo personalizado:</p> <pre><code>TYPE GameInfoType\n  currentMap AS INTEGER\n  oldMap AS INTEGER\n  playerX AS INTEGER\n  playerY AS INTEGER\nEND TYPE\n\nDIM SHARED gameInfo AS GameInfoType\n</code></pre> <p>Esto organiza mejor tu c\u00f3digo y facilita el paso de m\u00faltiples variables relacionadas entre subrutinas.</p>"},{"location":"gestion-memoria/#optimizacion-de-strings","title":"Optimizaci\u00f3n de strings","text":"<p>El manejo de strings en QBasic puede consumir mucha memoria debido al \"recolector de basura\" ineficiente. Algunas pr\u00e1cticas para optimizar:</p> <ol> <li>Predimensiona los strings cuando sea posible:</li> </ol> <p><code>qbasic    DIM text AS STRING * 80  ' String de longitud fija de 80 caracteres</code></p> <ol> <li>Reutiliza variables de string en lugar de crear nuevas:</li> </ol> <p>```qbasic    ' Mejor    temp$ = \"Hola \"    temp$ = temp$ + \"Mundo\"</p> <p>' Menos eficiente en memoria    greeting$ = \"Hola \"    fullGreeting$ = greeting$ + \"Mundo\"    ```</p> <ol> <li>Libera memoria de strings peri\u00f3dicamente en programas largos:</li> </ol> <p><code>qbasic    a$ = SPACE$(0)  ' Libera la memoria usada por a$</code></p>"},{"location":"gestion-memoria/#consejos-finales","title":"Consejos finales","text":"<ul> <li>Usa el tipo de datos m\u00e1s peque\u00f1o que se ajuste a tus necesidades</li> <li>Optimiza las estructuras de datos para minimizar el desperdicio de memoria</li> <li>Si necesitas trabajar con grandes cantidades de datos, considera usar archivos en lugar de mantener todo en memoria</li> <li>Evita la recursi\u00f3n profunda para prevenir errores de pila</li> <li>Utiliza <code>CLEAR</code> para ajustar el espacio de pila disponible si es necesario</li> </ul> <p>Entender estos conceptos te ayudar\u00e1 a crear programas QBasic m\u00e1s eficientes y estables, evitando los frustrantes errores de memoria.</p>"},{"location":"graficos/","title":"Gr\u00e1ficos","text":"<p>QBasic ofrece capacidades gr\u00e1ficas sorprendentemente potentes para su \u00e9poca. Este cap\u00edtulo cubre desde los comandos b\u00e1sicos de dibujo hasta t\u00e9cnicas avanzadas para trabajar con sprites y cargar gr\u00e1ficos externos.</p>"},{"location":"graficos/#modos-de-pantalla","title":"Modos de Pantalla","text":"<p>El comando <code>SCREEN</code> establece el modo gr\u00e1fico:</p> <pre><code>SCREEN 0  ' Modo texto (80x25 caracteres)\nSCREEN 1  ' Baja resoluci\u00f3n (320x200, 4 colores)\nSCREEN 2  ' Media resoluci\u00f3n (640x200, 2 colores)\nSCREEN 7  ' Media resoluci\u00f3n (320x200, 16 colores) - EGA\nSCREEN 8  ' Alta resoluci\u00f3n (640x200, 16 colores)\nSCREEN 9  ' Alta resoluci\u00f3n (640x350, 16 colores) - EGA\nSCREEN 12 ' Alta resoluci\u00f3n (640x480, 16 colores) - VGA\nSCREEN 13 ' Modo 256 colores (320x200) - VGA\n</code></pre> <p>Para este cap\u00edtulo, usaremos principalmente el modo 7 (EGA 16 colores) para animaci\u00f3n debido a su velocidad y soporte para m\u00faltiples p\u00e1ginas, y el modo 13 (VGA 256 colores) para gr\u00e1ficos m\u00e1s detallados.</p>"},{"location":"graficos/#comandos-basicos-de-dibujo","title":"Comandos B\u00e1sicos de Dibujo","text":""},{"location":"graficos/#pset","title":"PSET","text":"<p>El comando <code>PSET</code> dibuja un punto en las coordenadas especificadas:</p> <pre><code>SCREEN 13\nPSET (160, 100), 12  ' Dibuja un pixel rojo en el centro de la pantalla\n</code></pre>"},{"location":"graficos/#line","title":"LINE","text":"<p>El comando <code>LINE</code> dibuja l\u00edneas y rect\u00e1ngulos:</p> <pre><code>' L\u00ednea simple\nLINE (10, 10)-(100, 50), 14  ' L\u00ednea amarilla\n\n' Rect\u00e1ngulo\nLINE (50, 50)-(150, 100), 10, B  ' Rect\u00e1ngulo verde\n\n' Rect\u00e1ngulo relleno\nLINE (200, 50)-(250, 100), 9, BF ' Rect\u00e1ngulo azul relleno\n</code></pre>"},{"location":"graficos/#circle","title":"CIRCLE","text":"<p>El comando <code>CIRCLE</code> dibuja c\u00edrculos y elipses:</p> <pre><code>' C\u00edrculo simple\nCIRCLE (160, 100), 50, 4  ' C\u00edrculo rojo con radio 50\n\n' Elipse\nCIRCLE (160, 100), 50, 5, , , 0.5  ' Elipse\n\n' Arco\nCIRCLE (160, 100), 40, 12, 0, 3.14  ' Medio c\u00edrculo\n</code></pre>"},{"location":"graficos/#paint","title":"PAINT","text":"<p>El comando <code>PAINT</code> rellena un \u00e1rea cerrada con un color:</p> <pre><code>CIRCLE (160, 100), 50, 15\nPAINT (160, 100), 4, 15  ' Rellena el c\u00edrculo\n</code></pre>"},{"location":"graficos/#trabajando-con-sprites-imagenes","title":"Trabajando con Sprites (Im\u00e1genes)","text":""},{"location":"graficos/#usando-arrays-para-almacenar-graficos","title":"Usando Arrays para Almacenar Gr\u00e1ficos","text":"<p>Para trabajar con sprites en QBasic, necesitamos almacenarlos en arrays. La f\u00f3rmula para calcular el tama\u00f1o del array es:</p> <pre><code>Ancho * Alto / 2 + 1 = Tama\u00f1oArray\n</code></pre> <p>Por ejemplo, para un sprite de 16x16 p\u00edxeles:</p> <pre><code>' 16 * 16 / 2 + 1 = 129\nDIM SHARED Sprite%(129)\n</code></pre>"},{"location":"graficos/#get-y-put","title":"GET y PUT","text":"<p>Los comandos <code>GET</code> y <code>PUT</code> permiten capturar y dibujar \u00e1reas de la pantalla:</p> <pre><code>' Dibujar algo (un c\u00edrculo por ejemplo)\nCIRCLE (20, 20), 8, 14\nPAINT (20, 20), 14, 14\n\n' Guardar en el array\nGET (12, 12)-(28, 28), Sprite%\n\n' Limpiar la pantalla \nCLS\n\n' Dibujar el sprite en otra posici\u00f3n\nPUT (100, 100), Sprite%, PSET\n</code></pre> <p>Opciones del comando <code>PUT</code>:</p> <ul> <li><code>PSET</code>: Dibuja el sprite como est\u00e1 (reemplaza lo que hay)</li> <li><code>PRESET</code>: Invierte los colores</li> <li><code>AND</code>: Operaci\u00f3n AND con lo que ya est\u00e1 en pantalla</li> <li><code>OR</code>: Operaci\u00f3n OR con lo que ya est\u00e1 en pantalla</li> <li><code>XOR</code>: Operaci\u00f3n XOR (\u00fatil para borrar el sprite m\u00e1s tarde)</li> </ul>"},{"location":"graficos/#guia-completa-sobre-sprites-por-ted-felix","title":"Gu\u00eda Completa sobre Sprites (por Ted Felix)","text":""},{"location":"graficos/#que-son-los-sprites","title":"\u00bfQu\u00e9 son los sprites?","text":"<p>Los sprites son peque\u00f1as im\u00e1genes que pueden moverse por la pantalla y animarse. Al usar sprites, se pueden crear juegos con una apariencia m\u00e1s realista. Los sprites son bidimensionales (planos), pero si tienes habilidad para dibujar, puedes hacerlos parecer que tienen profundidad.</p> <p>Por ejemplo, \"The Legend of Zelda\" de Nintendo es un juego completamente basado en sprites, y quiz\u00e1s uno de los mejores. Link y los enemigos son claramente sprites bidimensionales planos. Sin embargo, no hay raz\u00f3n para limitarse a un aspecto 2D cuando puedes simular un aspecto 3D. \"Age of Empires\" es un buen ejemplo de sprites que parecen tridimensionales.</p>"},{"location":"graficos/#creando-un-sprite","title":"Creando un Sprite","text":"<p>Como los sprites son peque\u00f1as im\u00e1genes, necesitamos una imagen para crear un sprite. Hay muchas formas de hacerlo. La forma m\u00e1s simple es dibujar primero la imagen en la pantalla usando las instrucciones gr\u00e1ficas de QBasic:</p> <pre><code>SCREEN 13\nCLS\nCIRCLE (4, 3), 4, 4    ' C\u00edrculo con borde rojo\nPAINT (4, 3), 12, 4    ' Relleno rojo claro\n</code></pre> <p>Una vez que tenemos la imagen en la pantalla, podemos usar <code>GET</code> para copiarla a un array:</p> <pre><code>DIM Ball%(37)          ' Reservar espacio (37 enteros)\nGET (0, 0)-(8, 7), Ball%  ' Copiar de pantalla al array\n</code></pre> <p>\u00bfC\u00f3mo sabemos que necesitamos 37 elementos? Existe una f\u00f3rmula para calcularlo, pero para sprites peque\u00f1os podemos usar prueba y error. QBasic mostrar\u00e1 un error si el array es demasiado peque\u00f1o. Ver el tema de Ayuda \"Screen Image Arrays and Compatibility\" para la f\u00f3rmula.</p> <p>Una vez almacenado el sprite en el array, podemos dibujarlo donde queramos con <code>PUT</code>:</p> <pre><code>PUT (160, 100), Ball%  ' Dibujar en el centro de la pantalla\n</code></pre>"},{"location":"graficos/#moviendo-un-sprite","title":"Moviendo un Sprite","text":"<p>Para animar un sprite, seguimos el mismo principio que en cualquier juego 2D. Mantenemos un registro de la posici\u00f3n X e Y del sprite, y las cambiamos con el tiempo:</p> <pre><code>DEFINT A-Z        ' Hace que las cosas sean m\u00e1s r\u00e1pidas\nSCREEN 13\nCLS\n\n' Dibujar un c\u00edrculo para nuestro sprite\nCIRCLE (4, 3), 4, 4\nPAINT (4, 3), 12, 4\n\nDIM Ball%(37)\nGET (0, 0)-(8, 7), Ball%\nCLS\n\n' Tama\u00f1o de pantalla\nCONST XMax = 320\nCONST YMax = 200\n\n' Posici\u00f3n inicial\nX = 160\nY = 100\n\n' Movimiento\nDX = 1\nDY = 1\n\nDO\n  ' Dibujar el sprite en su posici\u00f3n actual\n  PUT (X, Y), Ball%\n\n  ' Guardar posici\u00f3n anterior\n  PX = X\n  PY = Y\n\n  ' Cambiar la posici\u00f3n\n  X = X + DX\n  Y = Y + DY\n\n  ' Detectar colisiones con los bordes\n  IF X &gt; XMax - 10 THEN DX = -1\n  IF X &lt; 1 THEN DX = 1\n  IF Y &gt; YMax - 9 THEN DY = -1\n  IF Y &lt; 1 THEN DY = 1\n\n  ' Bucle de temporizaci\u00f3n (ajustar seg\u00fan velocidad del PC)\n  FOR I = 1 TO 30000: NEXT I\n\n  ' Borrar el sprite antes de redibujarlo\n  PUT (PX, PY), Ball%\n\nLOOP WHILE INKEY$ = \"\"\n</code></pre> <p>Lo m\u00e1s extra\u00f1o de este ejemplo es c\u00f3mo usa <code>PUT</code> tanto para dibujar como para borrar el sprite. Esto funciona porque <code>PUT</code> dibuja nuestro sprite usando \"exclusive or\" (XOR), lo que permite eliminar la imagen aplic\u00e1ndolo dos veces.</p>"},{"location":"graficos/#sprites-mas-interesantes-con-mapas-de-bits","title":"Sprites m\u00e1s Interesantes con Mapas de Bits","text":"<p>Usar <code>CIRCLE</code> y <code>PAINT</code> es r\u00e1pido, pero es dif\u00edcil dibujar cosas realmente interesantes. Para eso, necesitamos un mapa de bits (bitmap). Un mapa de bits es una imagen almacenada de una manera que la computadora puede entender, generalmente como n\u00fameros:</p> <pre><code>DATA  0,15, 0\nDATA 15, 0,15\nDATA  0,15, 0\n</code></pre> <p>Es como colorear por n\u00fameros. Donde hay un 0, habr\u00e1 un punto negro (p\u00edxel) en la pantalla. Donde hay un 15, habr\u00e1 un p\u00edxel blanco. Este mapa de bits est\u00e1 organizado para ser 3 p\u00edxeles de ancho por 3 de alto.</p> <pre><code>SCREEN 13\nCLS\n\nFOR Y = 0 TO 2\n  FOR X = 0 TO 2\n    READ DotColor\n    PSET (X, Y), DotColor\n  NEXT X\nNEXT Y\n</code></pre> <p>Esto lee el mapa de bits desde las sentencias DATA y lo dibuja en pantalla. Se ver\u00e1 un peque\u00f1o diamante en la esquina superior izquierda.</p> <p>Los mapas de bits pueden ser tan grandes como necesitemos. Aqu\u00ed hay un ejemplo de 15x15 p\u00edxeles que podr\u00eda ser un peque\u00f1o personaje:</p> <pre><code>DATA 00,00,00,00,00,00,00,00,00,00,12,12,00,00,00\nDATA 00,00,00,00,00,00,00,00,00,00,15,15,00,00,00\nDATA 00,00,00,00,00,00,00,00,00,15,15,15,15,00,00\nDATA 00,00,00,00,00,00,00,00,00,15,15,00,15,00,00\nDATA 00,00,00,00,00,00,00,00,15,15,15,15,15,14,00\n' ... (resto del bitmap)\n</code></pre>"},{"location":"graficos/#problemas-con-put-y-alternativas","title":"Problemas con PUT y Alternativas","text":"<p>Aunque <code>PUT</code> es muy \u00fatil, tiene varias limitaciones importantes:</p> <ol> <li> <p>No recorta: Si intentas dibujar un sprite demasiado cerca del borde de la pantalla, QBasic detendr\u00e1 el programa con un error.</p> </li> <li> <p>Problemas con XOR: Aunque XOR es excelente para dibujar y borrar usando el mismo mapa de bits, causa problemas con fondos que no son negros, cambiando los colores del sprite.</p> </li> <li> <p>Forma rectangular: Los sprites con <code>GET</code> y <code>PUT</code> solo pueden ser rectangulares.</p> </li> </ol> <p>Estas limitaciones nos llevan a crear nuestra propia versi\u00f3n de <code>PUT</code> que pueda manejar transparencia y recorte:</p> <pre><code>SUB PUT2 (Sprite() AS INTEGER, XSize AS INTEGER, YSize AS INTEGER, X AS INTEGER, Y AS INTEGER)\n  ' Dibujar el sprite desde el array a la pantalla\n  FOR YP = 0 TO YSize - 1\n    FOR XP = 0 TO XSize - 1\n      PSET (X + XP, Y + YP), Sprite%(XP, YP)\n    NEXT XP\n  NEXT YP\nEND SUB\n</code></pre>"},{"location":"graficos/#cambio-de-pagina-page-flipping","title":"Cambio de P\u00e1gina (Page Flipping)","text":"<p>Una t\u00e9cnica fundamental para evitar el parpadeo en los juegos es el cambio de p\u00e1gina o doble b\u00fafer. Esto permite dibujar en una pantalla invisible mientras el usuario ve otra, y luego intercambiarlas.</p> <pre><code>SCREEN 9, 0, 0, 1  ' Modo EGA: trabajamos en p\u00e1g 0, mostramos p\u00e1g 1\n\n' Dibujamos en la p\u00e1gina invisible (0)\nCLS\n' ... (dibujar aqu\u00ed) ...\n\n' Mostramos la p\u00e1gina completa\nPCOPY 0, 1  ' Copia p\u00e1g 0 (trabajo) a p\u00e1g 1 (visible)\n</code></pre> <p>Desafortunadamente, el cambio de p\u00e1gina con <code>PCOPY</code> solo est\u00e1 disponible en algunos modos de pantalla (7-9), no en el modo 13 (256 colores). Para estos casos, podemos crear nuestro propio sistema de doble b\u00fafer usando un array grande y <code>PUT</code>.</p>"},{"location":"graficos/#transparencia","title":"Transparencia","text":"<p>Para hacer que partes de un sprite sean transparentes, podemos usar un valor especial en el mapa de bits que indique \"no dibujar nada aqu\u00ed\":</p> <pre><code>SUB PUT2Transparent (Sprite() AS INTEGER, XSize AS INTEGER, YSize AS INTEGER, X AS INTEGER, Y AS INTEGER)\n  FOR YP = 0 TO YSize - 1\n    FOR XP = 0 TO XSize - 1\n      IF Sprite%(XP, YP) &lt;&gt; 0 THEN  ' 0 indica transparencia\n        PSET (X + XP, Y + YP), Sprite%(XP, YP)\n      END IF\n    NEXT XP\n  NEXT YP\nEND SUB\n</code></pre>"},{"location":"graficos/#recorte-clipping","title":"Recorte (Clipping)","text":"<p>Para evitar errores cuando los sprites se dibujan cerca de los bordes, debemos verificar los l\u00edmites:</p> <pre><code>SUB PUT2WithClipping (Sprite() AS INTEGER, XSize AS INTEGER, YSize AS INTEGER, X AS INTEGER, Y AS INTEGER)\n  FOR YP = 0 TO YSize - 1\n    IF Y + YP &gt;= 0 AND Y + YP &lt; 200 THEN  ' Verificar l\u00edmite Y\n      FOR XP = 0 TO XSize - 1\n        IF X + XP &gt;= 0 AND X + XP &lt; 320 THEN  ' Verificar l\u00edmite X\n          IF Sprite%(XP, YP) &lt;&gt; 0 THEN  ' Transparencia\n            PSET (X + XP, Y + YP), Sprite%(XP, YP)\n          END IF\n        END IF\n      NEXT XP\n    END IF\n  NEXT YP\nEND SUB\n</code></pre> <p>Con estas t\u00e9cnicas, podemos crear animaciones suaves y visualmente atractivas que formen la base de juegos en QBasic.</p>"},{"location":"graficos/#creacion-de-mapas-de-tiles","title":"Creaci\u00f3n de Mapas de Tiles","text":"<p>Una de las t\u00e9cnicas m\u00e1s utilizadas en juegos de QBasic es la creaci\u00f3n de niveles usando \"tiles\" (baldosas o azulejos). Esta t\u00e9cnica permite crear grandes escenarios usando piezas peque\u00f1as reutilizables.</p>"},{"location":"graficos/#conceptos-basicos-de-tiles","title":"Conceptos B\u00e1sicos de Tiles","text":"<p>Los tiles son peque\u00f1os sprites (generalmente cuadrados) que se colocan en posiciones espec\u00edficas para formar un mapa o nivel. Ventajas:</p> <ul> <li>Ahorro de memoria: solo necesitas definir cada tile una vez</li> <li>Facilidad de edici\u00f3n: puedes crear niveles r\u00e1pidamente</li> <li>Reusabilidad: puedes crear muchos niveles con los mismos tiles</li> </ul>"},{"location":"graficos/#dimensionando-arrays-para-un-sistema-de-tiles","title":"Dimensionando Arrays para un Sistema de Tiles","text":"<p>Para crear un sistema de tiles, necesitas dos tipos de arrays:</p> <ol> <li>Arrays de tiles: Para almacenar cada tipo de tile</li> <li>Array de mapa: Para guardar la disposici\u00f3n de los tiles</li> </ol> <pre><code>' Dimensionar arrays para tiles (10x10 p\u00edxeles cada uno)\nDIM SueloTile(100)\nDIM ParedTile(100)\nDIM AguaTile(100)\n\n' Dimensionar array para mapa (21x15 tiles)\nDIM Mapa(21, 15)\n</code></pre>"},{"location":"graficos/#creando-los-tiles","title":"Creando los Tiles","text":"<p>Para cada tile, usamos la t\u00e9cnica de DATA y GET:</p> <pre><code>SCREEN 13\n\n' Primer tile: suelo\nFOR y = 1 TO 10\n    FOR x = 1 TO 10\n        READ color\n        PSET (x, y), color\n    NEXT x\nNEXT y\nGET (1, 1)-(10, 10), SueloTile\n\n' Tile de suelo (arena marr\u00f3n clara)\nDATA 6,6,6,6,6,6,6,6,6,6\nDATA 6,6,6,6,6,6,6,6,6,6\nDATA 6,6,14,6,6,6,6,6,6,6\nDATA 6,6,6,6,6,6,14,6,6,6\nDATA 6,6,6,6,6,6,6,6,6,6\nDATA 6,6,6,6,14,6,6,6,6,6\nDATA 6,6,6,6,6,6,6,6,6,6\nDATA 6,6,14,6,6,6,6,6,6,6\nDATA 6,6,6,6,6,6,6,14,6,6\nDATA 6,6,6,6,6,6,6,6,6,6\n\n' Segundo tile: pared\nFOR y = 1 TO 10\n    FOR x = 1 TO 10\n        READ color\n        PSET (x, y), color\n    NEXT x\nNEXT y\nGET (1, 1)-(10, 10), ParedTile\n\n' Tile de pared (piedra gris)\nDATA 8,7,8,7,8,7,8,7,8,7\nDATA 7,8,7,8,7,8,7,8,7,8\nDATA 8,7,8,7,8,7,8,7,8,7\nDATA 7,8,7,8,7,8,7,8,7,8\nDATA 8,7,8,7,8,7,8,7,8,7\nDATA 7,8,7,8,7,8,7,8,7,8\nDATA 8,7,8,7,8,7,8,7,8,7\nDATA 7,8,7,8,7,8,7,8,7,8\nDATA 8,7,8,7,8,7,8,7,8,7\nDATA 7,8,7,8,7,8,7,8,7,8\n\n' Tercer tile: agua\nFOR y = 1 TO 10\n    FOR x = 1 TO 10\n        READ color\n        PSET (x, y), color\n    NEXT x\nNEXT y\nGET (1, 1)-(10, 10), AguaTile\n\n' Tile de agua (azul)\nDATA 1,1,1,1,1,1,1,1,1,1\nDATA 1,1,1,1,1,1,1,1,1,1\nDATA 1,1,1,1,9,9,1,1,1,1\nDATA 1,1,1,9,9,9,9,1,1,1\nDATA 1,1,9,9,9,9,9,9,1,1\nDATA 1,1,9,9,9,9,9,9,1,1\nDATA 1,1,1,9,9,9,9,1,1,1\nDATA 1,1,1,1,9,9,1,1,1,1\nDATA 1,1,1,1,1,1,1,1,1,1\nDATA 1,1,1,1,1,1,1,1,1,1\n\nCLS\n</code></pre>"},{"location":"graficos/#cargando-el-diseno-del-mapa","title":"Cargando el Dise\u00f1o del Mapa","text":"<p>A continuaci\u00f3n, cargamos la disposici\u00f3n de los tiles en el array del mapa:</p> <pre><code>' Cargar dise\u00f1o de mapa desde DATA\nFOR y = 1 TO 15\n    FOR x = 1 TO 21\n        READ Mapa(x, y)\n    NEXT x\nNEXT y\n\n' Datos del mapa (1=Suelo, 2=Pared, 3=Agua)\nDATA 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2\nDATA 2,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2\nDATA 2,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2\nDATA 2,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2\nDATA 2,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2\nDATA 2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2\nDATA 2,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2\nDATA 2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2\nDATA 2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2\nDATA 2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2\nDATA 2,1,1,1,1,1,1,1,2,3,3,3,3,3,3,1,1,1,1,1,2\nDATA 2,1,1,1,1,1,1,1,1,3,3,3,3,3,3,1,1,1,1,1,2\nDATA 2,1,1,1,1,1,1,1,2,3,3,3,3,3,3,1,1,1,1,1,2\nDATA 2,1,1,1,1,1,1,1,2,3,3,3,3,3,3,1,1,1,1,1,2\nDATA 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2\n</code></pre>"},{"location":"graficos/#dibujando-el-mapa","title":"Dibujando el Mapa","text":"<p>Finalmente, recorremos el array de mapa y dibujamos cada tile en su posici\u00f3n correspondiente:</p> <pre><code>' Dibujar el mapa en pantalla\nFOR y = 1 TO 15\n    FOR x = 1 TO 21\n        ' Calcular posici\u00f3n en p\u00edxeles\n        pixelX = (x - 1) * 10\n        pixelY = (y - 1) * 10\n\n        ' Determinar qu\u00e9 tile dibujar seg\u00fan el valor en el mapa\n        SELECT CASE Mapa(x, y)\n            CASE 1: PUT (pixelX, pixelY), SueloTile, PSET\n            CASE 2: PUT (pixelX, pixelY), ParedTile, PSET\n            CASE 3: PUT (pixelX, pixelY), AguaTile, PSET\n        END SELECT\n    NEXT x\nNEXT y\n</code></pre>"},{"location":"graficos/#integrando-un-personaje-en-el-mapa-de-tiles","title":"Integrando un Personaje en el Mapa de Tiles","text":"<p>Para a\u00f1adir un personaje que pueda moverse por el mapa:</p> <pre><code>' Crear sprite de personaje (ejemplo simplificado)\nDIM Personaje(100)\nCLS\nCIRCLE (5, 5), 4, 12\nPAINT (5, 5), 12, 12\nGET (1, 1)-(10, 10), Personaje\n\n' Posici\u00f3n inicial del personaje\npersonajeX = 5\npersonajeY = 5\n\n' Dibujar mapa inicial\nGOSUB DibujarMapa\n\n' Bucle principal\nDO\n    k$ = INKEY$\n    IF k$ &lt;&gt; \"\" THEN\n        ' Guardar posici\u00f3n anterior\n        oldX = personajeX\n        oldY = personajeY\n\n        ' Actualizar posici\u00f3n seg\u00fan tecla\n        SELECT CASE k$\n            CASE CHR$(0) + \"H\": personajeY = personajeY - 1  ' Arriba\n            CASE CHR$(0) + \"P\": personajeY = personajeY + 1  ' Abajo\n            CASE CHR$(0) + \"K\": personajeX = personajeX - 1  ' Izquierda\n            CASE CHR$(0) + \"M\": personajeX = personajeX + 1  ' Derecha\n            CASE CHR$(27): EXIT DO  ' ESC para salir\n        END SELECT\n\n        ' Comprobar colisiones con paredes y agua\n        IF Mapa(personajeX, personajeY) = 2 OR Mapa(personajeX, personajeY) = 3 THEN\n            ' Restaurar posici\u00f3n anterior si hay colisi\u00f3n\n            personajeX = oldX\n            personajeY = oldY\n        ELSE\n            ' Redibujar el tile en la posici\u00f3n anterior\n            pixelX = (oldX - 1) * 10\n            pixelY = (oldY - 1) * 10\n            SELECT CASE Mapa(oldX, oldY)\n                CASE 1: PUT (pixelX, pixelY), SueloTile, PSET\n                CASE 2: PUT (pixelX, pixelY), ParedTile, PSET\n                CASE 3: PUT (pixelX, pixelY), AguaTile, PSET\n            END SELECT\n\n            ' Dibujar personaje en nueva posici\u00f3n\n            pixelX = (personajeX - 1) * 10\n            pixelY = (personajeY - 1) * 10\n            PUT (pixelX, pixelY), Personaje, PSET\n        END IF\n    END IF\nLOOP\n\n' Subrutina para dibujar todo el mapa\nDibujarMapa:\nFOR y = 1 TO 15\n    FOR x = 1 TO 21\n        pixelX = (x - 1) * 10\n        pixelY = (y - 1) * 10\n        SELECT CASE Mapa(x, y)\n            CASE 1: PUT (pixelX, pixelY), SueloTile, PSET\n            CASE 2: PUT (pixelX, pixelY), ParedTile, PSET\n            CASE 3: PUT (pixelX, pixelY), AguaTile, PSET\n        END SELECT\n    NEXT x\nNEXT y\nRETURN\n</code></pre>"},{"location":"graficos/#ampliando-el-sistema-de-tiles","title":"Ampliando el Sistema de Tiles","text":"<p>Puedes mejorar el sistema de tiles a\u00f1adiendo caracter\u00edsticas como:</p> <ol> <li>Tiles animados: Cambia el sprite de un tile en cada frame</li> <li>Propiedades por tile: Define comportamientos especiales (da\u00f1o, curaci\u00f3n, etc.)</li> <li>M\u00faltiples capas: Una capa para el suelo, otra para objetos, etc.</li> <li>Scrolling: Para mapas m\u00e1s grandes que la pantalla</li> </ol> <pre><code>' Ejemplo de scroll en un mapa grande (simplificado)\n' Asumimos Mapa(100, 100) para un mapa grande\n\n' Coordenadas de la \"c\u00e1mara\"\ncameraX = 0\ncameraY = 0\n\nSUB DibujarMapaConScroll\n    ' Solo dibuja la parte visible del mapa\n    FOR y = 1 TO 15\n        FOR x = 1 TO 21\n            mapX = x + cameraX\n            mapY = y + cameraY\n\n            ' Verificar que estamos dentro del mapa\n            IF mapX &gt;= 1 AND mapX &lt;= 100 AND mapY &gt;= 1 AND mapY &lt;= 100 THEN\n                pixelX = (x - 1) * 10\n                pixelY = (y - 1) * 10\n\n                SELECT CASE Mapa(mapX, mapY)\n                    CASE 1: PUT (pixelX, pixelY), SueloTile, PSET\n                    CASE 2: PUT (pixelX, pixelY), ParedTile, PSET\n                    CASE 3: PUT (pixelX, pixelY), AguaTile, PSET\n                END SELECT\n            END IF\n        NEXT x\n    NEXT y\nEND SUB\n</code></pre>"},{"location":"graficos/#cargando-gifs-y-paletas-personalizadas","title":"Cargando GIFs y Paletas Personalizadas","text":"<p>QBasic no puede cargar GIFs directamente, pero podemos usar programas auxiliares o t\u00e9cnicas como BSAVE/BLOAD:</p> <pre><code>' Cambiar la paleta de colores\nSUB CargarPaleta (fichero$)\n    filenum% = FREEFILE\n    OPEN fichero$ FOR INPUT AS #filenum%\n    FOR Color% = 0 TO 255\n        INPUT #filenum%, r, g, b\n        OUT &amp;H3C8, Color%\n        OUT &amp;H3C9, r\n        OUT &amp;H3C9, g\n        OUT &amp;H3C9, b\n    NEXT Color%\n    CLOSE #filenum%\nEND SUB\n\n' Cargar una imagen BSAVE desde QBasic\nSUB CargarImagen (fichero$)\n    DEF SEG = &amp;HA000\n    BLOAD fichero$, 0\nEND SUB\n</code></pre>"},{"location":"graficos/#manipulacion-de-paletas-en-qbasic","title":"Manipulaci\u00f3n de Paletas en QBasic","text":"<p>QBasic ofrece potentes capacidades para trabajar con paletas de colores, lo que permite crear efectos visuales impresionantes incluso con las limitaciones gr\u00e1ficas de la \u00e9poca.</p>"},{"location":"graficos/#conceptos-basicos-de-paletas","title":"Conceptos B\u00e1sicos de Paletas","text":"<p>En los modos gr\u00e1ficos de QBasic, especialmente en el modo 13 (320x200 con 256 colores), cada color en pantalla est\u00e1 definido por un valor en la paleta. Esta paleta es esencialmente un array de colores donde cada entrada contiene valores RGB (Rojo, Verde, Azul).</p>"},{"location":"graficos/#el-comando-palette","title":"El Comando PALETTE","text":"<p>La funci\u00f3n <code>PALETTE</code> permite cambiar los valores de color en la paleta:</p> <pre><code>PALETTE color, valor\n</code></pre> <p>Donde:</p> <ul> <li><code>color</code> es el \u00edndice del color a cambiar (0-255 en modo 13)</li> <li><code>valor</code> es el nuevo valor RGB calculado con la f\u00f3rmula:</li> </ul> <pre><code>valor = 65536 * Azul + 256 * Verde + Rojo\n</code></pre> <p>Los valores de Rojo, Verde y Azul pueden variar de 0 a 63, donde 0 es ausencia del color y 63 es la intensidad m\u00e1xima.</p> <p>Ejemplo b\u00e1sico:</p> <pre><code>SCREEN 13\nPALETTE 15, 63     ' Cambia el color 15 a rojo puro\nPRINT \"Este texto es rojo!\"\n</code></pre>"},{"location":"graficos/#ejemplo-de-transicion-de-colores","title":"Ejemplo de Transici\u00f3n de Colores","text":"<pre><code>SCREEN 13\nPRINT \"Color 15 cambiando constantemente!\"\n\nAzul = 63: Verde = 0: Rojo = 0\n\nDO\n  ' Transici\u00f3n de azul a rojo\n  FOR Azul = 63 TO 0 STEP -1\n     Rojo = 63 - Azul\n     valor = 65536 * Azul + 256 * Verde + Rojo\n     PALETTE 15, valor\n     FOR Delay = 1 TO 500: NEXT\n  NEXT\n\n  ' Transici\u00f3n de rojo a verde\n  FOR Rojo = 63 TO 0 STEP -1\n     Verde = 63 - Rojo\n     valor = 65536 * Azul + 256 * Verde + Rojo\n     PALETTE 15, valor\n     FOR Delay = 1 TO 500: NEXT\n  NEXT\n\n  ' Transici\u00f3n de verde a azul\n  FOR Verde = 63 TO 0 STEP -1\n     Azul = 63 - Verde\n     valor = 65536 * Azul + 256 * Verde + Rojo\n     PALETTE 15, valor\n     FOR Delay = 1 TO 500: NEXT\n  NEXT\nLOOP UNTIL INKEY$ &lt;&gt; \"\"\n</code></pre>"},{"location":"graficos/#optimizacion-con-acceso-directo-a-puertos","title":"Optimizaci\u00f3n con Acceso Directo a Puertos","text":"<p>Para manipulaciones avanzadas de paleta, el comando <code>PALETTE</code> puede resultar lento. Una alternativa m\u00e1s eficiente es acceder directamente a los puertos de la tarjeta VGA:</p> <pre><code>' Cambiar el color 15 a p\u00farpura usando puertos\nOUT &amp;H3C8, 15     ' Indicar qu\u00e9 color vamos a modificar\nOUT &amp;H3C9, 63     ' Componente Rojo (0-63)\nOUT &amp;H3C9, 0      ' Componente Verde (0-63)\nOUT &amp;H3C9, 63     ' Componente Azul (0-63)\n</code></pre> <p>Para leer los valores RGB de un color:</p> <pre><code>' Leer los valores RGB del color 15\nOUT &amp;H3C8, 15      ' Seleccionar el color\nRojo = INP(&amp;H3C9)  ' Leer componente Rojo\nVerde = INP(&amp;H3C9) ' Leer componente Verde\nAzul = INP(&amp;H3C9)  ' Leer componente Azul\n</code></pre>"},{"location":"graficos/#aplicaciones-de-la-manipulacion-de-paletas","title":"Aplicaciones de la Manipulaci\u00f3n de Paletas","text":""},{"location":"graficos/#fundidos-a-negro-o-blanco","title":"Fundidos a Negro o Blanco","text":"<pre><code>' Fundido a negro de toda la paleta\nSCREEN 13\n' Dibujamos algo\nLINE (0, 0)-(319, 199), 15, BF\nCIRCLE (160, 100), 50, 4\nPAINT (160, 100), 12, 4\n\n' Guardar la paleta original\nDIM PaletaOriginal(0 TO 255, 0 TO 2)\nFOR C = 0 TO 255\n    OUT &amp;H3C8, C\n    PaletaOriginal(C, 0) = INP(&amp;H3C9) ' Rojo\n    PaletaOriginal(C, 1) = INP(&amp;H3C9) ' Verde\n    PaletaOriginal(C, 2) = INP(&amp;H3C9) ' Azul\nNEXT C\n\n' Fundido a negro\nFOR Intensidad = 63 TO 0 STEP -1\n    FOR C = 0 TO 255\n        OUT &amp;H3C8, C\n        R = PaletaOriginal(C, 0) * Intensidad \\ 63\n        G = PaletaOriginal(C, 1) * Intensidad \\ 63\n        B = PaletaOriginal(C, 2) * Intensidad \\ 63\n        OUT &amp;H3C9, R\n        OUT &amp;H3C9, G\n        OUT &amp;H3C9, B\n    NEXT C\n\n    ' Peque\u00f1a pausa\n    FOR Delay = 1 TO 100: NEXT Delay\nNEXT Intensidad\n</code></pre>"},{"location":"graficos/#efectos-de-rotacion-de-paleta","title":"Efectos de Rotaci\u00f3n de Paleta","text":"<p>La rotaci\u00f3n de paleta es una t\u00e9cnica que permite crear ilusi\u00f3n de movimiento sin redibujar los p\u00edxeles:</p> <pre><code>' Efecto de agua con rotaci\u00f3n de paleta\nSCREEN 13\n\n' Crear una gama de azules\nFOR C = 16 TO 31\n    OUT &amp;H3C8, C\n    OUT &amp;H3C9, 0\n    OUT &amp;H3C9, 0\n    OUT &amp;H3C9, 32 + C\nNEXT C\n\n' Dibujar \"agua\" con esos colores\nFOR Y = 100 TO 199\n    FOR X = 0 TO 319\n        ' Patr\u00f3n ondulante\n        Color = 16 + (SIN(X / 20) * 7 + SIN(Y / 10) * 7) MOD 16\n        PSET (X, Y), Color\n    NEXT X\nNEXT Y\n\n' Rotar la paleta para crear efecto de movimiento\nDO\n    ' Guardar el primer color\n    OUT &amp;H3C8, 16\n    R = INP(&amp;H3C9)\n    G = INP(&amp;H3C9)\n    B = INP(&amp;H3C9)\n\n    ' Desplazar todos los colores\n    FOR C = 16 TO 30\n        OUT &amp;H3C8, C + 1\n        RN = INP(&amp;H3C9)\n        GN = INP(&amp;H3C9)\n        BN = INP(&amp;H3C9)\n\n        OUT &amp;H3C8, C\n        OUT &amp;H3C9, RN\n        OUT &amp;H3C9, GN\n        OUT &amp;H3C9, BN\n    NEXT C\n\n    ' El \u00faltimo color recibe el valor del primero\n    OUT &amp;H3C8, 31\n    OUT &amp;H3C9, R\n    OUT &amp;H3C9, G\n    OUT &amp;H3C9, B\n\n    ' Control de velocidad\n    FOR Delay = 1 TO 200: NEXT Delay\nLOOP UNTIL INKEY$ &lt;&gt; \"\"\n</code></pre>"},{"location":"graficos/#nota-tecnica","title":"Nota T\u00e9cnica","text":"<p>Al leer valores de paleta mediante puertos, algunas tarjetas VGA pueden presentar un error donde el registro solicitado no corresponde al obtenido. Una soluci\u00f3n para este problema es leer cada registro de color dos veces.</p>"},{"location":"graficos/#tutorial-de-paletas-vga-por-brian-bartels","title":"Tutorial de Paletas VGA por Brian Bartels","text":""},{"location":"graficos/#conceptos-de-paletas","title":"Conceptos de Paletas","text":"<p>\u00bfHas notado alguna vez, mientras creas gr\u00e1ficos para alg\u00fan juego en QBasic, que la paleta VGA predeterminada es bastante limitada? \u00bfTe has preguntado si puedes cambiar esos colores? Efectivamente, es posible y es un proceso muy simple.</p> <p>Lo primero que debes entender es que cada color que tu monitor puede mostrar est\u00e1 compuesto por los tres colores primarios: rojo, verde y azul (RGB). Para cambiar los valores RGB de un color espec\u00edfico, solo necesitas usar este comando:</p> <pre><code>PALETTE color, rojo+(verde*256)+(azul*65536)\n</code></pre> <p>Los valores de rojo, verde y azul pueden variar entre 0 y 63. \u00a1Es as\u00ed de simple!</p>"},{"location":"graficos/#temas-avanzados","title":"Temas Avanzados","text":"<p>Despu\u00e9s de experimentar con el comando PALETTE, probablemente hayas notado que es extremadamente lento. La instrucci\u00f3n PALETTE de QBasic es lenta por dos razones:</p> <ol> <li>Tiene que realizar todas esas operaciones matem\u00e1ticas (<code>rojo+verde*256+azul*65536</code>) cada vez que la usas.</li> <li>Cada vez que la usas, espera a que la pantalla se refresque, lo que hace que esta instrucci\u00f3n sea totalmente inutilizable para hacer fundidos de entrada, salida o entre paletas.</li> </ol> <p>\u00bfC\u00f3mo solucionamos este problema? Simplemente escribiendo nuestra propia subrutina PALETTE que no realice todos esos c\u00e1lculos y no espere a que la pantalla se refresque. Esto se puede lograr f\u00e1cilmente con cuatro simples comandos OUT:</p> <pre><code>SUB setpal (col%, r%, g%, b%)\n    OUT &amp;H3C8, col%\n    OUT &amp;H3C9, r%\n    OUT &amp;H3C9, g%\n    OUT &amp;H3C9, b%\nEND SUB\n</code></pre>"},{"location":"graficos/#creando-gradientes-de-colores","title":"Creando Gradientes de Colores","text":"<p>Con una rutina de paleta r\u00e1pida, podemos hacer cosas interesantes como fundir toda la pantalla o crear transiciones entre paletas. Crear gradientes entre colores es m\u00e1s simple de lo que parece.</p> <p>Pensemos en cada color como tres valores: rojo, verde y azul. Veamos c\u00f3mo generar un gradiente entre dos colores:</p> <p>Supongamos que el color n\u00famero 26 es rojo brillante (su valor rojo es 63 y sus valores verde y azul son 0), y el color 65 es azul brillante (su valor azul es 63 y sus valores rojo y verde son 0).</p> <p>Queremos que todos los colores entre el 26 y el 65 formen un gradiente. Primero, almacenamos los valores RGB del primer color (26) en tres variables: <code>r1%</code>, <code>g1%</code> y <code>b1%</code>. Tambi\u00e9n almacenamos los valores RGB del segundo color (65) en tres variables: <code>r2%</code>, <code>g2%</code> y <code>b2%</code>.</p> <p>Luego calculamos cu\u00e1ntos pasos necesitamos en el gradiente (65-26) y cu\u00e1nto debemos incrementar los valores RGB en cada paso:</p> <pre><code>numofsteps% = 65 - 26\nrinc# = (r2% - r1%) / numofsteps%\nginc# = (g2% - g1%) / numofsteps%\nbinc# = (b2% - b1%) / numofsteps%\n</code></pre> <p>Finalmente, utilizamos un bucle FOR para a\u00f1adir estos incrementos a los colores en nuestro gradiente secuencialmente:</p> <pre><code>r# = r1%\ng# = g1%\nb# = b1%\nFOR col% = 27 TO 64\n   r# = r# + rinc#\n   g# = g# + ginc#\n   b# = b# + binc#\n   setpal col%, INT(r#), INT(g#), INT(b#)\nNEXT\n</code></pre>"},{"location":"graficos/#fundidos-de-paleta","title":"Fundidos de Paleta","text":"<p>Para realizar fundidos completos de paleta, aplicamos el mismo principio pero a todos los colores. Necesitamos varios arrays:</p> <pre><code>DIM startpal(2, 255) AS INTEGER    ' Paleta inicial\nDIM endpal(2, 255) AS INTEGER      ' Paleta final\nDIM pal(2, 255) AS DOUBLE          ' Paleta actual\nDIM palinc(2, 255) AS DOUBLE       ' Incrementos\n</code></pre> <p>Estos arrays se utilizan as\u00ed:</p> <ul> <li><code>startpal(0, col%)</code> = valor rojo del color col%</li> <li><code>startpal(1, col%)</code> = valor verde del color col%</li> <li><code>startpal(2, col%)</code> = valor azul del color col%</li> </ul> <p>Para hacer un fundido de entrada, simplemente hacemos que todos los valores de <code>startpal</code> sean cero y que <code>endpal</code> sea la paleta que queremos mostrar. Para un fundido de salida, lo hacemos al rev\u00e9s. Para fundir de una paleta a otra, hacemos que <code>startpal</code> sea igual a la paleta actual y <code>endpal</code> sea la paleta a la que queremos cambiar.</p> <p>El n\u00famero de pasos que utilices determinar\u00e1 la velocidad del fundido:</p> <pre><code>steps% = 50\n\n' Configurar startpal y endpal aqu\u00ed\n\n' Calcular incrementos\nFOR col% = 0 TO 255\n   FOR j% = 0 TO 2\n      palinc(j%, col%) = (endpal(j%, col%) - startpal(j%, col%)) / steps%\n   NEXT\nNEXT\n\n' Inicializar paleta actual\nFOR col% = 0 TO 255\n   FOR j% = 0 TO 2\n      pal(j%, col%) = startpal(j%, col%)\n   NEXT\nNEXT\n\n' Realizar el fundido\nFOR q% = 0 TO steps%\n   FOR col% = 0 TO 255\n      FOR j% = 0 TO 2\n         pal(j%, col%) = pal(j%, col%) + palinc(j%, col%)\n      NEXT\n   NEXT\n\n   ' Aplicar la paleta actual\n   FOR col% = 0 TO 255\n      setpal col%, INT(pal(0, col%)), INT(pal(1, col%)), INT(pal(2, col%))\n   NEXT\nNEXT\n</code></pre>"},{"location":"graficos/#ejemplo-completo-fundido-entre-dos-paletas","title":"Ejemplo Completo: Fundido entre Dos Paletas","text":"<pre><code>SCREEN 13\nDIM startpal(2, 255) AS INTEGER\nDIM endpal(2, 255) AS INTEGER\nDIM pal(2, 255) AS DOUBLE\nDIM palinc(2, 255) AS DOUBLE\n\n' Guardar paleta actual\nFOR col% = 0 TO 255\n    OUT &amp;H3C8, col%\n    startpal(0, col%) = INP(&amp;H3C9)  ' Rojo\n    startpal(1, col%) = INP(&amp;H3C9)  ' Verde\n    startpal(2, col%) = INP(&amp;H3C9)  ' Azul\nNEXT\n\n' Crear una paleta de destino (ejemplo: predominantemente roja)\nFOR col% = 0 TO 255\n    endpal(0, col%) = 63 * (col% MOD 64) / 63  ' Rojo\n    endpal(1, col%) = 31 * (col% MOD 64) / 63  ' Verde\n    endpal(2, col%) = 20 * (col% MOD 64) / 63  ' Azul\nNEXT\n\n' Dibujar algo en pantalla\nLINE (0, 0)-(319, 199), 15, BF\nCIRCLE (160, 100), 80, 4\nPAINT (160, 100), 9, 4\n\n' Realizar fundido\nsteps% = 30\nFOR col% = 0 TO 255\n   FOR j% = 0 TO 2\n      palinc(j%, col%) = (endpal(j%, col%) - startpal(j%, col%)) / steps%\n   NEXT\nNEXT\n\nFOR col% = 0 TO 255\n   FOR j% = 0 TO 2\n      pal(j%, col%) = startpal(j%, col%)\n   NEXT\nNEXT\n\nFOR q% = 0 TO steps%\n   FOR col% = 0 TO 255\n      FOR j% = 0 TO 2\n         pal(j%, col%) = pal(j%, col%) + palinc(j%, col%)\n      NEXT\n   NEXT\n\n   FOR col% = 0 TO 255\n      OUT &amp;H3C8, col%\n      OUT &amp;H3C9, INT(pal(0, col%))\n      OUT &amp;H3C9, INT(pal(1, col%))\n      OUT &amp;H3C9, INT(pal(2, col%))\n   NEXT\n\n   ' Peque\u00f1a pausa para ver el efecto\n   FOR delay% = 1 TO 1000: NEXT\nNEXT\n</code></pre> <p>Con estas t\u00e9cnicas, puedes crear efectos visuales impresionantes en QBasic mediante la manipulaci\u00f3n de paletas.</p>"},{"location":"graficos/#ejemplo-completo-editor-de-tiles-simple","title":"Ejemplo Completo: Editor de Tiles Simple","text":"<pre><code>SCREEN 13\nDIM Tiles%(10, 129)  ' 10 tiles diferentes\nDIM Map%(20, 15)     ' Mapa de 20x15 tiles\n\n' Cargar tiles (simplificado, normalmente usar\u00edas DATA o archivos)\nFOR t = 1 TO 10\n    CIRCLE (8, 8), t, t + 5\n    PAINT (8, 8), t + 1, t + 5\n    GET (0, 0)-(15, 15), Tiles%(t, 0)\n    CLS\nNEXT t\n\n' Inicializar mapa\nFOR y = 0 TO 14\n    FOR x = 0 TO 19\n        Map%(x, y) = 1  ' Tile por defecto\n    NEXT x\nNEXT y\n\n' Dibujar mapa\nSUB DibujarMapa\n    FOR y = 0 TO 14\n        FOR x = 0 TO 19\n            PUT (x * 16, y * 16), Tiles%(Map%(x, y), 0), PSET\n        NEXT x\n    NEXT y\nEND SUB\n\n' Bucle principal (simplificado)\nDibujarMapa\nDO\n    k$ = INKEY$\n    IF k$ &lt;&gt; \"\" THEN\n        IF ASC(k$) = 27 THEN EXIT DO  ' ESC para salir\n    END IF\nLOOP\n</code></pre>"},{"location":"graficos/#recursos-adicionales","title":"Recursos Adicionales","text":"<p>Para aprender m\u00e1s sobre gr\u00e1ficos en QBasic:</p> <ul> <li>Explora ejemplos de juegos en Pete's QBasic Site</li> <li>Consulta tutoriales espec\u00edficos sobre sprites y animaci\u00f3n</li> <li>Prueba QB64 para acceder a capacidades gr\u00e1ficas mejoradas en sistemas modernos</li> </ul>"},{"location":"graficos/#efectos-avanzados","title":"Efectos Avanzados","text":"<p>Esta secci\u00f3n cubre t\u00e9cnicas avanzadas para crear efectos gr\u00e1ficos impresionantes en QBasic, los cuales pueden utilizarse en demos, juegos o para explorar conceptos matem\u00e1ticos de manera visual.</p>"},{"location":"graficos/#plasma-con-ondas-sinusoidales","title":"Plasma con Ondas Sinusoidales","text":"<p>Uno de los efectos m\u00e1s llamativos que se pueden crear en QBasic es el plasma. Aunque estrictamente hablando puede no ser un \"plasma\" f\u00edsico real, este efecto produce patrones coloridos y fluidos que se asemejan a un plasma, especialmente cuando se combinan con rotaci\u00f3n de paleta.</p>"},{"location":"graficos/#fundamentos-matematicos-la-onda-sinusoidal","title":"Fundamentos Matem\u00e1ticos: La Onda Sinusoidal","text":"<p>La base de este efecto es la funci\u00f3n seno (SIN). En QBasic, la funci\u00f3n SIN opera en radianes y devuelve valores en el rango de -1 a 1. Para nuestros prop\u00f3sitos, necesitamos convertir este rango a valores \u00fatiles para colores o coordenadas.</p> <p>Para convertir de grados a radianes:</p> <pre><code>Radianes = Grados * 0.017453  ' Aproximadamente Grados * PI / 180\n</code></pre> <p>Para ajustar el rango de -1 a 1 a un rango de 0 a 100 (por ejemplo):</p> <pre><code>ValorAjustado = (SIN(Radianes) * 50) + 50\n</code></pre>"},{"location":"graficos/#dibujando-una-onda-sinusoidal-basica","title":"Dibujando una Onda Sinusoidal B\u00e1sica","text":"<p>Este c\u00f3digo dibuja una onda sinusoidal b\u00e1sica en la pantalla:</p> <pre><code>SCREEN 13\nFOR x% = 0 TO 359\n  xx% = (x% / 360) * 320        ' Ajustar al ancho de pantalla (320 p\u00edxeles)\n  rd = x% * 0.017453            ' Convertir a radianes\n  y% = (SIN(rd) * 50) + 50      ' Ajustar a un rango de 0-100\n  PSET (xx%, y%), 15            ' Dibujar el punto\nNEXT x%\n</code></pre>"},{"location":"graficos/#mezclando-ondas-sinusoidales","title":"Mezclando Ondas Sinusoidales","text":"<p>La clave para crear patrones de plasma interesantes es mezclar varias ondas sinusoidales con diferentes frecuencias. Esto crea patrones complejos y aparentemente aleatorios:</p> <pre><code>SCREEN 13\nFOR x% = 0 TO 359\n  xx% = (x% / 360) * 320\n  rd = x% * 0.017453\n  ' Mezclar dos ondas sinusoidales con diferentes frecuencias\n  srd = (SIN(rd) + SIN(rd * 2.8)) / 2  ' Promedio de dos ondas\n  y% = (srd * 50) + 50\n  PSET (xx%, y%), 15\nNEXT x%\n</code></pre>"},{"location":"graficos/#aplicando-ondas-sinusoidales-a-la-paleta-de-colores","title":"Aplicando Ondas Sinusoidales a la Paleta de Colores","text":"<p>Podemos usar estos valores sinusoidales para generar paletas de colores din\u00e1micas:</p> <pre><code>SCREEN 13\n' Generar una paleta basada en ondas sinusoidales\nFOR x% = 0 TO 359\n  xx% = (x% / 360) * 100         ' Escalar a 100 colores\n  rd = x% * 0.017453\n  srd = (SIN(rd) + SIN(rd * 2.8)) / 2\n  colorValue = (srd * 31) + 31   ' Ajustar a rango de 0-63 para palette\n\n  OUT &amp;H3C8, xx% + 1             ' Seleccionar color (comenzando desde 1)\n  OUT &amp;H3C9, colorValue          ' Componente rojo\n  OUT &amp;H3C9, 0                   ' Componente verde\n  OUT &amp;H3C9, 0                   ' Componente azul\nNEXT x%\n\n' Dibujar un patr\u00f3n que use los colores\nFOR x% = 1 TO 100\n  FOR y% = 1 TO 100\n    PSET (x%, y%), (x% + y%) / 2\n  NEXT y%\nNEXT x%\n</code></pre>"},{"location":"graficos/#tipos-de-plasmas","title":"Tipos de Plasmas","text":"<p>Esencialmente, existen dos enfoques principales para crear efectos de plasma:</p> <ol> <li> <p>Rotaci\u00f3n de Paleta: R\u00e1pido y eficiente, pero produce plasmas est\u00e1ticos donde solo cambian los colores.</p> </li> <li> <p>Funcional (Trigonom\u00e9trico): M\u00e1s lento pero produce efectos mucho m\u00e1s din\u00e1micos y vers\u00e1tiles, permitiendo animaciones genuinas.</p> </li> </ol> <p>La t\u00e9cnica funcional tiene la ventaja de que puede limitarse a un determinado rango de colores, lo que la hace ideal para su uso en juegos donde no se desea afectar a todo el esquema de colores.</p>"},{"location":"graficos/#creacion-de-paletas-para-plasma","title":"Creaci\u00f3n de Paletas para Plasma","text":"<p>La calidad visual de un plasma depende en gran medida de la paleta de colores utilizada. Es importante crear una paleta que se \"envuelva\" sobre s\u00ed misma, es decir, donde el \u00faltimo color se mezcle suavemente con el primero. Esto permite transiciones suaves en las animaciones de plasma.</p> <p>Para crear una paleta envolvente:</p> <pre><code>' Crear una paleta arco\u00edris envolvente\nFOR c = 0 TO 63\n    ' Rojo: sube, baja, se mantiene bajo\n    IF c &lt; 21 THEN r = c * 3 ELSE IF c &lt; 42 THEN r = 63 - ((c - 21) * 3) ELSE r = 0\n\n    ' Verde: se mantiene bajo, sube, baja\n    IF c &lt; 21 THEN g = 0 ELSE IF c &lt; 42 THEN g = (c - 21) * 3 ELSE g = 63 - ((c - 42) * 3)\n\n    ' Azul: baja, se mantiene bajo, sube\n    IF c &lt; 21 THEN b = 63 - (c * 3) ELSE IF c &lt; 42 THEN b = 0 ELSE b = (c - 42) * 3\n\n    ' Establecer color en la paleta\n    OUT &amp;H3C8, c\n    OUT &amp;H3C9, r\n    OUT &amp;H3C9, g\n    OUT &amp;H3C9, b\nNEXT c\n</code></pre>"},{"location":"graficos/#plasmas-avanzados-combinacion-de-funciones-sinusoidales","title":"Plasmas Avanzados: Combinaci\u00f3n de Funciones Sinusoidales","text":"<p>La clave para crear plasmas visualmente impresionantes es combinar m\u00faltiples funciones sinusoidales con diferentes par\u00e1metros. Cada funci\u00f3n contribuye a la apariencia final del plasma.</p> <pre><code>SCREEN 13\nCONST PI = 3.141593\n\n' Crear una tabla de b\u00fasqueda para la funci\u00f3n SIN\nDIM SinTable(359) AS SINGLE\nFOR i = 0 TO 359\n    SinTable(i) = SIN(i * PI / 180)\nNEXT i\n\n' Variables de movimiento\noffset = 0\n\nDO\n    ' Incrementar offset para animar\n    offset = (offset + 1) MOD 360\n\n    ' Generar plasma\n    FOR y = 0 TO 199\n        FOR x = 0 TO 319\n            ' Combinar m\u00faltiples ondas sinusoidales\n            c1 = SinTable((x * 8 + offset) MOD 360) * 32 + 32\n            c2 = SinTable((y * 8 + offset) MOD 360) * 32 + 32\n            c3 = SinTable(((x + y) * 4 + offset) MOD 360) * 32 + 32\n            c4 = SinTable((SQR((x - 160) ^ 2 + (y - 100) ^ 2) * 2 + offset) MOD 360) * 32 + 32\n\n            ' Combinar valores y convertir a color\n            color = (c1 + c2 + c3 + c4) MOD 64\n\n            ' Dibujar p\u00edxel\n            PSET (x, y), color\n        NEXT x\n    NEXT y\n\n    ' Control de tiempo para no saturar CPU\n    WAIT &amp;H3DA, 8\n\nLOOP UNTIL INKEY$ &lt;&gt; \"\"\n</code></pre> <p>Este c\u00f3digo combina cuatro patrones sinusoidales diferentes:</p> <ol> <li>Una onda horizontal (en funci\u00f3n de x)</li> <li>Una onda vertical (en funci\u00f3n de y)</li> <li>Una onda diagonal (en funci\u00f3n de x+y)</li> <li>Una onda circular (en funci\u00f3n de la distancia al centro)</li> </ol>"},{"location":"graficos/#plasma-en-coordenadas-polares","title":"Plasma en Coordenadas Polares","text":"<p>Tambi\u00e9n se puede crear un plasma utilizando coordenadas polares en lugar de cartesianas, lo que produce efectos visuales diferentes:</p> <pre><code>SCREEN 13\nCONST PI = 3.141593\n\nDO\n    offset = offset + 0.1\n\n    FOR y = 0 TO 199\n        y2 = y - 100\n        FOR x = 0 TO 319\n            x2 = x - 160\n\n            ' Calcular radio y \u00e1ngulo (coordenadas polares)\n            radio = SQR(x2 * x2 + y2 * y2)\n            IF x2 = 0 THEN\n                IF y2 &lt; 0 THEN angulo = -PI / 2 ELSE angulo = PI / 2\n            ELSE\n                angulo = ATN(y2 / x2)\n                IF x2 &lt; 0 THEN angulo = angulo + PI\n            END IF\n\n            ' Aplicar funciones sinusoidales en coordenadas polares\n            c1 = SIN(radio * 0.1 + offset) * 32 + 32\n            c2 = SIN(angulo * 3 + offset) * 32 + 32\n\n            ' Calcular color final\n            color = (c1 + c2) MOD 64\n\n            ' Dibujar p\u00edxel\n            PSET (x, y), color\n        NEXT x\n    NEXT y\n\n    WAIT &amp;H3DA, 8\n\nLOOP UNTIL INKEY$ &lt;&gt; \"\"\n</code></pre>"},{"location":"graficos/#plasmas-semitransparentes","title":"Plasmas Semitransparentes","text":"<p>Se puede crear un efecto de semitransparencia superponiendo dos plasmas diferentes en el mismo fotograma:</p> <pre><code>SCREEN 13\nCONST PI = 3.141593\n\n' Crear un fondo o cargar una imagen\nFOR y = 0 TO 199\n    FOR x = 0 TO 319\n        PSET (x, y), (x + y) MOD 64 + 64\n    NEXT x\nNEXT y\n\nDO\n    offset1 = offset1 + 0.05\n    offset2 = offset2 + 0.07\n\n    FOR y = 0 TO 199 STEP 2  ' Optimizaci\u00f3n: procesar cada 2 p\u00edxeles\n        FOR x = 0 TO 319 STEP 2\n            ' Primer plasma\n            p1 = SIN((x + offset1) * 0.05) * 32 + SIN((y + offset1) * 0.05) * 32\n\n            ' Segundo plasma\n            p2 = SIN(((x + y) * 0.05 + offset2)) * 64\n\n            ' Combinar ambos plasmas con un efecto semitransparente\n            color = (p1 + p2) MOD 64\n\n            ' Aplicar a un bloque de 2x2 para optimizaci\u00f3n\n            PSET (x, y), color\n            PSET (x + 1, y), color\n            PSET (x, y + 1), color\n            PSET (x + 1, y + 1), color\n        NEXT x\n    NEXT y\n\n    WAIT &amp;H3DA, 8\n\nLOOP UNTIL INKEY$ &lt;&gt; \"\"\n</code></pre>"},{"location":"graficos/#optimizaciones-para-mayor-velocidad","title":"Optimizaciones para Mayor Velocidad","text":"<p>Dado que los efectos de plasma pueden ser intensivos en c\u00e1lculos, aqu\u00ed hay varias t\u00e9cnicas de optimizaci\u00f3n:</p> <ol> <li> <p>Tablas de b\u00fasqueda: Precalcular valores de seno/coseno y almacenarlos en arrays.</p> </li> <li> <p>Reducir resoluci\u00f3n: Calcular el plasma a una resoluci\u00f3n menor y ampliar los p\u00edxeles.</p> </li> <li> <p>Usar enteros: Cuando sea posible, utilizar variables enteras en lugar de flotantes.</p> </li> <li> <p>Limitar el \u00e1rea: Generar el plasma solo en una parte de la pantalla.</p> </li> <li> <p>Funciones m\u00e1s simples: A veces, funciones m\u00e1s simples pueden producir resultados similares con mejor rendimiento.</p> </li> <li> <p>C\u00f3digo ensamblador: Para optimizaciones cr\u00edticas, se puede recurrir a rutinas en ensamblador.</p> </li> </ol>"},{"location":"graficos/#aplicaciones-en-juegos-comerciales","title":"Aplicaciones en Juegos Comerciales","text":"<p>Estas t\u00e9cnicas de plasma se han utilizado en numerosos juegos comerciales para crear efectos especiales, fondos din\u00e1micos y transiciones:</p> <ul> <li>La serie Final Fantasy us\u00f3 plasmas para efectos m\u00e1gicos</li> <li>Chrono Trigger utiliz\u00f3 efectos similares para las animaciones de distorsi\u00f3n temporal</li> <li>Bahamut Lagoon incorpor\u00f3 efectos de plasma para representar energ\u00eda m\u00e1gica</li> <li>Seiken Densetsu 3 (Secret of Mana 2) us\u00f3 plasmas para efectos elementales</li> </ul>"},{"location":"graficos/#plasma-en-modo-texto","title":"Plasma en Modo Texto","text":"<p>Incluso es posible crear efectos de plasma en modo texto, utilizando caracteres ASCII para representar diferentes intensidades:</p> <pre><code>SCREEN 0\nWIDTH 80, 25\nCONST PI = 3.141593\n\nDO\n    offset = offset + 0.1\n\n    FOR y = 1 TO 25\n        FOR x = 1 TO 80\n            ' Calcular valor del plasma\n            valor = SIN(x * 0.2 + offset) * 8 + SIN(y * 0.1 + offset) * 8\n            valor = (valor + 16) \\ 2  ' Convertir a rango 0-15\n\n            ' Seleccionar car\u00e1cter seg\u00fan intensidad\n            SELECT CASE valor\n                CASE 0 TO 3: char$ = \" \"\n                CASE 4 TO 7: char$ = \".\"\n                CASE 8 TO 11: char$ = \"o\"\n                CASE 12 TO 15: char$ = \"O\"\n            END SELECT\n\n            ' Imprimir car\u00e1cter\n            LOCATE y, x\n            PRINT char$;\n        NEXT x\n    NEXT y\n\n    ' Pausa para controlar velocidad\n    FOR delay = 1 TO 1000: NEXT delay\n\nLOOP UNTIL INKEY$ &lt;&gt; \"\"\n</code></pre>"},{"location":"graficos/#efecto-de-ondulacion-ripple","title":"Efecto de Ondulaci\u00f3n (Ripple)","text":"<p>El efecto de ondulaci\u00f3n o \"ripple\" permite simular la refracci\u00f3n de la luz a trav\u00e9s de una superficie l\u00edquida ondulante. Este efecto es particularmente \u00fatil para crear animaciones de agua, lagos o cualquier superficie l\u00edquida en movimiento.</p>"},{"location":"graficos/#fundamentos-matematicos","title":"Fundamentos Matem\u00e1ticos","text":"<p>La base del efecto de ondulaci\u00f3n se encuentra en dos conceptos f\u00edsicos principales:</p> <ol> <li>Ondas sinusoidales: El movimiento de la superficie del l\u00edquido sigue un patr\u00f3n sinusoidal.</li> <li>Refracci\u00f3n de la luz: La luz cambia de direcci\u00f3n cuando pasa a trav\u00e9s de la superficie del l\u00edquido.</li> </ol>"},{"location":"graficos/#caso-unidimensional-1d","title":"Caso Unidimensional (1D)","text":"<p>Para entender mejor el concepto, comenzamos con el caso unidimensional. En una onda sinusoidal 1D:</p> <ul> <li>La altura del punto en la onda est\u00e1 dada por <code>y = d + sin(x)</code>, donde <code>d</code> es la profundidad.</li> <li>La pendiente instant\u00e1nea en cualquier punto es el coseno de <code>x</code>.</li> <li>Un rayo de luz que incide verticalmente se refracta seg\u00fan la pendiente de la superficie.</li> </ul> <p>La f\u00f3rmula para calcular la posici\u00f3n horizontal donde aparecer\u00eda un punto despu\u00e9s de la refracci\u00f3n es:</p> <pre><code>u = x - cos(x) * (d + sin(x))\n</code></pre> <p>Donde:</p> <ul> <li><code>x</code> es la posici\u00f3n horizontal original</li> <li><code>d</code> es la profundidad del agua</li> <li><code>u</code> es la nueva posici\u00f3n horizontal despu\u00e9s de la refracci\u00f3n</li> </ul>"},{"location":"graficos/#caso-bidimensional-2d","title":"Caso Bidimensional (2D)","text":"<p>Para crear un efecto de ondulaci\u00f3n 2D, aplicamos los mismos principios pero considerando la distancia desde el centro de la ondulaci\u00f3n:</p> <ol> <li>La distancia desde el centro se calcula usando el teorema de Pit\u00e1goras: <code>distancia = SQR(x^2 + y^2)</code></li> <li>La altura de la onda en un punto es: <code>altura = d + sin(distancia)</code></li> <li>La refracci\u00f3n se calcula para cada componente (X e Y) manteniendo el \u00e1ngulo en el plano XY</li> </ol> <p>Las f\u00f3rmulas finales para calcular las coordenadas despu\u00e9s de la refracci\u00f3n son:</p> <pre><code>magnitud = SQR(x^2 + y^2)\nn = magnitud  ' Para evitar divisi\u00f3n por cero, si n=0 entonces establecer n=1\nangulo = ATN(y / x)  ' Ajustar seg\u00fan el cuadrante\n\nu = (magnitud - (d + a * (SIN(magnitud + w) / n)) * a * COS(magnitud + w)) * COS(angulo)\nv = (magnitud - (d + a * (SIN(magnitud + w) / n)) * a * COS(magnitud + w)) * SIN(angulo)\n</code></pre> <p>Donde:</p> <ul> <li><code>a</code> es la amplitud m\u00e1xima</li> <li><code>w</code> es el par\u00e1metro de animaci\u00f3n (se decrementa para crear el movimiento)</li> <li><code>u</code> y <code>v</code> son las nuevas coordenadas X e Y despu\u00e9s de la refracci\u00f3n</li> </ul>"},{"location":"graficos/#implementacion-en-qbasic","title":"Implementaci\u00f3n en QBasic","text":"<pre><code>SCREEN 13\nCONST PI = 3.14159\n\n' Cargar imagen de fondo\nDIM Fondo(320, 200)\n' Aqu\u00ed cargar\u00edas tu imagen o generar\u00edas un patr\u00f3n\n\n' Par\u00e1metros del efecto\nprofundidad = 2\namplitudMax = 0.5\nw = 0\n\n' Buffer para doble b\u00fafer\nDIM Buffer(320, 200)\n\nDO\n    ' Decrementar el par\u00e1metro de animaci\u00f3n\n    w = w - 0.1\n    IF w &lt; 0 THEN w = 2 * PI\n\n    ' Centro de la pantalla\n    centroX = 160\n    centroY = 100\n\n    ' Radio de la ondulaci\u00f3n\n    radio = 100\n\n    ' Procesar cada p\u00edxel en el \u00e1rea de ondulaci\u00f3n\n    FOR y = centroY - radio TO centroY + radio\n        FOR x = centroX - radio TO centroX + radio\n            ' Calcular desplazamiento desde el centro\n            dx = x - centroX\n            dy = y - centroY\n\n            ' Calcular magnitud (distancia desde el centro)\n            mag = SQR(dx * dx + dy * dy)\n\n            ' Si estamos dentro del radio de ondulaci\u00f3n\n            IF mag &lt;= radio THEN\n                ' Evitar divisi\u00f3n por cero\n                n = mag\n                IF n = 0 THEN n = 1\n\n                ' Calcular fase de la onda\n                fase = mag + w\n\n                ' Calcular nueva magnitud despu\u00e9s de refracci\u00f3n\n                nuevaMag = mag - (profundidad + amplitudMax * (SIN(fase) / n)) * amplitudMax * COS(fase)\n\n                ' Calcular \u00e1ngulo\n                IF dx &lt;&gt; 0 THEN\n                    angulo = ATN(dy / dx)\n                    ' Ajustar para cuadrantes correctos\n                    IF dx &lt; 0 THEN angulo = angulo + PI\n                ELSE\n                    IF dy &gt;= 0 THEN angulo = PI / 2 ELSE angulo = -PI / 2\n                END IF\n\n                ' Calcular nuevas coordenadas\n                u = centroX + nuevaMag * COS(angulo)\n                v = centroY + nuevaMag * SIN(angulo)\n\n                ' Verificar que estamos dentro de los l\u00edmites\n                IF u &gt;= 0 AND u &lt; 320 AND v &gt;= 0 AND v &lt; 200 THEN\n                    ' Obtener color de fondo en (u,v) y colocarlo en (x,y)\n                    Buffer(x, y) = Fondo(u, v)\n                END IF\n            ELSE\n                ' Fuera del radio de ondulaci\u00f3n, copiar directamente\n                Buffer(x, y) = Fondo(x, y)\n            END IF\n        NEXT x\n    NEXT y\n\n    ' Copiar buffer a pantalla\n    ' Aqu\u00ed implementar\u00edas la copia del buffer a la pantalla\n\n    ' Control de tiempo\n    FOR Delay = 1 TO 1000: NEXT Delay\n\nLOOP UNTIL INKEY$ &lt;&gt; \"\"\n</code></pre>"},{"location":"graficos/#optimizaciones","title":"Optimizaciones","text":"<p>Como el efecto de ondulaci\u00f3n es computacionalmente intensivo, hay varias optimizaciones que se pueden aplicar:</p> <ol> <li> <p>Tablas precalculadas: Calcular los valores de seno una sola vez al inicio y almacenarlos en un array.</p> </li> <li> <p>Procesamiento por bloques: Actualizar solo partes de la pantalla en cada fotograma.</p> </li> <li> <p>Uso de WAIT para sincronizaci\u00f3n: Para evitar parpadeos y conseguir un refresco suave.</p> </li> </ol>"},{"location":"graficos/#aplicaciones","title":"Aplicaciones","text":"<p>Este tipo de efectos puede utilizarse para:</p> <ul> <li>Fondos animados en juegos</li> <li>Demostraciones gr\u00e1ficas</li> <li>Visualizaci\u00f3n de m\u00fasica</li> <li>Base para otros efectos como fuego, agua o nubes</li> </ul>"},{"location":"historia/","title":"Historia de QBasic","text":""},{"location":"historia/#origenes","title":"Or\u00edgenes","text":"<p>QBasic tiene sus ra\u00edces en el lenguaje BASIC (Beginners All-purpose Symbolic Instruction Code), creado en 1964 por John G. Kemeny y Thomas E. Kurtz en el Dartmouth College como un lenguaje de programaci\u00f3n educativo. Microsoft entr\u00f3 en la escena del BASIC en 1975 cuando Bill Gates y Paul Allen desarrollaron Altair BASIC para el computador MITS Altair 8800.</p>"},{"location":"historia/#evolucion-del-basic-de-microsoft","title":"Evoluci\u00f3n del BASIC de Microsoft","text":"<ul> <li>1975: Microsoft lanza Altair BASIC</li> <li>1977-1980: Microsoft desarrolla versiones de BASIC para diferentes plataformas</li> <li>1982: Se introduce BASICA (Advanced BASIC) con IBM PC DOS</li> <li>1983: GW-BASIC aparece como una versi\u00f3n mejorada de BASICA</li> <li>1985: Microsoft lanza QuickBASIC 1.0, introduciendo un entorno de desarrollo integrado (IDE)</li> <li>1988: QuickBASIC 4.5, la \u00faltima versi\u00f3n comercial del producto</li> </ul>"},{"location":"historia/#nacimiento-de-qbasic","title":"Nacimiento de QBasic","text":"<p>QBasic fue introducido por Microsoft en 1991 como parte de MS-DOS 5.0. A diferencia de QuickBASIC (que era un producto comercial), QBasic se distribuy\u00f3 gratuitamente con MS-DOS. Era esencialmente una versi\u00f3n limitada de QuickBASIC 4.5, sin el compilador y algunas otras caracter\u00edsticas avanzadas.</p>"},{"location":"historia/#diferencias-entre-qbasic-y-quickbasic","title":"Diferencias entre QBasic y QuickBASIC","text":"Caracter\u00edstica QBasic QuickBASIC Compilador No (solo int\u00e9rprete) S\u00ed Precio Gratuito (incluido con MS-DOS) Producto comercial Creaci\u00f3n de EXE No S\u00ed Soporte para librer\u00edas Limitado Completo Versi\u00f3n m\u00e1xima 1.1 4.5"},{"location":"historia/#versiones-de-qbasic","title":"Versiones de QBasic","text":"<ul> <li>QBasic 1.0: Incluido con MS-DOS 5.0 (1991)</li> <li>QBasic 1.1: Incluido con MS-DOS 6.0-6.22 y Windows 95 (1993-1995)</li> </ul>"},{"location":"historia/#legado-e-impacto","title":"Legado e Impacto","text":"<p>QBasic jug\u00f3 un papel crucial en la educaci\u00f3n inform\u00e1tica durante los a\u00f1os 90. Muchos programadores actuales tuvieron su primer contacto con la programaci\u00f3n a trav\u00e9s de QBasic debido a su accesibilidad y a que ven\u00eda preinstalado en muchos ordenadores con MS-DOS.</p> <p>Aunque Microsoft dej\u00f3 de desarrollar QBasic tras la versi\u00f3n 1.1, su legado contin\u00faa a trav\u00e9s de proyectos como:</p> <ul> <li>QB64: Un compilador y entorno moderno que mantiene compatibilidad con QBasic pero permite crear aplicaciones para sistemas operativos modernos.</li> <li>FreeBASIC: Un compilador de c\u00f3digo abierto que soporta gran parte de la sintaxis de QBasic/QuickBASIC.</li> <li>SmallBASIC: Un int\u00e9rprete BASIC que incorpora elementos de QBasic y otras variantes del lenguaje.</li> </ul> <p>La simplicidad y facilidad de uso de QBasic siguen siendo caracter\u00edsticas valoradas en los lenguajes de programaci\u00f3n educativos actuales.</p>"},{"location":"implementaciones/","title":"Implementaciones y Herramientas Relacionadas","text":"<p>QBasic ha inspirado el desarrollo de varias herramientas modernas que buscan mantener vivo su legado, mejorar sus capacidades o proporcionar compatibilidad en sistemas operativos actuales.</p>"},{"location":"implementaciones/#versiones-de-microsoft-basic","title":"Versiones de Microsoft BASIC","text":""},{"location":"implementaciones/#cronologia-de-basic-de-microsoft","title":"Cronolog\u00eda de BASIC de Microsoft","text":"Versi\u00f3n A\u00f1o Caracter\u00edsticas principales Altair BASIC 1975 Primera versi\u00f3n de Microsoft BASIC BASIC-80 1978 Para sistemas CP/M GW-BASIC 1983 Para MS-DOS, compatible con BASICA QuickBASIC 1.0 1985 Primer IDE, primeros pasos hacia el BASIC estructurado QuickBASIC 4.5 1988 \u00daltima versi\u00f3n comercial, caracter\u00edstica completas QBasic 1.0 1991 Incluido con MS-DOS 5.0, versi\u00f3n sin compilador de QB4.5 QBasic 1.1 1993 Incluido con MS-DOS 6.0 y versiones posteriores Visual Basic 1.0 1991 Enfoque de programaci\u00f3n visual para Windows"},{"location":"implementaciones/#comparativa-entre-qbasic-y-quickbasic","title":"Comparativa entre QBasic y QuickBASIC","text":"Caracter\u00edstica QBasic 1.1 QuickBASIC 4.5 IDE S\u00ed S\u00ed Compilador No S\u00ed Precio Gratuito (con MS-DOS) Producto comercial L\u00edmite de tama\u00f1o de programa 160KB 160KB (entorno) / Sin l\u00edmite (compilaci\u00f3n) Bibliotecas adicionales No S\u00ed Soporte de EXE No S\u00ed Depurador Limitado Completo"},{"location":"implementaciones/#implementaciones-modernas","title":"Implementaciones Modernas","text":""},{"location":"implementaciones/#qb64","title":"QB64","text":"<p>QB64 es un moderno entorno de desarrollo y compilador compatible con QBasic pero que proporciona acceso a hardware y caracter\u00edsticas modernas.</p>"},{"location":"implementaciones/#caracteristicas-principales","title":"Caracter\u00edsticas principales","text":"<ul> <li>Compatible con sintaxis QBasic/QuickBASIC</li> <li>Genera ejecutables nativos para Windows, macOS y Linux</li> <li>Soporta resoluciones modernas y acceso a hardware moderno</li> <li>Permite llamadas a bibliotecas externas (OpenGL, SDL, etc.)</li> <li>Comunidad activa y en desarrollo continuo</li> </ul>"},{"location":"implementaciones/#ejemplo-de-codigo-qb64-extension-especifica","title":"Ejemplo de c\u00f3digo QB64 (extensi\u00f3n espec\u00edfica)","text":"<pre><code>' Ejemplo que utiliza caracter\u00edsticas modernas exclusivas de QB64\nSCREEN _NEWIMAGE(1280, 720, 32)  ' Resoluci\u00f3n HD con 32 bits de color\n_TITLE \"Ventana de QB64\"\nLINE (0, 0)-(1280, 720), _RGB(255, 0, 0), BF\n_DISPLAY\n</code></pre>"},{"location":"implementaciones/#freebasic","title":"FreeBASIC","text":"<p>FreeBASIC es un compilador de BASIC gratuito y de c\u00f3digo abierto que soporta m\u00faltiples dialectos, incluyendo QBasic.</p>"},{"location":"implementaciones/#caracteristicas-principales_1","title":"Caracter\u00edsticas principales","text":"<ul> <li>Compatible con sintaxis QBasic</li> <li>Sintaxis extendida m\u00e1s cercana a C/C++</li> <li>Dise\u00f1ado para alto rendimiento</li> <li>Soporte para programaci\u00f3n orientada a objetos</li> <li>Integraci\u00f3n con bibliotecas C/C++</li> </ul>"},{"location":"implementaciones/#ejemplo-de-codigo-freebasic","title":"Ejemplo de c\u00f3digo FreeBASIC","text":"<pre><code>' Ejemplo FreeBASIC con caracter\u00edsticas extendidas\n#include \"fbgfx.bi\"\n\nSCREENRES 640, 480, 32\nWINDOWTITLE \"Ventana FreeBASIC\"\n\nDIM AS SINGLE x, y\nDIM AS INTEGER tecla\n\nDO\n    SCREENLOCK\n    CLS\n    CIRCLE (x, y), 20, RGB(255, 0, 0)\n    SCREENUNLOCK\n\n    tecla = GETKEY()\n\n    SELECT CASE tecla\n        CASE ASC(\"w\"): y = y - 5\n        CASE ASC(\"s\"): y = y + 5\n        CASE ASC(\"a\"): x = x - 5\n        CASE ASC(\"d\"): x = x + 5\n        CASE 27: EXIT DO  ' ESC para salir\n    END SELECT\n\n    SLEEP 10\nLOOP\n</code></pre>"},{"location":"implementaciones/#smallbasic","title":"SmallBASIC","text":"<p>SmallBASIC es un int\u00e9rprete BASIC port\u00e1til orientado a la programaci\u00f3n de aplicaciones matem\u00e1ticas y educativas.</p>"},{"location":"implementaciones/#caracteristicas-principales_2","title":"Caracter\u00edsticas principales","text":"<ul> <li>Sintaxis inspirada en QBasic y otras variantes</li> <li>Altamente port\u00e1til (Windows, Linux, Android, etc.)</li> <li>Enfocado en programaci\u00f3n matem\u00e1tica</li> <li>Soporta gr\u00e1ficos 2D y 3D b\u00e1sicos</li> <li>F\u00e1cil de aprender y usar</li> </ul>"},{"location":"implementaciones/#thinbasic","title":"ThinBASIC","text":"<p>ThinBASIC es un lenguaje de programaci\u00f3n BASIC moderno para Windows.</p>"},{"location":"implementaciones/#caracteristicas-principales_3","title":"Caracter\u00edsticas principales","text":"<ul> <li>Inspirado en QBasic y otros dialectos BASIC</li> <li>Orientado a la creaci\u00f3n de aplicaciones Windows</li> <li>Sistema de m\u00f3dulos para extender funcionalidad</li> <li>Amplio soporte para API de Windows</li> </ul>"},{"location":"implementaciones/#emulacion-de-qbasic-original","title":"Emulaci\u00f3n de QBasic Original","text":"<p>Para ejecutar el aut\u00e9ntico QBasic en sistemas modernos, existen varias opciones:</p>"},{"location":"implementaciones/#dosbox","title":"DOSBox","text":"<p>DOSBox es el emulador m\u00e1s com\u00fan para ejecutar QBasic en sistemas modernos.</p>"},{"location":"implementaciones/#configuracion-para-un-rendimiento-optimo","title":"Configuraci\u00f3n para un rendimiento \u00f3ptimo","text":"<pre><code>[dosbox]\nmemsize=16\ncycles=max\n\n[cpu]\ncore=dynamic\ncputype=pentium_slow\n</code></pre>"},{"location":"implementaciones/#dosemu-linux","title":"DOSEMU (Linux)","text":"<p>Para usuarios de Linux, DOSEMU proporciona una alternativa a DOSBox con mejor integraci\u00f3n con el sistema.</p>"},{"location":"implementaciones/#vdos-windows","title":"vDos (Windows)","text":"<p>vDos es un entorno DOS especializado para Windows que puede ofrecer mejor rendimiento que DOSBox para aplicaciones como QBasic.</p>"},{"location":"implementaciones/#recursos-para-desarrolladores","title":"Recursos para Desarrolladores","text":""},{"location":"implementaciones/#herramientas-auxiliares","title":"Herramientas Auxiliares","text":"<ul> <li>Pete's QBasic Site (PQS): Conjunto de herramientas y utilidades para QBasic</li> <li>QBasic Accelerator: Mejora el rendimiento de programas QBasic</li> <li>Future Library: Biblioteca de extensi\u00f3n para QBasic que a\u00f1ade funciones modernas</li> <li>QbScreenLib: Biblioteca para manejo avanzado de pantalla en QBasic</li> </ul>"},{"location":"implementaciones/#editores-modernos-con-soporte-para-qbasic","title":"Editores modernos con soporte para QBasic","text":"<ul> <li>Visual Studio Code con extensi\u00f3n \"QBasic\"</li> <li>Notepad++ con definici\u00f3n de sintaxis QBasic</li> <li>Vim/Neovim con resaltado de sintaxis para QBasic</li> </ul>"},{"location":"instalacion/","title":"Instalaci\u00f3n y Configuraci\u00f3n","text":"<p>QBasic es un software antiguo dise\u00f1ado para MS-DOS, por lo que instalar y ejecutarlo en sistemas operativos modernos requiere el uso de emuladores o herramientas espec\u00edficas.</p>"},{"location":"instalacion/#obtener-qbasic","title":"Obtener QBasic","text":"<p>QBasic ven\u00eda incluido en MS-DOS 5.0 hasta MS-DOS 6.22, as\u00ed como en algunas versiones tempranas de Windows. Puedes encontrar copias archivadas en:</p> <ul> <li>WinWorld PC - QBasic 1.x</li> <li>Archive.org - Microsoft QuickBasic</li> </ul> <p>Los archivos principales que necesitas son:</p> <ul> <li><code>QBASIC.EXE</code> - El entorno de desarrollo integrado</li> <li><code>QBASIC.HLP</code> - El archivo de ayuda</li> </ul>"},{"location":"instalacion/#instalacion-en-sistemas-modernos","title":"Instalaci\u00f3n en sistemas modernos","text":""},{"location":"instalacion/#usando-dosbox","title":"Usando DOSBox","text":"<p>DOSBox es un emulador de DOS que te permite ejecutar QBasic en sistemas operativos modernos.</p> <ol> <li>Instala DOSBox:</li> <li>Windows: Descarga el instalador desde dosbox.com</li> <li>macOS: <code>brew install dosbox</code> con Homebrew</li> <li> <p>Linux: <code>sudo apt install dosbox</code> (Ubuntu/Debian) o equivalente</p> </li> <li> <p>Configura DOSBox:</p> </li> <li>Crea una carpeta en tu sistema para los archivos de QBasic (por ejemplo, <code>C:\\QBasic</code> en Windows)</li> <li>Copia <code>QBASIC.EXE</code> y <code>QBASIC.HLP</code> a esta carpeta</li> <li>Abre el archivo de configuraci\u00f3n de DOSBox (normalmente en <code>~/.dosbox/dosbox-0.74.conf</code> en Linux/macOS o <code>C:\\Users\\[Usuario]\\AppData\\Local\\DOSBox\\dosbox-0.74.conf</code> en Windows)</li> <li> <p>A\u00f1ade al final:</p> <p><code>text  [autoexec]  mount c C:\\QBasic  c:</code></p> <p>(Ajusta la ruta seg\u00fan la ubicaci\u00f3n de tu carpeta)</p> </li> <li> <p>Ejecuta QBasic:</p> </li> <li>Inicia DOSBox</li> <li>Ejecuta <code>QBASIC.EXE</code> escribiendo <code>qbasic</code> y presionando Enter</li> </ol>"},{"location":"instalacion/#alternativa-qb64","title":"Alternativa: QB64","text":"<p>QB64 es una versi\u00f3n moderna de QBasic compatible con sistemas actuales.</p> <ol> <li>Descarga QB64:</li> <li> <p>Visita https://qb64.com/ y descarga la versi\u00f3n para tu sistema operativo</p> </li> <li> <p>Instalaci\u00f3n:</p> </li> <li>Windows: Descomprime el archivo descargado y ejecuta <code>qb64.exe</code></li> <li>macOS/Linux: Descomprime el archivo y ejecuta <code>./qb64</code></li> </ol> <p>QB64 ofrece compatibilidad con programas QBasic originales pero a\u00f1ade caracter\u00edsticas modernas como soporte para resoluciones m\u00e1s altas, m\u00e1s memoria, y la capacidad de compilar a ejecutables nativos.</p>"},{"location":"instalacion/#configuracion-del-entorno-de-desarrollo","title":"Configuraci\u00f3n del entorno de desarrollo","text":""},{"location":"instalacion/#en-qbasic-original-via-dosbox","title":"En QBasic original (v\u00eda DOSBox)","text":"<ol> <li>Ajustes de pantalla:</li> <li>Presiona Alt+Enter para cambiar entre pantalla completa y ventana</li> <li> <p>Ajusta la resoluci\u00f3n de DOSBox en el archivo de configuraci\u00f3n si es necesario</p> </li> <li> <p>Opciones de QBasic:</p> </li> <li>Dentro de QBasic, accede al men\u00fa <code>Options</code> para configurar:<ul> <li><code>Display...</code>: Cambia colores y disposici\u00f3n del editor</li> <li><code>Environment...</code>: Configura tabulaciones y otros aspectos</li> </ul> </li> </ol>"},{"location":"instalacion/#en-qb64","title":"En QB64","text":"<ol> <li>Opciones de visualizaci\u00f3n:</li> <li> <p>Men\u00fa <code>View &gt; Options</code> para ajustar colores, fuentes y comportamiento del editor</p> </li> <li> <p>Carpetas de trabajo:</p> </li> <li>Configura las carpetas por defecto desde el men\u00fa <code>File &gt; Preferences</code></li> </ol>"},{"location":"instalacion/#recursos-adicionales","title":"Recursos adicionales","text":"<ul> <li>Gu\u00eda de DOSBox - Wiki oficial con instrucciones detalladas</li> <li>QB64 Phoenix Edition Wiki - Documentaci\u00f3n actualizada para QB64</li> </ul>"},{"location":"instrucciones/","title":"Instrucciones B\u00e1sicas","text":"<p>Las instrucciones b\u00e1sicas de QBasic son los comandos fundamentales que permiten realizar operaciones esenciales como entrada/salida, asignaci\u00f3n de variables y control del flujo de ejecuci\u00f3n.</p>"},{"location":"instrucciones/#entrada-y-salida","title":"Entrada y Salida","text":""},{"location":"instrucciones/#print","title":"PRINT","text":"<p>La instrucci\u00f3n <code>PRINT</code> muestra informaci\u00f3n en la pantalla:</p> <pre><code>PRINT \"Hola Mundo\"            ' Muestra texto\nPRINT variable                ' Muestra el valor de una variable\nPRINT \"Valor:\"; variable      ' Muestra texto y variable juntos\nPRINT \"A\"; \"B\"; \"C\"           ' Usa punto y coma para juntar sin espacios\nPRINT \"X\", \"Y\", \"Z\"           ' Usa coma para separar en columnas\nPRINT TAB(10); \"Tabulado\"     ' Tabula a la posici\u00f3n 10\nPRINT SPC(5); \"Espaciado\"     ' A\u00f1ade 5 espacios\n</code></pre> <p>Para imprimir sin salto de l\u00ednea al final, termina con punto y coma:</p> <pre><code>PRINT \"Esto no salta l\u00ednea\";\nPRINT \" y contin\u00faa aqu\u00ed\"\n</code></pre>"},{"location":"instrucciones/#input","title":"INPUT","text":"<p>La instrucci\u00f3n <code>INPUT</code> solicita datos al usuario:</p> <pre><code>INPUT \"\u00bfCu\u00e1l es tu nombre? \", nombre$\nINPUT \"Introduce tu edad: \", edad%\n</code></pre> <p>Para evitar que aparezca el signo de interrogaci\u00f3n:</p> <pre><code>INPUT; \"Introduce un valor: \", valor\n</code></pre>"},{"location":"instrucciones/#line-input","title":"LINE INPUT","text":"<p>Para leer una l\u00ednea completa incluyendo comas y otros caracteres especiales:</p> <pre><code>LINE INPUT \"Introduce una frase: \", frase$\n</code></pre>"},{"location":"instrucciones/#asignacion-de-variables","title":"Asignaci\u00f3n de Variables","text":"<p>La asignaci\u00f3n de valores a variables se realiza con el operador <code>=</code>:</p> <pre><code>nombre$ = \"Juan\"\nedad% = 25\npi# = 3.14159\n</code></pre> <p>La instrucci\u00f3n <code>LET</code> es opcional en QBasic:</p> <pre><code>LET contador = contador + 1  ' Equivalente a: contador = contador + 1\n</code></pre>"},{"location":"instrucciones/#control-de-pantalla","title":"Control de Pantalla","text":""},{"location":"instrucciones/#cls","title":"CLS","text":"<p>Limpia la pantalla:</p> <pre><code>CLS\n</code></pre>"},{"location":"instrucciones/#locate","title":"LOCATE","text":"<p>Posiciona el cursor en una fila y columna espec\u00edficas:</p> <pre><code>LOCATE 10, 20  ' Posiciona en la fila 10, columna 20\nPRINT \"Texto posicionado\"\n</code></pre>"},{"location":"instrucciones/#color","title":"COLOR","text":"<p>Cambia los colores de texto y fondo:</p> <pre><code>COLOR 14, 1  ' Texto amarillo (14) sobre fondo azul (1)\nPRINT \"Texto coloreado\"\n</code></pre>"},{"location":"instrucciones/#temporizacion","title":"Temporizaci\u00f3n","text":""},{"location":"instrucciones/#sleep","title":"SLEEP","text":"<p>Pausa la ejecuci\u00f3n del programa durante un n\u00famero espec\u00edfico de segundos:</p> <pre><code>PRINT \"Espera 2 segundos...\"\nSLEEP 2\nPRINT \"\u00a1Listo!\"\n</code></pre>"},{"location":"instrucciones/#declaracion-de-variables","title":"Declaraci\u00f3n de Variables","text":""},{"location":"instrucciones/#dim","title":"DIM","text":"<p>Declara y reserva espacio para variables simples y arrays:</p> <pre><code>DIM nombre AS STRING\nDIM edades(10) AS INTEGER      ' Array de una dimensi\u00f3n\nDIM matriz(5, 5) AS SINGLE     ' Array de dos dimensiones\nDIM vector(1 TO 100) AS DOUBLE ' Array con \u00edndice personalizado\n</code></pre>"},{"location":"instrucciones/#redim","title":"REDIM","text":"<p>Redimensiona un array din\u00e1mico (poco com\u00fan en QBasic, m\u00e1s usado en QuickBASIC):</p> <pre><code>DIM SHARED miArray() AS INTEGER\nREDIM miArray(tamano)\n</code></pre>"},{"location":"instrucciones/#shared","title":"SHARED","text":"<p>Declara variables compartidas entre el programa principal y las subrutinas:</p> <pre><code>DIM SHARED valorGlobal AS INTEGER\n</code></pre>"},{"location":"instrucciones/#control-de-programa","title":"Control de Programa","text":""},{"location":"instrucciones/#end","title":"END","text":"<p>Finaliza la ejecuci\u00f3n del programa:</p> <pre><code>PRINT \"Fin del programa\"\nEND\n</code></pre>"},{"location":"instrucciones/#stop","title":"STOP","text":"<p>Detiene la ejecuci\u00f3n del programa y muestra un mensaje:</p> <pre><code>IF error THEN\n    PRINT \"Se ha producido un error\"\n    STOP\nEND IF\n</code></pre>"},{"location":"instrucciones/#system","title":"SYSTEM","text":"<p>Sale de QBasic y vuelve al sistema operativo:</p> <pre><code>SYSTEM\n</code></pre>"},{"location":"instrucciones/#comentarios","title":"Comentarios","text":""},{"location":"instrucciones/#rem-y","title":"REM y '","text":"<p>A\u00f1ade comentarios al c\u00f3digo:</p> <pre><code>REM Esto es un comentario\n' Esto tambi\u00e9n es un comentario\n</code></pre>"},{"location":"instrucciones/#generacion-de-numeros-aleatorios","title":"Generaci\u00f3n de N\u00fameros Aleatorios","text":""},{"location":"instrucciones/#randomize","title":"RANDOMIZE","text":"<p>Inicializa el generador de n\u00fameros aleatorios:</p> <pre><code>RANDOMIZE TIMER  ' Usa el reloj del sistema como semilla\n</code></pre>"},{"location":"instrucciones/#rnd","title":"RND","text":"<p>Genera un n\u00famero aleatorio entre 0 y 1:</p> <pre><code>numeroAleatorio = RND\nenteroAleatorio = INT(RND * 100) + 1  ' N\u00famero entre 1 y 100\n</code></pre>"},{"location":"manipulacion-sonido/","title":"Manipulaci\u00f3n de Sonido en QBasic","text":"<p>Este art\u00edculo proporciona informaci\u00f3n detallada sobre la manipulaci\u00f3n de sonido digital en QBasic, incluyendo c\u00f3mo reproducir diferentes formatos de archivos de sonido y los detalles t\u00e9cnicos sobre las estructuras de estos formatos.</p>"},{"location":"manipulacion-sonido/#fundamentos-del-sonido-digital","title":"Fundamentos del Sonido Digital","text":"<p>Un archivo de sonido digital b\u00e1sicamente consiste en una serie de valores de volumen. En la PC, generalmente un valor de 128 representa el silencio. Los valores m\u00e1s alejados de 128 (en cualquier direcci\u00f3n) son m\u00e1s fuertes seg\u00fan su distancia de este punto medio. Los valores 0 y 255 representan los vol\u00famenes m\u00e1s altos.</p> <p>Es importante destacar que 128 no es necesariamente un silencio absoluto. Cuando se hace una grabaci\u00f3n, siempre hay ruido de fondo, por lo que lo que puede sonar como silencio suele estar entre 126-130.</p>"},{"location":"manipulacion-sonido/#reproduccion-de-sonido-en-hardware-basico","title":"Reproducci\u00f3n de Sonido en Hardware B\u00e1sico","text":""},{"location":"manipulacion-sonido/#dac-en-puerto-paralelo-lpt","title":"DAC en Puerto Paralelo (LPT)","text":"<p>Para reproducir archivos de sonido digital (VOC, WAV, SND, etc.) en un DAC conectado al puerto paralelo:</p> <ol> <li>Lee un byte del archivo</li> <li>Env\u00edalo al puerto paralelo</li> <li>Repite con el siguiente byte</li> </ol> <p>Para obtener la direcci\u00f3n I/O del puerto paralelo:</p> <ul> <li>LPT1: Lee la palabra en la ubicaci\u00f3n de memoria 40h:8h</li> <li>LPT2: 40h:0Ah</li> <li>LPT3: 40h:0Ch</li> <li>LPT4 (en no-PS/2): 40h:0Eh</li> </ul>"},{"location":"manipulacion-sonido/#altavoz-interno-de-la-pc","title":"Altavoz Interno de la PC","text":"<p>Reproducir sonido digital en el altavoz interno es m\u00e1s complicado porque este componente no fue dise\u00f1ado para ese prop\u00f3sito. Para reproducir sonido, primero debes configurar correctamente el chip temporizador:</p> <pre><code>' Configurar el chip temporizador\nOUT 43, &amp;HB6\nOUT 42, &amp;HFF\nOUT 42, 0\nOUT 43, &amp;H90\na = INP(61)\na = a OR 3\nOUT 61, a\n</code></pre> <p>Despu\u00e9s de esta configuraci\u00f3n, para reproducir el sonido:</p> <ol> <li>Obt\u00e9n un byte del archivo de sonido</li> <li>Divide el byte por un \"valor de desplazamiento\" (shift value)</li> <li>Env\u00eda este nuevo byte al puerto 42h</li> <li>Repite para todo el archivo</li> </ol> <p>El \"valor de desplazamiento\" var\u00eda seg\u00fan el equipo. Depende del tama\u00f1o del altavoz y otros factores. Generalmente, un valor de 4 funciona en todas las computadoras. Cuanto menor sea el valor de desplazamiento, m\u00e1s alto ser\u00e1 el volumen de reproducci\u00f3n, pero un valor demasiado peque\u00f1o causar\u00e1 distorsi\u00f3n.</p> <p>Despu\u00e9s de reproducir el sonido, debes restaurar el chip temporizador:</p> <pre><code>' Restaurar el chip temporizador\nOUT 43, &amp;HB6\na = INP(61)\na = a AND &amp;HFC\nOUT 61, a\n</code></pre>"},{"location":"manipulacion-sonido/#formatos-de-archivo-de-sonido","title":"Formatos de Archivo de Sonido","text":""},{"location":"manipulacion-sonido/#archivos-sam-amiga","title":"Archivos SAM (Amiga)","text":"<p>Los archivos SAM no contienen un encabezado o estructura espec\u00edfica; son archivos de sonido \"raw\" (sin procesar). Lo importante a recordar es que utilizan valores \"signed\" (con signo), lo que significa que cuando el bit 7 est\u00e1 activado, el n\u00famero es negativo.</p> <p>Para convertir un archivo signed a unsigned:</p> <ol> <li>Lee un byte del archivo original</li> <li>Suma 128 a ese byte</li> <li>Escribe el resultado en un nuevo archivo</li> </ol> <p>En el mundo Amiga, un byte de 0 equivale al silencio, mientras que -128 y +128 son los vol\u00famenes m\u00e1s altos. En la PC, 0 y 255 son los vol\u00famenes m\u00e1s altos, y 128 equivale al silencio.</p>"},{"location":"manipulacion-sonido/#formato-de-archivo-wav","title":"Formato de Archivo WAV","text":"<pre><code>BYTE(S)        CONTENIDO NORMAL              PROP\u00d3SITO/DESCRIPCI\u00d3N\n-----------------------------------------------------------------------\n00 - 03        \"RIFF\"                        Bloque de identificaci\u00f3n\n04 - 07        ???                           Entero largo que indica el\n                                             tama\u00f1o del archivo en bytes,\n                                             incluyendo el encabezado\n08 - 11        \"WAVE\"                        Identificador de formato\n12 - 15        \"fmt \"                        Identificador de formato\n16 - 19        16, 0, 0, 0                   Tama\u00f1o del encabezado hasta este punto\n20 - 21        1, 0                          Etiqueta de formato\n22 - 23        1, 0                          Canales\n24 - 27        ???                           Frecuencia de muestreo (samples por segundo)\n28 - 31        ???                           Bytes promedio por segundo\n32 - 33        1, 0                          Alineaci\u00f3n de bloque\n34 - 35        8, 0                          Bits por muestra (8, 12 o 16)\n36 - 39        \"data\"                        Marcador que precede a los datos reales\n40 - 43        ???                           N\u00famero de bytes en la muestra\n</code></pre>"},{"location":"manipulacion-sonido/#formato-de-archivo-voc-creative-labs","title":"Formato de Archivo VOC (Creative Labs)","text":"<pre><code>BYTE(S)        CONTENIDO NORMAL              PROP\u00d3SITO/DESCRIPCI\u00d3N\n-----------------------------------------------------------------------\n00 - 19        \"Creative Voice File\", 26     Bloque de identificaci\u00f3n\n20 - 21        26, 00                        Desplazamiento al primer bloque de datos\n22 - 23        10, 1                         N\u00famero de versi\u00f3n (1.10)\n24 - 25        41, 17                        D\u00edgitos de verificaci\u00f3n\n</code></pre> <p>Despu\u00e9s del encabezado (a partir del byte 26), el archivo VOC contiene bloques de datos. Hay ocho tipos, numerados de 0 a 7:</p>"},{"location":"manipulacion-sonido/#bloque-0-end-block","title":"BLOQUE 0 - \"END BLOCK\"","text":"<ul> <li>Byte 1: '0' para denotar el tipo \"fin de bloque\"</li> <li>Este bloque marca el final del archivo VOC</li> </ul>"},{"location":"manipulacion-sonido/#bloque-1-data-block","title":"BLOQUE 1 - \"DATA BLOCK\"","text":"<ul> <li>Byte 1: '1' para denotar el tipo \"bloque de datos\"</li> <li>Bytes 2-4: Longitud del bloque</li> <li>Byte 5: Frecuencia de muestreo (calculada como 1000000 / (256-b5))</li> <li>Byte 6: Tipo de compresi\u00f3n (0=sin compresi\u00f3n, 1=4 bits, 2=2 bits, 3=1 bit)</li> <li>Byte 7: Comienzan los datos reales de la muestra</li> </ul>"},{"location":"manipulacion-sonido/#bloque-2-more-data-block","title":"BLOQUE 2 - \"MORE DATA BLOCK\"","text":"<ul> <li>Byte 1: '2' para denotar el tipo \"m\u00e1s datos\"</li> <li>Bytes 2-4: Longitud del bloque</li> <li>Byte 5: Comienzan los datos de la muestra</li> <li>Utiliza la misma frecuencia de muestreo y compresi\u00f3n que el bloque de datos anterior</li> </ul>"},{"location":"manipulacion-sonido/#bloque-3-silence-block","title":"BLOQUE 3 - \"SILENCE BLOCK\"","text":"<ul> <li>Byte 1: '3' para denotar el tipo \"bloque de silencio\"</li> <li>Bytes 2-4: Longitud del bloque (generalmente 3)</li> <li>Bytes 5-6: Duraci\u00f3n del silencio</li> <li>Byte 7: Frecuencia de muestreo</li> </ul>"},{"location":"manipulacion-sonido/#bloque-4-marker-block","title":"BLOQUE 4 - \"MARKER BLOCK\"","text":"<ul> <li>Byte 1: '4' para denotar el tipo \"bloque marcador\"</li> <li>Bytes 2-4: Longitud del bloque</li> <li>Bytes 5-6: Valor del marcador</li> </ul>"},{"location":"manipulacion-sonido/#bloque-5-message-block","title":"BLOQUE 5 - \"MESSAGE BLOCK\"","text":"<ul> <li>Byte 1: '5' para denotar el tipo \"bloque de mensaje\"</li> <li>Bytes 2-4: Longitud del bloque</li> <li>Bytes 5-?: Mensaje en texto ASCII</li> <li>Byte ?: 0, para denotar fin del texto</li> </ul>"},{"location":"manipulacion-sonido/#bloque-6-repeat-block","title":"BLOQUE 6 - \"REPEAT BLOCK\"","text":"<ul> <li>Byte 1: '6' para denotar el tipo \"bloque de repetici\u00f3n\"</li> <li>Bytes 2-4: Longitud del bloque</li> <li>Bytes 5-6: N\u00famero de veces que los datos deben repetirse</li> </ul>"},{"location":"manipulacion-sonido/#bloque-7-end-repeat-block","title":"BLOQUE 7 - \"END REPEAT BLOCK\"","text":"<ul> <li>Byte 1: '7' para denotar el tipo \"fin de bloque de repetici\u00f3n\"</li> <li>Bytes 2-4: Longitud del bloque (siempre cero)</li> </ul>"},{"location":"manipulacion-sonido/#formato-de-archivo-mod-protracker","title":"Formato de Archivo MOD (Protracker)","text":"<p>El formato MOD (Module) originario del Amiga es un formato de m\u00fasica tracker con las siguientes secciones:</p> <pre><code>Offset   Bytes   Descripci\u00f3n\n------   -----   -----------\n0        20      Nombre de la canci\u00f3n (con bytes nulos al final)\n</code></pre> <p>Informaci\u00f3n para las muestras 1-31:</p> <pre><code>Offset   Bytes   Descripci\u00f3n\n------   -----   -----------\n20       22      Nombre de la muestra 1 (rellenado con bytes nulos)\n42       2       Longitud de la muestra 1 en palabras (multiplicar por 2 para obtener longitud en bytes)\n44       1       Los 4 bits inferiores son el valor de ajuste fino (signed)\n45       1       Volumen para la muestra 1 (rango 0-64 decimal)\n46       2       Punto de repetici\u00f3n para la muestra 1 (en palabras)\n48       2       Longitud de repetici\u00f3n para la muestra 1 (en palabras)\n</code></pre> <p>La informaci\u00f3n para las siguientes 30 muestras contin\u00faa de manera similar.</p> <pre><code>Offset   Bytes   Descripci\u00f3n\n------   -----   -----------\n950      1       Longitud de la canci\u00f3n (rango 1-128)\n951      1       Este byte se establece en 127\n952      128     Posiciones de la canci\u00f3n 0-127\n1080     4       Las cuatro letras \"M.K.\" - Identificador\n1084     1024    Datos para el patr\u00f3n 00\n</code></pre> <p>Cada nota se almacena como 4 bytes, y las cuatro notas en cada posici\u00f3n del patr\u00f3n se almacenan una tras otra.</p> <p>Informaci\u00f3n para cada nota:</p> <pre><code>Byte 1             Byte 2      Byte 3             Byte 4\n------------------  ---------   -----------------   ----------\nCuatro bits        12 bits      Cuatro bits         Comando\nsuperiores del     para el      inferiores del      de efecto\nn\u00famero de muestra  per\u00edodo      n\u00famero de muestra\n</code></pre>"},{"location":"manipulacion-sonido/#archivos-snd-sounder","title":"Archivos SND (Sounder)","text":"<pre><code>BYTE(S)        CONTENIDO NORMAL              PROP\u00d3SITO/DESCRIPCI\u00d3N\n-----------------------------------------------------------------------\n00 - 01        0, 0                          Bits por muestra (normalmente 0 para 8 bits)\n02 - 03        ???                           Frecuencia de muestreo\n04 - 05        ???                           Volumen de reproducci\u00f3n\n06 - 07        4, 0                          Valor de desplazamiento (shift)\n</code></pre>"},{"location":"manipulacion-sonido/#archivos-snd-sound-tool","title":"Archivos SND (Sound Tool)","text":"<pre><code>BYTE(S)        CONTENIDO NORMAL              PROP\u00d3SITO/DESCRIPCI\u00d3N\n-----------------------------------------------------------------------\n00 - 05        \"SOUND\", 26                   Identificaci\u00f3n\n08 - 11        ???                           N\u00famero de bytes en la muestra\n12 - 15        ???                           Primer byte a reproducir\n16 - 19        ???                           \u00daltimo byte a reproducir\n20 - 21        ???                           Frecuencia de muestreo\n22 - 23        ???                           Bits por muestra\n24 - 25        ???                           Volumen de reproducci\u00f3n\n26 - 27        4, 0                          Valor de desplazamiento\n28 - 123       ???                           Nombre de la muestra (termina con ASCII 0)\n</code></pre>"},{"location":"manipulacion-sonido/#ejemplo-de-codigo-para-reproducir-sonido","title":"Ejemplo de C\u00f3digo para Reproducir Sonido","text":"<p>A continuaci\u00f3n se presenta un ejemplo simplificado de c\u00f3mo reproducir un archivo WAV sin comprimir en el altavoz interno de la PC:</p> <pre><code>' Abrir el archivo WAV\nOPEN \"sonido.wav\" FOR BINARY AS #1\n\n' Saltar el encabezado (primeros 44 bytes generalmente)\nSEEK #1, 45\n\n' Configurar el chip temporizador\nOUT 43, &amp;HB6\nOUT 42, &amp;HFF\nOUT 42, 0\nOUT 43, &amp;H90\na = INP(61)\na = a OR 3\nOUT 61, a\n\n' Reproducir el sonido\nshiftValue = 4 ' Ajustar seg\u00fan sea necesario\nDO WHILE NOT EOF(1)\n  ' Leer un byte del archivo\n  byte$ = INPUT$(1, #1)\n  value = ASC(byte$)\n\n  ' Dividir por el valor de desplazamiento\n  value = value \\ shiftValue\n\n  ' Enviar al puerto del altavoz\n  OUT 42, value\n\n  ' Peque\u00f1a pausa para la frecuencia de muestreo\n  ' (esto deber\u00eda ajustarse seg\u00fan la frecuencia del archivo)\n  FOR delay = 1 TO 8: NEXT delay\nLOOP\n\n' Restaurar el chip temporizador\nOUT 43, &amp;HB6\na = INP(61)\na = a AND &amp;HFC\nOUT 61, a\n\n' Cerrar el archivo\nCLOSE #1\n</code></pre>"},{"location":"manipulacion-sonido/#consejos-para-trabajar-con-sonido-en-qbasic","title":"Consejos para Trabajar con Sonido en QBasic","text":"<ol> <li> <p>Frecuencia de muestreo: Cuanto mayor sea la frecuencia, mejor ser\u00e1 la calidad del sonido, pero tambi\u00e9n requerir\u00e1 m\u00e1s recursos. Las frecuencias comunes son 22 KHz, 11 KHz, 7.33 KHz y 5.5 KHz.</p> </li> <li> <p>Altavoz interno vs DAC: El altavoz interno tiene limitaciones significativas en la calidad de sonido. Un DAC en el puerto paralelo ofrece mejor calidad.</p> </li> <li> <p>Conversi\u00f3n signed a unsigned: Recuerda que los formatos Amiga (MOD, SAM) utilizan valores signed, mientras que los formatos PC suelen usar unsigned.</p> </li> <li> <p>Valor de desplazamiento (shift): Experimenta con diferentes valores (2-6) para encontrar el mejor equilibrio entre volumen y distorsi\u00f3n para tu sistema.</p> </li> <li> <p>Timing: La reproducci\u00f3n de sonido en tiempo real requiere un timing preciso. En sistemas m\u00e1s r\u00e1pidos, es posible que necesites agregar retrasos adicionales para mantener la frecuencia de muestreo correcta.</p> </li> </ol>"},{"location":"manipulacion-sonido/#conclusion","title":"Conclusi\u00f3n","text":"<p>Aunque QBasic no fue dise\u00f1ado espec\u00edficamente para la manipulaci\u00f3n de sonido avanzada, con las t\u00e9cnicas adecuadas es posible reproducir una variedad de formatos de sonido digital. Los programadores experimentados pueden incluso crear aplicaciones con efectos de sonido y m\u00fasica de fondo utilizando estas t\u00e9cnicas.</p>"},{"location":"modem/","title":"Uso del M\u00f3dem en QBasic","text":"<p>Autor: Matthew River Knight (HORIZONS Interactive Entertainment)</p> <p>El m\u00f3dem ha sido posiblemente el dispositivo inform\u00e1tico m\u00e1s influyente jam\u00e1s creado. Su aparici\u00f3n ha transformado por completo el mundo de los negocios y la publicidad, ha permitido comunicaciones internacionales m\u00e1s econ\u00f3micas y eficientes, y ha tenido un enorme impacto tanto en profesionales como en aficionados a la inform\u00e1tica.</p> <p>Para muchos, el m\u00f3dem es una peque\u00f1a caja m\u00e1gica que abre nuestro ordenador al mundo. En realidad, es muy sencillo de usar y, lo que es m\u00e1s importante, de programar.</p>"},{"location":"modem/#como-funciona-un-modem","title":"\u00bfC\u00f3mo funciona un m\u00f3dem?","text":"<p>El m\u00f3dem toma bytes de datos, los convierte en se\u00f1ales ac\u00fasticas y los env\u00eda a trav\u00e9s de la l\u00ednea telef\u00f3nica. Te\u00f3ricamente, si pudieras silbar lo suficientemente r\u00e1pido y con los tonos adecuados, podr\u00edas enviar un archivo mediante los sonidos que produces.</p> <p>B\u00e1sicamente, el ordenador env\u00eda un archivo a trav\u00e9s del m\u00f3dem de la siguiente manera:</p> <ol> <li>El m\u00f3dem env\u00eda un car\u00e1cter ASCII para informar al otro ordenador que est\u00e1 enviando un archivo</li> <li>Divide ese archivo en fragmentos y lo env\u00eda por bloques de bytes</li> <li>El m\u00f3dem espera un car\u00e1cter ASCII del otro ordenador confirmando que todo est\u00e1 bien, para enviar el siguiente fragmento</li> </ol>"},{"location":"modem/#programando-el-modem-en-qbasic","title":"Programando el m\u00f3dem en QBasic","text":"<p>Programar comunicaciones con el m\u00f3dem en QBasic es sorprendentemente sencillo. Solo necesitas 4 comandos b\u00e1sicos:</p> <ol> <li>OPEN COM: Abre el m\u00f3dem para que lo use QBasic</li> <li>INPUT$: Obtiene datos del m\u00f3dem</li> <li>LOC: Indica si el m\u00f3dem ha recibido datos de una fuente externa</li> <li>PRINT #: Env\u00eda datos al m\u00f3dem</li> </ol>"},{"location":"modem/#estableciendo-comunicacion-con-el-modem","title":"Estableciendo comunicaci\u00f3n con el m\u00f3dem","text":"<p>Para empezar a trabajar con el m\u00f3dem, primero debes abrir un \"camino\" hacia \u00e9l. Esto es similar a abrir un archivo, pero se utiliza la sentencia <code>OPEN COM</code>:</p> <pre><code>OPEN \"COM2:2400,N,8,1,RB2048,TB2048\" FOR RANDOM AS #1\n</code></pre> <p>Aunque parece complicado, es bastante simple. Lo \u00fanico que debes tener en cuenta es:</p> <ul> <li>El n\u00famero entre \"COM\" y \":\" es el puerto COM en el que est\u00e1 conectado tu m\u00f3dem (COM1 o COM2)</li> <li>El n\u00famero entre \":\" y \",N\" es la velocidad (baudios) del m\u00f3dem</li> </ul> <p>QBasic solo puede acceder a los puertos COM 1 y 2. Si tu m\u00f3dem est\u00e1 en otro puerto, existen formas de modificar las direcciones de memoria de los puertos COM, pero eso es tema para otro art\u00edculo.</p> <p>En cuanto a los baudios, QBasic no puede acceder a los puertos COM a velocidades superiores a 9600. As\u00ed que aunque tengas un m\u00f3dem de 56K, QBasic no podr\u00e1 utilizarlo a m\u00e1s de 9600 baudios.</p>"},{"location":"modem/#enviando-comandos-al-modem","title":"Enviando comandos al m\u00f3dem","text":"<p>Para enviar datos a tu m\u00f3dem se utiliza la sentencia <code>PRINT #n</code>, donde n es el n\u00famero de archivo (en el ejemplo anterior, 1). Sin embargo, todav\u00eda no est\u00e1s conectado a nada, solo has creado una ruta entre tu programa y el m\u00f3dem.</p> <p>Para que el m\u00f3dem se comunique con una fuente externa (como un BBS), debes indicarle que marque un n\u00famero. Para ello, debes utilizar los comandos AT integrados en la memoria del m\u00f3dem:</p> Comando del m\u00f3dem Significado ATDT###-###-#### Marca el n\u00famero ###-###-#### ATZ Cuelga el tel\u00e9fono ATS0=# Espera a que alguien llame y el tel\u00e9fono suene # veces, luego intenta conectar los m\u00f3dems ATM2H1L# Establece el volumen del altavoz en # (1-3)"},{"location":"modem/#ejemplo-marcador-telefonico-simple","title":"Ejemplo: Marcador telef\u00f3nico simple","text":"<p>Aqu\u00ed tienes un programa simple que marcar\u00e1 un n\u00famero telef\u00f3nico:</p> <pre><code>CLS\nPRINT \"Abriendo una ruta hacia tu m\u00f3dem...\"\nOPEN \"COM2:2400,N,8,1,RB7048,TB7048\" FOR RANDOM AS #1\nPRINT \"Por favor, introduce el n\u00famero de tel\u00e9fono que deseas llamar\"\nINPUT PhoneNumber$\nPRINT \"Comunic\u00e1ndose con tu m\u00f3dem...\"\nPRINT #1, \"ATDT\"; PhoneNumber$\nPRINT \"\u00a1Listo! Levanta el tel\u00e9fono y habla.\"\nPRINT \"Presiona la tecla ESC para colgar.\"\nDO\nLOOP UNTIL INKEY$ = CHR$(27)\nPRINT #1, \"ATZ\"\n</code></pre>"},{"location":"modem/#leyendo-la-informacion-del-modem","title":"Leyendo la informaci\u00f3n del m\u00f3dem","text":"<p>El mayor desaf\u00edo en la programaci\u00f3n de m\u00f3dems con QBasic es leer los datos que llegan. Para esto se utiliza la funci\u00f3n <code>LOC</code>, que indica si el m\u00f3dem ha recibido algo:</p> <pre><code>LOC(n)  ' donde n es el n\u00famero de archivo\n</code></pre> <p>LOC te indica d\u00f3nde te encuentras en un archivo. \u00bfArchivo? \u00a1Pero estamos intentando acceder al m\u00f3dem! Como dije antes, los archivos y dispositivos funcionan de la misma manera. Pero con un m\u00f3dem, LOC te dice si ha recibido algo.</p> <p>Para leer lo que est\u00e1 recibiendo el m\u00f3dem, utilizas <code>INPUT$(x,y)</code>, donde:</p> <ul> <li>x es el n\u00famero de bytes a obtener</li> <li>y es el n\u00famero del archivo/dispositivo abierto</li> </ul> <p>El valor x deber\u00eda ser SIEMPRE 1. S\u00e9 que esto significa que solo se puede leer 1 car\u00e1cter en cada pasada, pero de esta manera se lee CADA car\u00e1cter, y no se omite ninguno. Si estuvieras recibiendo una transmisi\u00f3n de 11 bytes, y x fuera 2, solo se leer\u00edan los primeros 10 caracteres (porque 10 es m\u00faltiplo de 2). La \u00faltima parte se omitir\u00eda. Esta es la forma para comunicaciones NORMALES. \u00a1Mant\u00e9n x como 1!</p>"},{"location":"modem/#programa-completo-de-comunicaciones","title":"Programa completo de comunicaciones","text":"<p>Este es un programa completo de comunicaciones con m\u00f3dem que te permite conectarte a cualquier BBS e interactuar con \u00e9l:</p> <pre><code>CLS\nPRINT \"Programa de comunicaciones simple en QBasic.\"\nPRINT \"\u00bfQu\u00e9 puerto COM utiliza tu m\u00f3dem?\"\nINPUT \"&gt;\", port$\nbaud$ = \"9600\" '9600 deber\u00eda funcionar bien con la mayor\u00eda de los m\u00f3dems. Si tienes\n              'uno m\u00e1s antiguo, usa 2400.\n'Abre ese puerto COM.\nOPEN \"COM\" + port$ + \":\" + baud$ + \",N,8,1,RB2048,TB2048\" FOR RANDOM AS #1\n\nPRINT \"OPCIONES:\"\nPRINT \"1-Llamar a otro ordenador\"\nPRINT \"2-Esperar una llamada\"\nPRINT \"3-Salir\"\nDO\na = VAL(INKEY$)\nLOOP UNTIL a &gt;= 1 AND a &lt;= 3\nIF a = 3 THEN CLOSE : SYSTEM\nIF a = 2 THEN GOTO wait\n\nPRINT \"\u00bfN\u00famero a llamar?\"\nINPUT \"&gt;\", number$\nPRINT #1, \"ATDT\" + number$  'Indica al m\u00f3dem que marque el n\u00famero.\nGOTO chat\nwait:\nPRINT #1, \"ATS0=1\"         'Indica al m\u00f3dem que se conecte despu\u00e9s de 1 timbre.\n\n'Cuando un m\u00f3dem se conecta, devuelve \"CONNECT ####\"\n'El siguiente bloque de c\u00f3digo espera hasta que el m\u00f3dem se conecte antes de continuar\n\na$ = \"\"\nDO\nIF LOC(1) THEN a$ = a$ + INPUT$(1, 1) 'Si hay algo en el m\u00f3dem, a\u00f1\u00e1delo a a$\nLOOP UNTIL INSTR(a$, \"CONNECT\") 'Espera hasta que los m\u00f3dems se hayan conectado.\n\nchat:\n'Si estabas esperando una llamada, se imprimir\u00e1n muchos caracteres ASCII\n'en la pantalla. No te preocupes, son solo los ordenadores sincroniz\u00e1ndose y\n'comunic\u00e1ndose. Adem\u00e1s, no ver\u00e1s lo que escribes.\n\nCLS\nPRINT \"Ahora est\u00e1s listo para chatear, presiona ESC para salir.\"\nDO\nt$ = INKEY$\nIF LEN(t$) THEN PRINT #1, t$    'Si escribiste algo, env\u00edalo al m\u00f3dem\n                                'esto ser\u00e1 enviado por el m\u00f3dem al otro\n                                'ordenador\nIF LOC(1) THEN r$ = INPUT$(1, 1) 'Si hay algo que recibir, gu\u00e1rdalo en r$\n\nIF LEN(r$) THEN PRINT r$;       'Si r$ &lt;&gt; \"\" entonces impr\u00edmelo. \";\" significa que\n                                'no se inicia una nueva l\u00ednea\nLOOP UNTIL t$ = CHR$(27)        'Contin\u00faa haciendo esto hasta que se presione ESC\nPRINT #1, \"ATZ\"                 'Indica al m\u00f3dem que cuelgue\nCLOSE                           'Cierra la sentencia COM abierta\n</code></pre>"},{"location":"modem/#limitaciones-y-consideraciones","title":"Limitaciones y consideraciones","text":"<ul> <li>QBasic solo puede acceder a los puertos COM 1 y 2</li> <li>La velocidad m\u00e1xima es de 9600 baudios</li> <li>Este programa b\u00e1sico no incluye capacidades de carga o descarga de archivos</li> <li>Al esperar una llamada, se mostrar\u00e1n muchos caracteres ASCII en la pantalla durante la sincronizaci\u00f3n</li> </ul>"},{"location":"modem/#conclusion","title":"Conclusi\u00f3n","text":"<p>\u00a1Y eso es todo! \u00bfF\u00e1cil, verdad? Ahora tienes un programa genial que puedes usar para hablar con tus amigos a trav\u00e9s del m\u00f3dem en QBasic.</p> <p>La programaci\u00f3n de comunicaciones con m\u00f3dem en QBasic es mucho m\u00e1s sencilla de lo que podr\u00eda parecer inicialmente. Con solo cuatro comandos fundamentales (<code>OPEN COM</code>, <code>INPUT$</code>, <code>LOC</code> y <code>PRINT #</code>), puedes crear programas funcionales para comunicarte con otros ordenadores a trav\u00e9s de la l\u00ednea telef\u00f3nica.</p> <p>Este conocimiento b\u00e1sico te permitir\u00e1 experimentar con las comunicaciones por m\u00f3dem y sentar las bases para desarrollar aplicaciones m\u00e1s complejas que incluyan transferencia de archivos y otros protocolos de comunicaci\u00f3n.</p> <p>Antes de dejarte experimentar con tus nuevos conocimientos, me gustar\u00eda extender mi agradecimiento a las siguientes personas que me han ayudado de alguna manera con mi programaci\u00f3n en general: LordAcidus, Petter Holmberg, Tek, ZKman, y por \u00faltimo, pero no menos importante, Christian Garms. Chicos, me hab\u00e9is ayudado mucho.</p> <p>\u00a1Feliz hacking para todos!</p> <p>Este art\u00edculo apareci\u00f3 originalmente en The BASIX Fanzine, N\u00famero 17, en abril de 2000.</p>"},{"location":"mouse/","title":"Uso del Rat\u00f3n en QBasic","text":"<p>\u00daltima actualizaci\u00f3n: 8 de marzo de 2002 Autor original: Antoni Gual</p> <p>Este tutorial explica c\u00f3mo utilizar el rat\u00f3n en modos VGA est\u00e1ndar de QBasic. Los modos SVGA y Mode-X est\u00e1n fuera del alcance de este documento. La informaci\u00f3n es v\u00e1lida tanto para QB 4.5 como para QBasic 1.1.</p>"},{"location":"mouse/#formas-de-usar-el-raton-en-programas-qbasic","title":"Formas de usar el rat\u00f3n en programas QBasic","text":"<p>Hay dos formas de implementar el uso del rat\u00f3n:</p> <ol> <li>La forma f\u00e1cil: Usar QB4.5 con una biblioteca que lo soporte (Future, DQB, CosmoX, Rellib, Zephyr, etc.)</li> <li>La forma dif\u00edcil: Implementarlo manualmente a trav\u00e9s de interrupciones</li> </ol> <p>Este tutorial se centra en la segunda opci\u00f3n, explicando c\u00f3mo hacerlo desde cero.</p>"},{"location":"mouse/#conceptos-basicos-sobre-interrupciones","title":"Conceptos b\u00e1sicos sobre interrupciones","text":"<p>Una interrupci\u00f3n es una instrucci\u00f3n especial del procesador que llama a una funci\u00f3n. Existen dos tipos:</p> <ul> <li>Interrupciones de hardware: Son disparadas el\u00e9ctricamente por el hardware cuando necesita atenci\u00f3n del procesador (teclado, puertos, disco, etc.)</li> <li>Interrupciones de software: Son la API de DOS, la forma de acceder a las funciones del sistema operativo. Casi todas las funciones de DOS se realizan a trav\u00e9s de llamadas a interrupciones.</li> </ul> <p>El rat\u00f3n no es parte nativa de DOS, sino un complemento que debe cargarse en CONFIG.SYS (en DOS puro). Para usarlo, debemos llamar a las interrupciones adecuadas, cargar los registros del procesador con los valores apropiados y leer los resultados que devuelven.</p>"},{"location":"mouse/#habilitando-interrupciones-en-qb-45","title":"Habilitando interrupciones en QB 4.5","text":"<p>Para usar interrupciones en QB 4.5:</p> <ol> <li>Configura los directorios en IDE (Options/Directories) hacia la ruta donde est\u00e1 instalado el compilador</li> <li>Abre QB con el par\u00e1metro <code>/l</code> para cargar la biblioteca predeterminada:</li> </ol> <p><code>batch    myqbpath\\qb mysource /l</code></p> <ol> <li>Utiliza la funci\u00f3n <code>INTERRUPTX</code> que se carga en la biblioteca para gestionar las llamadas a interrupciones</li> <li>Incluye el archivo QB.BI en tu programa para definir el tipo RegType:</li> </ol> <p><code>qbasic    '$INCLUDE:'QB.BI'</code></p>"},{"location":"mouse/#habilitando-interrupciones-en-qbasic-11","title":"Habilitando interrupciones en QBasic 1.1","text":"<p>QBasic 1.1 no soporta bibliotecas, por lo que necesitamos cargar una rutina en ensamblador previamente creada:</p> <pre><code>TYPE RegTypeX\n    ax    AS INTEGER\n    bx    AS INTEGER\n    cx    AS INTEGER\n    dx    AS INTEGER\n    bp    AS INTEGER\n    si    AS INTEGER\n    di    AS INTEGER\n    flags AS INTEGER\n    ds    AS INTEGER\n    es    AS INTEGER\nEND TYPE\n\nSUB INTERRUPTX (intnum AS INTEGER, InReg AS RegTypeX, OutReg AS RegTypeX)\n'standard interrupt call compatibility with QBasic\n'some  static variables  \nSTATIC a() AS LONG, bReady AS INTEGER\n'If assembler array not created, create it\nIF NOT bReady THEN\n    'don't change anything\n    I =50:DIM a(1 TO I ) AS LONG\n    a(1) = &amp;H53EC8B55: a(2) = &amp;H1E575651: a(3) = &amp;H5E8B9C06: a(4) = &amp;HA078B0E\n    a(5) = &amp;HC70774E4: a(6) = &amp;HE9FFFF07: a(7) = &amp;HEC8300A1: a(8) = &amp;HB3F88A0A\n    a(9) = &amp;HE85E89CD: a(10) = &amp;HCBEA46C7: a(11) = &amp;H74253C90: a(12) = &amp;H75263C04\n    a(13) = &amp;HEA46C714: a(14) = &amp;H46C701E8: a(15) = &amp;HC7CB00EC: a(16) = &amp;H2C2EE46\n    a(17) = &amp;HF046C7: a(18) = &amp;H85E8B90: a(19) = &amp;H5E8B37FF: a(20) = &amp;HE37FF06\n    a(21) = &amp;H50008FB8: a(22) = &amp;HE85E8D16: a(23) = &amp;H8BDA8C53: a(24) = &amp;H378B0A5E\n    a(25) = &amp;H8E0C5E8B: a(26) = &amp;H10448B1F: a(27) = &amp;H75FFFF3D: a(28) = &amp;H50C28B02\n    a(29) = &amp;H3D12448B: a(30) = &amp;H275FFFF: a(31) = &amp;HC08EC28B: a(32) = &amp;H5C8B048B\n    a(33) = &amp;H44C8B02: a(34) = &amp;H8B06548B: a(35) = &amp;H748B0C7C: a(36) = &amp;H9CCB1F0A\n    a(37) = &amp;H83EC8B55: a(38) = &amp;H1E5620C5: a(39) = &amp;H89E476C5: a(40) = &amp;H25C8904\n    a(41) = &amp;H89044C89: a(42) = &amp;H7C890654: a(43) = &amp;H12448C0C: a(44) = &amp;H8F10448F\n    a(45) = &amp;H448F0A44: a(46) = &amp;HE448F08: a(47) = &amp;H9D0EC483: a(48) = &amp;H5E5F1F07\n    a(49) = &amp;HCA5D5B59: a(50) = &amp;H9165000A\n   'Checksum, can be ommited \n    S1 = 0: S2 = 0: p = VARPTR(a(1)): DEF SEG = VARSEG(a(1))\n      FOR I  = 0 TO 199\n        S1 = (S1 + PEEK(p + I )) MOD 255: S2 = (S2 + S1) MOD 255\n    NEXT I \n    IF S1 OR S2 THEN ERROR 2: intnum = -1: EXIT SUB ' Checksum Error\n   'End of the checksum  \n    bReady = -1\nEND IF\n'This is where we call our assembler interrupt calling function\nDEF SEG = VARSEG(a(1))\n    CALL ABSOLUTE(intnum, VARSEG(InReg), VARPTR(InReg),VARSEG(OutReg), VARPTR(OutReg),0)\nEND SUB\n</code></pre>"},{"location":"mouse/#primera-llamada-a-interrupcion","title":"Primera llamada a interrupci\u00f3n","text":"<p>Una vez habilitada la capacidad de usar interrupciones, podemos hacer la primera llamada:</p> <pre><code>DIM SHARED Regs as RegtypeX  ' Define la variable compartida\n\nRegs.ax = 0                  ' Funci\u00f3n 0: inicializa rat\u00f3n y detecta si est\u00e1 presente\nCALL INTERRUPTX(&amp;H33, Regs, Regs)  ' Llama a la interrupci\u00f3n 33h con los par\u00e1metros\n\n' Verifica resultados\nIF Regs.ax THEN\n    PRINT \"Rat\u00f3n habilitado, tiene \"; Regs.bx; \" botones.\"\nELSE\n    PRINT \"No se detect\u00f3 rat\u00f3n, o el controlador no est\u00e1 cargado\"\nEND IF\n</code></pre>"},{"location":"mouse/#funciones-principales-del-raton-int-33h","title":"Funciones principales del rat\u00f3n (INT 33h)","text":""},{"location":"mouse/#funcion-0-reiniciar-ratonverificar-instalacion","title":"Funci\u00f3n 0 - Reiniciar rat\u00f3n/Verificar instalaci\u00f3n","text":"<pre><code>Entrada:\nAX = 00\n\nRetorno:\nAX = 0000  controlador no instalado\n     FFFF  controlador instalado\nBX = n\u00famero de botones\n</code></pre> <p>Esta funci\u00f3n reinicia el rat\u00f3n a los valores predeterminados:</p> <ul> <li>El cursor se posiciona en el centro de la pantalla</li> <li>El cursor se reinicia y se oculta</li> <li>No se habilitan interrupciones</li> <li>Umbral de doble velocidad establecido en 64 mickeys por segundo</li> <li>Relaci\u00f3n mickey a p\u00edxel horizontal (8 a 8)</li> <li>Relaci\u00f3n mickey a p\u00edxel vertical (16 a 8)</li> <li>Se establecen anchura y altura m\u00e1ximas para el modo de v\u00eddeo</li> </ul>"},{"location":"mouse/#funcion-1-mostrar-cursor-del-raton","title":"Funci\u00f3n 1 - Mostrar cursor del rat\u00f3n","text":"<pre><code>Entrada:\nAX = 01\n\nNo retorna valores\n</code></pre> <p>Incrementa el contador del cursor; el cursor se muestra si el contador es cero. El valor predeterminado del contador es -1, por lo que el cursor est\u00e1 inicialmente oculto.</p>"},{"location":"mouse/#funcion-2-ocultar-cursor-del-raton","title":"Funci\u00f3n 2 - Ocultar cursor del rat\u00f3n","text":"<pre><code>Entrada:\nAX = 02\n\nNo retorna valores\n</code></pre> <p>Decrementa el contador del cursor; oculta el cursor si el contador no es cero.</p> <p>Hay dos razones principales para ocultar el cursor:</p> <ul> <li>No deseas que el usuario lo vea</li> <li>En modos gr\u00e1ficos, el controlador del rat\u00f3n guarda la imagen detr\u00e1s del cursor. Si no ocultas el cursor antes de actualizar una imagen, cuando el cursor se mueva, restaurar\u00e1 la imagen anterior a tu actualizaci\u00f3n. Por lo tanto: ocultar rat\u00f3n \u2192 actualizar \u2192 mostrar rat\u00f3n.</li> </ul>"},{"location":"mouse/#funcion-3-obtener-posicion-y-estado-de-botones","title":"Funci\u00f3n 3 - Obtener posici\u00f3n y estado de botones","text":"<pre><code>Entrada:\nAX = 03\n\nRetorno:\nCX = posici\u00f3n horizontal (X) (0..639)\nDX = posici\u00f3n vertical (Y) (0..199)\nBX = estado de botones:    \n     bit 0: bot\u00f3n izquierdo (1 = presionado)\n     bit 1: bot\u00f3n derecho (1 = presionado)\n     bits 2-15: sin usar\n</code></pre> <p>Una forma f\u00e1cil de usar el rat\u00f3n es consultar regularmente esta funci\u00f3n.</p>"},{"location":"mouse/#funcion-4-establecer-posicion-del-cursor","title":"Funci\u00f3n 4 - Establecer posici\u00f3n del cursor","text":"<pre><code>Entrada:\nAX = 4\nCX = posici\u00f3n horizontal\nDX = posici\u00f3n vertical\n\nNo retorna valores\n</code></pre> <ul> <li>Despu\u00e9s de inicializar el rat\u00f3n, el cursor est\u00e1 en el centro de la pantalla</li> <li>La posici\u00f3n debe estar dentro del rango del modo de v\u00eddeo actual</li> <li>La posici\u00f3n puede redondearse para ajustarse a la resoluci\u00f3n del modo de pantalla</li> </ul>"},{"location":"mouse/#funcion-7-establecer-limites-horizontales","title":"Funci\u00f3n 7 - Establecer l\u00edmites horizontales","text":"<pre><code>Entrada:\nAX = 7\nCX = posici\u00f3n horizontal m\u00ednima\nDX = posici\u00f3n horizontal m\u00e1xima\n\nNo retorna valores\n</code></pre> <ul> <li>Restringe el movimiento horizontal del rat\u00f3n a una ventana</li> <li>Si el valor m\u00ednimo es mayor que el m\u00e1ximo, se intercambian</li> </ul>"},{"location":"mouse/#funcion-8-establecer-limites-verticales","title":"Funci\u00f3n 8 - Establecer l\u00edmites verticales","text":"<pre><code>Entrada:\nAX = 8\nCX = posici\u00f3n vertical m\u00ednima\nDX = posici\u00f3n vertical m\u00e1xima\n\nNo retorna valores\n</code></pre> <ul> <li>Restringe el movimiento vertical del rat\u00f3n a una ventana</li> <li>Si el valor m\u00ednimo es mayor que el m\u00e1ximo, se intercambian</li> </ul>"},{"location":"mouse/#funcion-9-definir-cursor-grafico","title":"Funci\u00f3n 9 - Definir cursor gr\u00e1fico","text":"<pre><code>Entrada:\nAX = 9\nBX = posici\u00f3n horizontal del punto caliente (-16 a 16)\nCX = posici\u00f3n vertical del punto caliente (-16 a 16)\nES:DX = puntero a las m\u00e1scaras de pantalla y cursor (mapa de bits de 16 bytes)\n\nNo retorna valores\n</code></pre> <ul> <li>El cursor gr\u00e1fico siempre es en blanco y negro</li> <li>Para el punto caliente, el origen de las coordenadas (0,0) es la esquina superior izquierda del mapa de bits</li> <li>ES:DX apunta a un array de 64 bytes:</li> <li>bytes 0-31: mapa de bits de m\u00e1scara de pantalla (16x16) 1 bit por p\u00edxel</li> <li>bytes 31-63: mapa de bits de m\u00e1scara del cursor (16x16) 1 bit por p\u00edxel</li> </ul>"},{"location":"mouse/#funcion-a-definir-cursor-de-texto","title":"Funci\u00f3n A - Definir cursor de texto","text":"<pre><code>Entrada:\nAX = 0A\nBX = 00 cursor de software o atributo\n     01 cursor de hardware\n\nSi es cursor de hardware:\nCX = l\u00ednea de inicio del cursor\nDX = l\u00ednea final del cursor\n\nSi es cursor de software/atributo:\nCX = m\u00e1scara: atributo*256+car\u00e1cter para AND\nDX = m\u00e1scara: atributo*256+car\u00e1cter para XOR\n\nNo retorna valores\n</code></pre> <ul> <li>El cursor de hardware es un rect\u00e1ngulo que puedes formatear como el cursor de texto en la instrucci\u00f3n LOCATE de QB</li> <li>El cursor de software/atributo permite hacer cursores coloridos</li> </ul>"},{"location":"mouse/#coordenadas-usadas-por-las-funciones-del-raton","title":"Coordenadas usadas por las funciones del rat\u00f3n","text":"<p>Las coordenadas del cursor utilizadas en las funciones de INT 33h no siempre corresponden a p\u00edxeles o caracteres en la pantalla. Tras obtener las coordenadas del cursor, deber\u00e1s rescalarlas para que se ajusten a tus necesidades.</p> <p>Las coordenadas a utilizar son:</p> <ul> <li>X en el rango 0-639 para todos los modos VGA</li> <li>Y dependiendo del modo de pantalla:</li> <li>Modo 0 (50 l\u00edneas): Y = 0-399</li> <li>Modo 0 (25 l\u00edneas), Modos 1, 2, 7, 8, 13: Y = 0-199</li> <li>Modos 11, 12: Y = 0-479</li> <li>Modos 9, 10: Y = 0-349</li> </ul>"},{"location":"mouse/#programa-de-ejemplo","title":"Programa de ejemplo","text":"<pre><code>'MOUSE DEMO\n'Modificado de una publicaci\u00f3n en QB45.COM por herman \n\n'Usuarios de QB4.5: Iniciar Qb con /lqb\n'Usuarios de QBasic1.1: borrar la siguiente l\u00ednea y pegar TYPE y SUB de arriba\n\n'$INCLUDE:'QB.BI'\nDIM SHARED Regs AS RegTypeX\nCLS: SCREEN 13\n\nRegs.Ax = 0: Mouse                                        'inicializarlo\nIF Regs.Ax = 0 THEN PRINT \"\u00a1Rat\u00f3n no presente!\": END      'sin rat\u00f3n &gt; sin demo\nRegs.Ax = 1: Mouse                                        'mostrarlo\nDO                                                        'consultarlo           \n    Regs.Ax = 3: Mouse                                   \n    LOCATE , 0: \n    PRINT USING \"X: ###  Y:###\"; Regs.Cx; Regs.Dx;        'mostrar coordenadas\nLOOP UNTIL Regs.Bx = 1                                    'hasta que se presione el bot\u00f3n izquierdo \nEND\n\nSUB Mouse                                                      \nCALL INTERRUPTX(&amp;H33, Regs, Regs)\nEND SUB\n</code></pre>"},{"location":"mouse/#deteccion-de-clics-y-arrastre","title":"Detecci\u00f3n de clics y arrastre","text":"<ul> <li>Para detectar clics, leer el bit 0 (bot\u00f3n izquierdo) y bit 1 (bot\u00f3n derecho) del registro BX</li> <li>Para detectar doble clic y arrastres, comparar el estado actual de los botones con el estado anterior:</li> <li>Si hay un bot\u00f3n presionado, se ha movido desde la \u00faltima consulta y el bot\u00f3n ya estaba presionado, es un arrastre</li> <li>Si no se mueve y detectas presionado-no presionado-presionado de nuevo en un corto per\u00edodo de tiempo, es un doble clic</li> </ul>"},{"location":"mouse/#cursores-personalizados","title":"Cursores personalizados","text":"<ul> <li>Puedes crear tus propios cursores gr\u00e1ficos, similar a crear un sprite y su m\u00e1scara, pero en un solo color</li> <li>Para un cursor multicolor, debes ocultar el cursor predeterminado y seguir colocando tu propio sprite donde deber\u00eda estar el cursor del rat\u00f3n</li> <li>En modos de texto, siempre tienes un cursor rectangular, solo puedes modificar su altura o color</li> </ul>"},{"location":"mouse/#conclusion","title":"Conclusi\u00f3n","text":"<p>Con estas instrucciones, puedes implementar soporte para rat\u00f3n en tus programas de QBasic. Una vez habilitado, simplemente sigue consultando su estado y compara las coordenadas devueltas por la funci\u00f3n 3 con las coordenadas de los objetos en la pantalla para saber si el usuario hace clic sobre ellos.</p>"},{"location":"pilas/","title":"Implementaci\u00f3n de Pilas (Stacks) en QBasic","text":"<p>Una pila (stack) es una estructura de datos fundamental en la programaci\u00f3n. Este art\u00edculo explica c\u00f3mo implementar y utilizar una pila en QBasic.</p>"},{"location":"pilas/#que-es-una-pila","title":"\u00bfQu\u00e9 es una Pila?","text":"<p>Una pila es una colecci\u00f3n de elementos que sigue el principio LIFO (Last In, First Out - \u00daltimo en entrar, Primero en salir). Esto significa que el \u00faltimo elemento a\u00f1adido a la pila ser\u00e1 el primero en ser eliminado.</p> <p>Las operaciones b\u00e1sicas de una pila son:</p> <ul> <li>Push: A\u00f1adir un elemento a la parte superior de la pila</li> <li>Pop: Eliminar y devolver el elemento superior de la pila</li> <li>Verificar si est\u00e1 vac\u00eda: Comprobar si la pila no contiene elementos</li> </ul>"},{"location":"pilas/#implementacion-en-qbasic","title":"Implementaci\u00f3n en QBasic","text":"<p>Para implementar una pila en QBasic, podemos utilizar un array. Sin embargo, esto nos limitar\u00e1 a una pila de tama\u00f1o fijo (bounded stack) ya que los arrays en QBasic tienen dimensiones predefinidas.</p>"},{"location":"pilas/#componentes-necesarios","title":"Componentes necesarios","text":"<ol> <li>Un array para almacenar los elementos de la pila</li> <li>Una variable para rastrear la posici\u00f3n del elemento superior (top) de la pila</li> <li>Una constante que defina la profundidad m\u00e1xima de la pila</li> <li>Funciones para las operaciones b\u00e1sicas de la pila</li> </ol>"},{"location":"pilas/#codigo-de-implementacion","title":"C\u00f3digo de implementaci\u00f3n","text":"<p>A continuaci\u00f3n se presenta una implementaci\u00f3n completa de una pila acotada en QBasic:</p> <pre><code>'  Implementaci\u00f3n de una Pila Acotada (Bounded Stack)\n\nDECLARE FUNCTION EmptyStack! ()    ' Funci\u00f3n que verifica si la pila est\u00e1 vac\u00eda\nDECLARE SUB InStack (X!)           ' Procedimiento para a\u00f1adir un elemento a la pila\nDECLARE FUNCTION OutStack! ()      ' Funci\u00f3n para extraer un elemento de la pila\n\nDIM SHARED DeepStack, TopStack     ' Variables globales para la profundidad y el tope de la pila\n\nCONST True = -1\nCONST False = NOT True\n\n' Inicializaci\u00f3n de la pila\nDeepStack = 100                    ' Definir la profundidad m\u00e1xima de la pila\nDIM SHARED Stack(DeepStack)        ' Definir el array para la pila\nTopStack = 0                       ' El tope se inicia en 0 (pila vac\u00eda)\n\n' Funci\u00f3n para verificar si la pila est\u00e1 vac\u00eda\nFUNCTION EmptyStack\n  IF TopStack = 0 THEN\n    EmptyStack = True\n  ELSE\n    EmptyStack = False\n  END IF\nEND FUNCTION\n\n' Procedimiento para a\u00f1adir un elemento a la pila (Push)\nSUB InStack (X)\n  IF TopStack = DeepStack THEN\n    PRINT \"Error: \u00a1La pila est\u00e1 llena!\"\n    STOP\n  ELSE\n    TopStack = TopStack + 1\n    Stack(TopStack) = X\n  END IF\nEND SUB\n\n' Funci\u00f3n para extraer un elemento de la pila (Pop)\nFUNCTION OutStack\n  IF TopStack = 0 THEN\n    PRINT : PRINT \"Error: \u00a1La pila est\u00e1 vac\u00eda!\"\n    STOP\n  ELSE\n    OutStack = Stack(TopStack)\n    TopStack = TopStack - 1\n  END IF\nEND FUNCTION\n</code></pre>"},{"location":"pilas/#programa-de-demostracion","title":"Programa de demostraci\u00f3n","text":"<p>El siguiente programa demuestra el uso de una pila acotada. Primero, a\u00f1ade una serie de n\u00fameros secuenciales a la pila y luego los extrae y los muestra en pantalla:</p> <pre><code>'  Programa de Demostraci\u00f3n de una Pila Acotada\n\nDECLARE FUNCTION EmptyStack! ()\nDECLARE SUB InStack (X!)\nDECLARE FUNCTION OutStack! ()\n\nDIM SHARED DeepStack, TopStack\n\nCONST True = -1\nCONST False = NOT True\n\n' Inicializaci\u00f3n de la pila\nDeepStack = 100                ' Definiendo la profundidad de la pila\nDIM SHARED Stack(DeepStack)    ' Definiendo el array para la pila\nTopStack = 0\n\n' Demostraci\u00f3n de la operaci\u00f3n de la pila\nCLS\nPRINT \"Demostraci\u00f3n de una Pila Acotada\"\nPRINT \"         (profundidad de la pila - 100)\"\nPRINT\nINPUT \"\u00bfN\u00famero de elementos a a\u00f1adir a la pila? \"; NS\n\n' Llenando la pila\nFOR I = 1 TO NS\n  CALL InStack(I)\nNEXT I\n\n' Extrayendo elementos de la pila\nINPUT \"\u00bfN\u00famero de elementos a extraer de la pila? \", OS\nFOR I = 1 TO OS\n  IF NOT EmptyStack THEN\n    X = OutStack\n    PRINT X;\n  ELSE\n    PRINT : PRINT \"\u00a1La pila est\u00e1 vac\u00eda! \";\n    PRINT I; \"- elemento no puede ser recuperado.\"\n    EXIT FOR\n  END IF\nNEXT I\nEND\n\nFUNCTION EmptyStack\n  IF TopStack = 0 THEN\n    EmptyStack = True\n  ELSE\n    EmptyStack = False\n  END IF\nEND FUNCTION\n\nSUB InStack (X)\n  IF TopStack = DeepStack THEN\n    PRINT \"Error: \u00a1La pila est\u00e1 llena!\"\n    STOP\n  ELSE\n    TopStack = TopStack + 1\n    Stack(TopStack) = X\n  END IF\nEND SUB\n\nFUNCTION OutStack\n  IF TopStack = 0 THEN\n    PRINT : PRINT \"Error: \u00a1La pila est\u00e1 vac\u00eda!\"\n    STOP\n  ELSE\n    OutStack = Stack(TopStack)\n    TopStack = TopStack - 1\n  END IF\nEND FUNCTION\n</code></pre>"},{"location":"pilas/#explicacion-del-programa","title":"Explicaci\u00f3n del programa","text":"<ol> <li>El programa solicita al usuario cu\u00e1ntos elementos desea a\u00f1adir a la pila.</li> <li>A\u00f1ade los n\u00fameros del 1 al NS a la pila (operaci\u00f3n Push).</li> <li>Si NS es mayor que 100 (la profundidad m\u00e1xima de la pila), mostrar\u00e1 un mensaje de desbordamiento (overflow) y detendr\u00e1 el programa.</li> <li>Luego solicita cu\u00e1ntos elementos desea extraer de la pila.</li> <li>Extrae y muestra OS elementos de la pila (operaci\u00f3n Pop).</li> <li>Si se intenta extraer m\u00e1s elementos de los que contiene la pila, mostrar\u00e1 un mensaje indicando que la pila est\u00e1 vac\u00eda.</li> </ol>"},{"location":"pilas/#aplicaciones-practicas-de-las-pilas","title":"Aplicaciones pr\u00e1cticas de las pilas","text":"<p>Las pilas son estructuras de datos muy \u00fatiles para diversas aplicaciones:</p> <ol> <li>Evaluaci\u00f3n de expresiones matem\u00e1ticas: Utilizadas para evaluar expresiones en notaci\u00f3n polaca inversa o para convertir entre diferentes notaciones.</li> <li>Control de recursi\u00f3n: Los lenguajes de programaci\u00f3n utilizan pilas para gestionar llamadas a funciones recursivas.</li> <li>Verificaci\u00f3n de par\u00e9ntesis balanceados: \u00datil para verificar si las expresiones tienen sus par\u00e9ntesis, corchetes y llaves correctamente balanceados.</li> <li>Algoritmos de b\u00fasqueda en profundidad: Utilizados en la exploraci\u00f3n de \u00e1rboles y grafos.</li> <li>Historial de navegaci\u00f3n: Los navegadores web utilizan pilas para implementar el historial (bot\u00f3n \"Atr\u00e1s\").</li> </ol>"},{"location":"pilas/#ampliaciones-posibles","title":"Ampliaciones posibles","text":"<p>La implementaci\u00f3n b\u00e1sica puede mejorarse de varias maneras:</p> <ol> <li>Pila din\u00e1mica: Aunque QBasic tiene limitaciones, se podr\u00eda implementar una pila que pueda crecer din\u00e1micamente usando REDIM.</li> <li>Pila de diferentes tipos de datos: Modificar la pila para almacenar diferentes tipos de datos utilizando tipos definidos por el usuario.</li> <li>Verificaci\u00f3n de desbordamiento silenciosa: En lugar de detener el programa, podr\u00eda devolver un c\u00f3digo de error.</li> <li>Implementaci\u00f3n de operaciones adicionales: Como Peek (ver el elemento superior sin extraerlo) o operaciones de b\u00fasqueda.</li> </ol>"},{"location":"pilas/#conclusion","title":"Conclusi\u00f3n","text":"<p>Las pilas son estructuras de datos fundamentales que son relativamente f\u00e1ciles de implementar en QBasic utilizando arrays. Aunque esta implementaci\u00f3n est\u00e1 limitada por el tama\u00f1o fijo del array, proporciona todas las operaciones b\u00e1sicas de una pila y puede ser \u00fatil para muchas aplicaciones.</p> <p>Este art\u00edculo est\u00e1 basado en una publicaci\u00f3n original en Peter Cooper's BASIX Fanzine, N\u00famero #1 de noviembre de 1995, escrito por Adrian, que posteriormente form\u00f3 parte del libro \"The Revolutionary Guide to QBasic\" de Wrox Press.</p>"},{"location":"programacion-modular/","title":"Programaci\u00f3n Modular en QBasic","text":"<p>En art\u00edculos anteriores, discutimos el uso de m\u00f3dulos en la programaci\u00f3n estructurada, pero no entramos en detalles sobre c\u00f3mo utilizarlos en la programaci\u00f3n con QBasic. En este art\u00edculo, hablaremos sobre c\u00f3mo usar diferentes tipos de m\u00f3dulos para organizar correctamente proyectos grandes.</p>"},{"location":"programacion-modular/#dos-tipos-de-modulos","title":"Dos Tipos de M\u00f3dulos","text":"<p>En QBasic, tenemos m\u00f3dulos y archivos de inclusi\u00f3n. Basados en su uso, llamamos al primer grupo \"M\u00f3dulos de C\u00f3digo\" y al otro \"M\u00f3dulos de Inclusi\u00f3n\".</p>"},{"location":"programacion-modular/#modulos-de-inclusion","title":"M\u00f3dulos de Inclusi\u00f3n","text":"<p>En la tradici\u00f3n de QBasic, estos archivos generalmente tienen la extensi\u00f3n <code>.BI</code>. Los m\u00f3dulos de inclusi\u00f3n se utilizan principalmente para contener declaraciones de procedimientos y funciones, variables, variables globales (declaradas usando la instrucci\u00f3n COMMON), tipos definidos por el usuario, etc. Los m\u00f3dulos de inclusi\u00f3n son muy \u00fatiles para compartir declaraciones. Aqu\u00ed hay una lista de algunos de sus usos m\u00e1s importantes:</p> <ol> <li> <p>Declaraci\u00f3n de procedimientos: Cuando tienes un m\u00f3dulo de c\u00f3digo que contiene varios procedimientos, debes declarar estos procedimientos en cualquier m\u00f3dulo donde quieras utilizarlos. Puedes colocar todas las declaraciones en un m\u00f3dulo de inclusi\u00f3n (que puedes nombrar igual que el m\u00f3dulo de c\u00f3digo pero con extensi\u00f3n <code>.BI</code>). Luego, en cada m\u00f3dulo donde quieras usar los procedimientos, puedes poner un meta-comando <code>$INCLUDE</code> en la parte superior de ese m\u00f3dulo.</p> </li> <li> <p>Compartir tipos definidos por el usuario: Esto significa que no necesitas declarar los tipos definidos por el usuario en cada m\u00f3dulo que los utilice. Simplemente coloca las declaraciones en un m\u00f3dulo de inclusi\u00f3n e incl\u00fayelo en tus m\u00f3dulos de c\u00f3digo.</p> </li> <li> <p>Variables globales: Cuando quieres tener una variable global accesible en todos los m\u00f3dulos, necesitas declarar las variables en todos los m\u00f3dulos usando una instrucci\u00f3n COMMON. Aqu\u00ed nuevamente puedes colocar las instrucciones COMMON en un m\u00f3dulo de inclusi\u00f3n e incluirlo en todos los dem\u00e1s m\u00f3dulos.</p> </li> </ol> <p>Hay un punto importante sobre los m\u00f3dulos de inclusi\u00f3n: No coloques comandos ejecutables en un m\u00f3dulo de inclusi\u00f3n. Hacerlo puede causar errores si colocas algunos comandos no ejecutables (como DECLARE, COMMON, etc.) despu\u00e9s de la instrucci\u00f3n include.</p>"},{"location":"programacion-modular/#modulos-de-codigo","title":"M\u00f3dulos de C\u00f3digo","text":"<p>Los m\u00f3dulos de c\u00f3digo son los medios para dividir el c\u00f3digo discutidos en el art\u00edculo \"T\u00e9cnicas de Codificaci\u00f3n\". Las ideas principales sobre el uso de estos m\u00f3dulos se pueden encontrar en ese art\u00edculo. Estos archivos, que en la tradici\u00f3n de QBasic tienen extensi\u00f3n <code>.BAS</code>, forman el cuerpo principal de tu proyecto.</p>"},{"location":"programacion-modular/#como-implementarlo-en-qbasic","title":"C\u00f3mo implementarlo en QBasic","text":"<p>Hemos hablado mucho sobre m\u00f3dulos. Pero, \u00bfc\u00f3mo se pueden usar estas t\u00e9cnicas en QBasic? Aqu\u00ed te mostrar\u00e9 c\u00f3mo QBasic gestiona m\u00faltiples m\u00f3dulos (recordando que las versiones anteriores de QBasic no admiten m\u00f3dulos).</p> <p>Cada proyecto de QBasic contiene un m\u00f3dulo principal que tiene el punto de inicio del programa. Este c\u00f3digo de inicio es el c\u00f3digo a nivel de m\u00f3dulo del m\u00f3dulo principal. Otros m\u00f3dulos no deben tener c\u00f3digo a nivel de m\u00f3dulo (de hecho, pueden tenerlo, pero el c\u00f3digo nunca se ejecutar\u00e1). Los procedimientos en otros m\u00f3dulos son llamados desde el m\u00f3dulo principal (o desde un procedimiento al que llama el m\u00f3dulo principal).</p>"},{"location":"programacion-modular/#creacion-de-un-proyecto-multi-modulo","title":"Creaci\u00f3n de un proyecto multi-m\u00f3dulo","text":"<p>Para crear un proyecto de m\u00faltiples m\u00f3dulos desde el entorno de QBasic:</p> <ol> <li>Abre tu m\u00f3dulo (o cr\u00e9alo)</li> <li>Desde el men\u00fa Archivo, elige \"Cargar Archivo\" o \"Crear Archivo\"</li> <li>Ingresa (o elige) el m\u00f3dulo que deseas agregar al proyecto y selecciona OK</li> <li>El m\u00f3dulo se agregar\u00e1 al proyecto</li> </ol> <p>Puedes cambiar entre m\u00f3dulos eligiendo \"Subs\" desde el men\u00fa Ver o presionando F2.</p> <p>Cuando agregas un m\u00f3dulo al proyecto, QBasic crea (si es necesario) un archivo de proyecto con el mismo nombre que el m\u00f3dulo principal y extensi\u00f3n <code>.MAK</code>, y agrega el nombre de los m\u00f3dulos a \u00e9l. Luego, cada vez que abres el m\u00f3dulo principal, QBasic encuentra y abre los otros m\u00f3dulos (el archivo de proyecto debe estar en la misma carpeta que el m\u00f3dulo principal).</p>"},{"location":"programacion-modular/#ejemplo-de-estructura-de-proyecto-modular","title":"Ejemplo de Estructura de Proyecto Modular","text":"<p>A continuaci\u00f3n se muestra un ejemplo de c\u00f3mo podr\u00edas organizar un proyecto QBasic con m\u00faltiples m\u00f3dulos:</p>"},{"location":"programacion-modular/#archivo-globalbi-modulo-de-inclusion","title":"Archivo: GLOBAL.BI (M\u00f3dulo de Inclusi\u00f3n)","text":"<pre><code>' Declaraciones globales para todo el proyecto\nTYPE ConfiguracionType\n  RutaArchivos AS STRING * 64\n  ModoGrafico AS INTEGER\n  ColorFondo AS INTEGER\nEND TYPE\n\n' Variables globales compartidas\nCOMMON SHARED Configuracion AS ConfiguracionType\nCOMMON SHARED ArchivoActual AS STRING * 64\n</code></pre>"},{"location":"programacion-modular/#archivo-graficosbi-modulo-de-inclusion","title":"Archivo: GRAFICOS.BI (M\u00f3dulo de Inclusi\u00f3n)","text":"<pre><code>' Declaraciones de procedimientos gr\u00e1ficos\nDECLARE SUB InicializarGraficos (Modo%)\nDECLARE SUB DibujarCuadro (x1%, y1%, x2%, y2%, Color%)\nDECLARE SUB DibujarMenu ()\nDECLARE FUNCTION DetectarTarjetaVGA% ()\n</code></pre>"},{"location":"programacion-modular/#archivo-principalbas-modulo-de-codigo-principal","title":"Archivo: PRINCIPAL.BAS (M\u00f3dulo de C\u00f3digo Principal)","text":"<pre><code>' Inclusi\u00f3n de m\u00f3dulos\n'$INCLUDE: 'GLOBAL.BI'\n'$INCLUDE: 'GRAFICOS.BI'\n'$INCLUDE: 'ARCHIVOS.BI'\n\n' M\u00f3dulo principal del programa\nSUB Main\n  ' Inicializaci\u00f3n\n  InicializarPrograma\n\n  ' Bucle principal\n  DO\n    opcion = MostrarMenuPrincipal()\n    SELECT CASE opcion\n      CASE 1: ProcesarArchivos\n      CASE 2: EditarConfiguracion\n      CASE 3: MostrarAyuda\n      CASE 0: ' Salir\n    END SELECT\n  LOOP UNTIL opcion = 0\n\n  ' Finalizaci\u00f3n\n  FinalizarPrograma\nEND SUB\n\n' Inicializa los componentes del programa\nSUB InicializarPrograma\n  ' Inicializar variables\n  Configuracion.RutaArchivos = \"C:\\DATOS\\\"\n  Configuracion.ModoGrafico = 1\n  Configuracion.ColorFondo = 1\n\n  ' Inicializar gr\u00e1ficos\n  InicializarGraficos Configuracion.ModoGrafico\nEND SUB\n\n' Finaliza el programa y libera recursos\nSUB FinalizarPrograma\n  ' C\u00f3digo de finalizaci\u00f3n...\nEND SUB\n\n' Punto de entrada principal\nMain\nEND\n</code></pre>"},{"location":"programacion-modular/#archivo-graficosbas-modulo-de-codigo-para-graficos","title":"Archivo: GRAFICOS.BAS (M\u00f3dulo de C\u00f3digo para Gr\u00e1ficos)","text":"<pre><code>'$INCLUDE: 'GLOBAL.BI'\n'$INCLUDE: 'GRAFICOS.BI'\n\n' Inicializa el modo gr\u00e1fico\nSUB InicializarGraficos (Modo%)\n  SCREEN Modo%\n  CLS\n  COLOR Configuracion.ColorFondo\nEND SUB\n\n' Dibuja un cuadro en la pantalla\nSUB DibujarCuadro (x1%, y1%, x2%, y2%, Color%)\n  LINE (x1%, y1%)-(x2%, y2%), Color%, B\nEND SUB\n\n' Dibuja el men\u00fa en pantalla\nSUB DibujarMenu ()\n  ' C\u00f3digo para dibujar men\u00fa...\nEND SUB\n\n' Detecta si hay tarjeta VGA disponible\nFUNCTION DetectarTarjetaVGA%\n  ' C\u00f3digo para detectar hardware...\n  DetectarTarjetaVGA% = -1 ' True\nEND FUNCTION\n</code></pre>"},{"location":"programacion-modular/#conclusion","title":"Conclusi\u00f3n","text":"<p>Organizar tu proyecto en m\u00f3dulos es un excelente m\u00e9todo para mantener tu c\u00f3digo estructurado y manejable. Si no has probado este m\u00e9todo hasta ahora, int\u00e9ntalo en tu pr\u00f3ximo proyecto y observa los resultados. La programaci\u00f3n modular permite:</p> <ul> <li>Mayor claridad y organizaci\u00f3n del c\u00f3digo</li> <li>Reutilizaci\u00f3n de componentes en diferentes proyectos</li> <li>Desarrollo en equipo m\u00e1s eficiente</li> <li>Mantenimiento m\u00e1s sencillo del c\u00f3digo</li> </ul> <p>Autor original: Homayoon.P.A. Fecha original: 5 de diciembre de 2002 Publicado originalmente en Sepent Technologies.</p>"},{"location":"raycasting/","title":"Raycasting en QBasic","text":"<p>Autor: William Moores</p>"},{"location":"raycasting/#introduccion","title":"Introducci\u00f3n","text":"<p>\u00bfQuieres crear un juego como DOOM? Con esta gu\u00eda, explicaremos los fundamentos del raycasting, que te permitir\u00e1 desarrollar juegos con perspectiva 3D en QBasic.</p> <p>El concepto del raycasting es muy simple: imagina que tienes un puntero l\u00e1ser con una peque\u00f1a pantalla en la parte posterior que muestra el color y la distancia del objeto al que est\u00e1s apuntando. \u00a1El raycasting funciona exactamente as\u00ed! En QBasic, implementar esta t\u00e9cnica es m\u00e1s sencillo de lo que parece.</p>"},{"location":"raycasting/#fundamentos-del-raycasting","title":"Fundamentos del Raycasting","text":""},{"location":"raycasting/#el-mapa","title":"El Mapa","text":"<p>Primero necesitamos un mapa para nuestro entorno. Podemos crearlo con un array bidimensional:</p> <pre><code>DIM map%(1 TO 20, 1 TO 20)\n</code></pre> <p>Este c\u00f3digo crea un nivel de 20\u00d720 bloques. Cada elemento del array representa una pared en nuestro demo (por ejemplo, <code>map%(3, 4) = 10</code> colocar\u00eda una pared en la posici\u00f3n (3,4) con color 10).</p>"},{"location":"raycasting/#el-concepto-del-ray-rayo","title":"El Concepto del Ray (Rayo)","text":"<p>La parte \"ray\" del raycasting funciona as\u00ed:</p> <ol> <li>La \"c\u00e1mara\" emite rayos en diferentes direcciones</li> <li>Cuando un rayo golpea una pared en nuestro mapa, la \"c\u00e1mara\" registra:</li> <li>El color de la pared que ha golpeado</li> <li>La distancia a la pared</li> <li>El rayo deja de avanzar</li> </ol> <p>Es similar a un radar: emite ondas que rebotan en objetos s\u00f3lidos, y luego calcula la distancia a esos objetos bas\u00e1ndose en el tiempo que tardan las ondas en regresar.</p>"},{"location":"raycasting/#implementacion-2d","title":"Implementaci\u00f3n 2D","text":"<p>Antes de abordar el 3D, es \u00fatil visualizar el raycasting en 2D. En una demo 2D, podemos ver:</p> <ul> <li>Una vista superior de nuestro mapa</li> <li>Un peque\u00f1o cono que podemos rotar y mover (nuestra \"c\u00e1mara\")</li> <li>Los rayos que salen de la c\u00e1mara</li> </ul> <p>Esta visualizaci\u00f3n 2D nos ayuda a entender c\u00f3mo la c\u00e1mara emite rayos y c\u00f3mo estos interact\u00faan con las paredes.</p>"},{"location":"raycasting/#ejemplo-de-codigo-2d-2draybas","title":"Ejemplo de c\u00f3digo 2D (2DRAY.BAS)","text":"<p>A continuaci\u00f3n se presenta un esquema conceptual de la implementaci\u00f3n 2D:</p> <pre><code>' Inicializar el mapa\nDIM map%(1 TO 20, 1 TO 20)\n' Llenar el mapa con paredes\nFOR y = 1 TO 20\n  FOR x = 1 TO 20\n    IF x = 1 OR y = 1 OR x = 20 OR y = 20 THEN\n      map%(x, y) = 14 ' Paredes exteriores en color 14\n    ELSE\n      map%(x, y) = 0 ' Espacio vac\u00edo\n    END IF\n  NEXT x\nNEXT y\n' A\u00f1adir algunas paredes interiores\nmap%(5, 5) = 12: map%(6, 5) = 12: map%(7, 5) = 12\n\n' Variables para la c\u00e1mara\ncamX = 10: camY = 10 ' Posici\u00f3n inicial\ncamAngle = 0 ' \u00c1ngulo inicial (en radianes)\n\n' Bucle principal\nDO\n  ' Borrar pantalla\n  CLS\n\n  ' Dibujar mapa\n  FOR y = 1 TO 20\n    FOR x = 1 TO 20\n      IF map%(x, y) &gt; 0 THEN\n        PSET (x * 8, y * 8), map%(x, y)\n      END IF\n    NEXT x\n  NEXT y\n\n  ' Dibujar c\u00e1mara\n  CIRCLE (camX * 8, camY * 8), 3, 15\n\n  ' Dibujar rayos\n  FOR rayAngle = camAngle - .3 TO camAngle + .3 STEP .02\n    ' Emitir rayo\n    rayX = camX\n    rayY = camY\n    rayDist = 0\n\n    DO\n      ' Avanzar rayo\n      rayX = rayX + COS(rayAngle) * .1\n      rayY = rayY + SIN(rayAngle) * .1\n      rayDist = rayDist + .1\n\n      ' Comprobar si el rayo golpea una pared\n      mapX = INT(rayX)\n      mapY = INT(rayY)\n\n      IF mapX &gt;= 1 AND mapX &lt;= 20 AND mapY &gt;= 1 AND mapY &lt;= 20 THEN\n        IF map%(mapX, mapY) &gt; 0 THEN\n          ' Rayo golpe\u00f3 una pared\n          LINE (camX * 8, camY * 8)-(rayX * 8, rayY * 8), map%(mapX, mapY)\n          EXIT DO\n        END IF\n      ELSE\n        ' Rayo sali\u00f3 del mapa\n        EXIT DO\n      END IF\n    LOOP WHILE rayDist &lt; 20\n  NEXT rayAngle\n\n  ' Controles de movimiento\n  k$ = INKEY$\n  IF k$ = CHR$(0) + \"H\" THEN ' Flecha arriba\n    camX = camX + COS(camAngle) * .5\n    camY = camY + SIN(camAngle) * .5\n  ELSEIF k$ = CHR$(0) + \"P\" THEN ' Flecha abajo\n    camX = camX - COS(camAngle) * .5\n    camY = camY - SIN(camAngle) * .5\n  ELSEIF k$ = CHR$(0) + \"K\" THEN ' Flecha izquierda\n    camAngle = camAngle - .1\n  ELSEIF k$ = CHR$(0) + \"M\" THEN ' Flecha derecha\n    camAngle = camAngle + .1\n  END IF\n\n  ' Salir del programa\n  IF k$ = CHR$(27) THEN EXIT DO\n\n  ' Peque\u00f1a pausa\n  _LIMIT 30\nLOOP\n</code></pre>"},{"location":"raycasting/#implementacion-3d","title":"Implementaci\u00f3n 3D","text":"<p>Para crear el efecto 3D, en lugar de dibujar los rayos directamente, dibujamos l\u00edneas verticales en la pantalla que corresponden a cada rayo emitido. La altura de cada l\u00ednea se calcula bas\u00e1ndose en la distancia a la pared: cuanto m\u00e1s cerca est\u00e9 la pared, m\u00e1s alta ser\u00e1 la l\u00ednea.</p> <p>La implementaci\u00f3n 3D utiliza la misma l\u00f3gica de raycasting que la versi\u00f3n 2D, pero representa los resultados de manera diferente para crear la ilusi\u00f3n de 3D.</p>"},{"location":"raycasting/#ejemplo-de-codigo-3d-3draybas","title":"Ejemplo de c\u00f3digo 3D (3DRAY.BAS)","text":"<p>A continuaci\u00f3n se presenta un esquema conceptual de la implementaci\u00f3n 3D:</p> <pre><code>' Inicializar el mapa (igual que en la versi\u00f3n 2D)\nDIM map%(1 TO 20, 1 TO 20)\n' ... c\u00f3digo para inicializar el mapa ...\n\n' Variables para la c\u00e1mara\ncamX = 10: camY = 10\ncamAngle = 0\nscreenWidth = 320 ' Ancho de la pantalla\n\n' Modo gr\u00e1fico\nSCREEN 13 ' 320x200, 256 colores\n\n' Bucle principal\nDO\n  ' Preparar la pantalla\n  LINE (0, 0)-(screenWidth, 100), 9, BF ' Cielo\n  LINE (0, 100)-(screenWidth, 200), 2, BF ' Suelo\n\n  ' Emitir rayos y dibujar paredes\n  rayAngleStep = .6 / screenWidth ' Campo de visi\u00f3n dividido por el ancho de la pantalla\n\n  FOR screenX = 0 TO screenWidth - 1\n    ' Calcular \u00e1ngulo del rayo\n    rayAngle = camAngle - .3 + rayAngleStep * screenX\n\n    ' Emitir rayo\n    rayX = camX\n    rayY = camY\n    rayDist = 0\n    hitColor = 0\n\n    DO\n      ' Avanzar rayo\n      rayX = rayX + COS(rayAngle) * .05\n      rayY = rayY + SIN(rayAngle) * .05\n      rayDist = rayDist + .05\n\n      ' Comprobar si el rayo golpea una pared\n      mapX = INT(rayX)\n      mapY = INT(rayY)\n\n      IF mapX &gt;= 1 AND mapX &lt;= 20 AND mapY &gt;= 1 AND mapY &lt;= 20 THEN\n        IF map%(mapX, mapY) &gt; 0 THEN\n          ' Rayo golpe\u00f3 una pared\n          hitColor = map%(mapX, mapY)\n          EXIT DO\n        END IF\n      ELSE\n        ' Rayo sali\u00f3 del mapa\n        EXIT DO\n      END IF\n    LOOP WHILE rayDist &lt; 20\n\n    ' Calcular altura de la l\u00ednea\n    lineHeight = 200\n    IF rayDist &gt; 0 THEN\n      ' Corregir el efecto \"ojo de pez\" (opcional)\n      correctedDist = rayDist * COS(rayAngle - camAngle)\n      lineHeight = 3000 / correctedDist\n      IF lineHeight &gt; 200 THEN lineHeight = 200\n    END IF\n\n    ' Calcular posici\u00f3n y de inicio y fin\n    lineY1 = 100 - lineHeight / 2\n    lineY2 = lineY1 + lineHeight\n\n    ' Dibujar l\u00ednea vertical (pared)\n    IF hitColor &gt; 0 THEN\n      ' Oscurecer colores basado en la distancia\n      shade = 15 - INT(rayDist)\n      IF shade &lt; 0 THEN shade = 0\n      actualColor = hitColor - 8 + shade\n      IF actualColor &lt; hitColor - 8 THEN actualColor = hitColor - 8\n      IF actualColor &gt; hitColor THEN actualColor = hitColor\n\n      LINE (screenX, lineY1)-(screenX, lineY2), actualColor\n    END IF\n  NEXT screenX\n\n  ' Controles de movimiento (igual que en la versi\u00f3n 2D)\n  ' ... c\u00f3digo para mover la c\u00e1mara ...\n\n  ' Peque\u00f1a pausa\n  _LIMIT 30\nLOOP\n</code></pre>"},{"location":"raycasting/#el-efecto-ojo-de-pez","title":"El Efecto \"Ojo de Pez\"","text":"<p>Un problema com\u00fan con el raycasting simple es el efecto \"ojo de pez\", donde las paredes aparecen curvadas en lugar de rectas. Esto ocurre porque estamos midiendo la distancia directa desde la c\u00e1mara a la pared, pero para una representaci\u00f3n 3D m\u00e1s realista, necesitar\u00edamos la distancia perpendicular al \"plano de proyecci\u00f3n\".</p> <p>Se puede corregir este efecto multiplicando la distancia por el coseno del \u00e1ngulo entre el rayo y la direcci\u00f3n de la c\u00e1mara, como se muestra en el ejemplo 3D.</p>"},{"location":"raycasting/#mejoras-posibles","title":"Mejoras Posibles","text":"<p>Con esta base de raycasting, puedes implementar varias mejoras:</p> <ol> <li>Texturas: En lugar de usar colores s\u00f3lidos, puedes mapear texturas en las paredes</li> <li>Iluminaci\u00f3n: Implementar luces en el entorno</li> <li>Sprites: A\u00f1adir objetos y personajes como sprites 2D</li> <li>Suelos y Techos Texturizados: M\u00e1s all\u00e1 del raycasting b\u00e1sico</li> <li>Colisiones: Impedir que la c\u00e1mara atraviese paredes</li> </ol>"},{"location":"raycasting/#conclusion","title":"Conclusi\u00f3n","text":"<p>El raycasting es una t\u00e9cnica poderosa que te permite crear entornos 3D convincentes incluso en un lenguaje como QBasic. Con este conocimiento, puedes comenzar a desarrollar juegos similares a los cl\u00e1sicos de los a\u00f1os 90 como Wolfenstein 3D y DOOM.</p> <p>Como sugiere el autor original: \"\u00a1Piensa en ello, podr\u00edas a\u00f1adir luces! Todo lo que tendr\u00edas que hacer es lo opuesto a una c\u00e1mara. En lugar de leer el color, \u00a1podr\u00edas escribir el color!\"</p> <p>Los ejemplos proporcionados son intencionalmente simples para facilitar la comprensi\u00f3n, pero se pueden optimizar y expandir considerablemente para crear juegos completos.</p>"},{"location":"recursos/","title":"Recursos","text":"<p>Esta secci\u00f3n contiene enlaces a recursos \u00fatiles, documentaci\u00f3n de referencia, libros, emuladores y otras herramientas relacionadas con QBasic.</p>"},{"location":"recursos/#documentacion-de-referencia","title":"Documentaci\u00f3n de Referencia","text":"<ul> <li> <p>QBasic_1_1_Referencia.pdf - Manual de referencia completo de QBasic 1.1 con todas las instrucciones, funciones y caracter\u00edsticas del lenguaje.</p> </li> <li> <p>QBASIC_user_guide.pdf - Gu\u00eda de usuario de QBasic creada por John Walker de Marinchip Systems. Este documento est\u00e1 en ingl\u00e9s y fue obtenido desde fourmilab.ch.</p> </li> </ul>"},{"location":"recursos/#sitios-web","title":"Sitios Web","text":"<ul> <li> <p>QBasic.net - Uno de los sitios m\u00e1s completos sobre QBasic, con tutoriales, ejemplos y foros de discusi\u00f3n.</p> </li> <li> <p>Pete's QBasic Site - Recursos, tutoriales y c\u00f3digo de ejemplo para QBasic.</p> </li> <li> <p>QB64.org - Sitio oficial de QB64, la implementaci\u00f3n moderna de QBasic.</p> </li> </ul>"},{"location":"recursos/#emuladores-y-entornos-de-desarrollo","title":"Emuladores y Entornos de Desarrollo","text":"<ul> <li> <p>DOSBox - Emulador de DOS que permite ejecutar QBasic en sistemas operativos modernos.</p> </li> <li> <p>QB64 - Un compilador y entorno de desarrollo moderno compatible con QBasic.</p> </li> <li> <p>FreeBASIC - Un compilador BASIC de c\u00f3digo abierto con compatibilidad parcial con QBasic.</p> </li> </ul>"},{"location":"recursos/#tutoriales-y-cursos","title":"Tutoriales y Cursos","text":"<ul> <li> <p>Tutoriales de QBasic.net - Serie de tutoriales desde nivel principiante hasta avanzado.</p> </li> <li> <p>QB64 Wiki - Documentaci\u00f3n completa sobre QB64 con ejemplos y tutoriales.</p> </li> </ul>"},{"location":"recursos/#comunidades","title":"Comunidades","text":"<ul> <li> <p>Foro QB64 - Comunidad activa de programadores de QB64 y QBasic.</p> </li> <li> <p>Reddit r/qbasic - Comunidad de Reddit dedicada a QBasic.</p> </li> <li> <p>Discord de QB64 - Servidor de Discord para discusiones en tiempo real sobre QB64 y QBasic.</p> </li> </ul>"},{"location":"recursos/#libros-recomendados","title":"Libros Recomendados","text":"<ul> <li>\"Microsoft QuickBASIC: Programming for the Absolute Beginner\" - Doug Hergert</li> <li>\"Microsoft QBasic: An Introduction to Structured Programming\" - Mitchell Waite &amp; Stephen Prata</li> <li>\"Programmer's Guide to Microsoft QuickBASIC\" - David I. Schneider</li> </ul>"},{"location":"recursos/#codigos-de-ejemplo","title":"C\u00f3digos de Ejemplo","text":"<ul> <li>Colecci\u00f3n de QBasic.net - Juegos y aplicaciones escritos en QBasic.</li> <li>Ejemplos de Pete's QBasic Site - Tutoriales con c\u00f3digo de ejemplo para diversos prop\u00f3sitos.</li> </ul>"},{"location":"sintaxis/","title":"Sintaxis","text":"<p>La sintaxis de QBasic sigue las convenciones generales de la familia de lenguajes BASIC, con algunas particularidades propias. Esta secci\u00f3n cubre las reglas fundamentales para escribir c\u00f3digo QBasic v\u00e1lido.</p>"},{"location":"sintaxis/#estructura-de-un-programa","title":"Estructura de un programa","text":"<p>Un programa en QBasic tiene la siguiente estructura general:</p> <pre><code>' Declaraciones (opcional)\nDECLARE SUB MiSubrutina (parametro1 AS INTEGER, parametro2 AS STRING)\nDIM variables AS tipo\n\n' Programa principal\nCLS\nPRINT \"Hola Mundo\"\nMiSubrutina 10, \"texto\"\nEND\n\n' Subrutinas y funciones\nSUB MiSubrutina (x AS INTEGER, texto AS STRING)\n    PRINT x; texto\nEND SUB\n</code></pre>"},{"location":"sintaxis/#tipos-de-datos","title":"Tipos de datos","text":"<p>QBasic ofrece varios tipos de datos nativos:</p> Tipo Descripci\u00f3n Rango Espacio Ejemplo INTEGER Entero de 16 bits -32,768 a 32,767 2 bytes <code>DIM a AS INTEGER</code> LONG Entero de 32 bits -2,147,483,648 a 2,147,483,647 4 bytes <code>DIM b AS LONG</code> SINGLE Punto flotante \u00b13.4E-38 a \u00b13.4E+38 4 bytes <code>DIM c AS SINGLE</code> DOUBLE Punto flotante doble precisi\u00f3n \u00b11.7E-308 a \u00b11.7E+308 8 bytes <code>DIM d AS DOUBLE</code> STRING Cadena de caracteres M\u00e1ximo 32,767 caracteres Variable <code>DIM e AS STRING</code> STRING * n Cadena de longitud fija n caracteres n bytes <code>DIM f AS STRING * 10</code>"},{"location":"sintaxis/#declaracion-de-variables","title":"Declaraci\u00f3n de variables","text":"<p>Las variables se pueden declarar con:</p> <pre><code>DIM miVariable AS tipo   ' Declaraci\u00f3n expl\u00edcita\nDIM miArray(10) AS tipo  ' Array de una dimensi\u00f3n\nDIM miMatriz(5, 5) AS tipo  ' Array de dos dimensiones\n</code></pre> <p>Tambi\u00e9n puedes usar sufijos para definir el tipo:</p> <ul> <li><code>%</code> para INTEGER: <code>contador%</code></li> <li><code>&amp;</code> para LONG: <code>numeroGrande&amp;</code></li> <li><code>!</code> para SINGLE: <code>decimal!</code></li> <li><code>#</code> para DOUBLE: <code>pi#</code></li> <li><code>$</code> para STRING: <code>nombre$</code></li> </ul>"},{"location":"sintaxis/#operadores","title":"Operadores","text":""},{"location":"sintaxis/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"Operador Descripci\u00f3n Ejemplo + Suma <code>a = b + c</code> - Resta <code>a = b - c</code> * Multiplicaci\u00f3n <code>a = b * c</code> / Divisi\u00f3n <code>a = b / c</code> \\ Divisi\u00f3n entera <code>a = 7 \\ 2</code> (resultado: 3) MOD M\u00f3dulo (resto) <code>a = 7 MOD 2</code> (resultado: 1) ^ Exponenciaci\u00f3n <code>a = 2 ^ 3</code> (resultado: 8) - Negaci\u00f3n <code>a = -b</code>"},{"location":"sintaxis/#operadores-relacionales","title":"Operadores relacionales","text":"Operador Descripci\u00f3n Ejemplo = Igual a <code>IF a = b THEN</code> &lt;&gt; Distinto a <code>IF a &lt;&gt; b THEN</code> &lt; Menor que <code>IF a &lt; b THEN</code> &gt; Mayor que <code>IF a &gt; b THEN</code> &lt;= Menor o igual que <code>IF a &lt;= b THEN</code> &gt;= Mayor o igual que <code>IF a &gt;= b THEN</code>"},{"location":"sintaxis/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"Operador Descripci\u00f3n Ejemplo AND Y l\u00f3gico <code>IF a &gt; 0 AND b &gt; 0 THEN</code> OR O l\u00f3gico <code>IF a &gt; 0 OR b &gt; 0 THEN</code> NOT Negaci\u00f3n l\u00f3gica <code>IF NOT a = 0 THEN</code> XOR O exclusivo <code>result = a XOR b</code> EQV Equivalencia <code>result = a EQV b</code> IMP Implicaci\u00f3n <code>result = a IMP b</code>"},{"location":"sintaxis/#constantes","title":"Constantes","text":"<p>Se pueden definir constantes con la instrucci\u00f3n <code>CONST</code>:</p> <pre><code>CONST PI = 3.14159\nCONST NOMBRE$ = \"QBasic\"\nCONST MAX_ELEMENTOS = 100\n</code></pre>"},{"location":"sintaxis/#comentarios","title":"Comentarios","text":"<p>Los comentarios en QBasic se indican con ap\u00f3strofe o con la palabra clave <code>REM</code>:</p> <pre><code>' Esto es un comentario\nREM Esto tambi\u00e9n es un comentario\n</code></pre>"},{"location":"sintaxis/#continuacion-de-linea","title":"Continuaci\u00f3n de l\u00ednea","text":"<p>Para continuar una l\u00ednea larga en la siguiente, se usa el car\u00e1cter <code>_</code>:</p> <pre><code>PRINT \"Esta es una l\u00ednea muy larga que contin\u00faa \" + _\n      \"en la siguiente l\u00ednea\"\n</code></pre>"},{"location":"sintaxis/#convenciones-de-nombres","title":"Convenciones de nombres","text":"<ul> <li>Los nombres de variables, subrutinas y funciones son insensibles a may\u00fasculas/min\u00fasculas: <code>Contador</code> es igual a <code>CONTADOR</code> o <code>contador</code></li> <li>Pueden contener letras, n\u00fameros y algunos caracteres especiales como el guion bajo</li> <li>Deben comenzar con una letra</li> <li>No pueden contener espacios ni usar palabras reservadas</li> <li>La longitud m\u00e1xima es de 40 caracteres</li> </ul>"},{"location":"sonido/","title":"Sonido","text":"<p>QBasic ofrece varias instrucciones para reproducir sonidos a trav\u00e9s del altavoz del PC. Estas capacidades van desde simples pitidos hasta melod\u00edas complejas y efectos de sonido personalizados.</p>"},{"location":"sonido/#comandos-basicos-de-sonido","title":"Comandos B\u00e1sicos de Sonido","text":""},{"location":"sonido/#beep","title":"BEEP","text":"<p>La instrucci\u00f3n m\u00e1s simple para producir sonido en QBasic es <code>BEEP</code>. Produce un pitido corto con una frecuencia y duraci\u00f3n predeterminadas:</p> <pre><code>BEEP  ' Produce un pitido est\u00e1ndar\n</code></pre> <p>Este comando es \u00fatil para alertas o confirmaciones simples.</p>"},{"location":"sonido/#sound","title":"SOUND","text":"<p>El comando <code>SOUND</code> ofrece control directo sobre la frecuencia y duraci\u00f3n de un tono:</p> <pre><code>SOUND frecuencia, duraci\u00f3n\n</code></pre> <ul> <li>frecuencia: valor en Hertz (Hz) entre 37 y 32767</li> <li>duraci\u00f3n: valor en \"ticks\" (aproximadamente 18.2 ticks = 1 segundo)</li> </ul> <p>Ejemplos:</p> <pre><code>SOUND 440, 18   ' Nota La (A4) durante aproximadamente 1 segundo\nSOUND 261, 9    ' Nota Do (C4) durante medio segundo\nSOUND 1000, 5   ' Tono de 1000 Hz durante un cuarto de segundo\n</code></pre> <p>Tabla de frecuencias para notas musicales (octava 4):</p> Nota Frecuencia (Hz) C4 (Do) 261.63 D4 (Re) 293.66 E4 (Mi) 329.63 F4 (Fa) 349.23 G4 (Sol) 392.00 A4 (La) 440.00 B4 (Si) 493.88"},{"location":"sonido/#efectos-sonoros-con-sound","title":"Efectos Sonoros con SOUND","text":"<p>Puedes crear diversos efectos de sonido combinando m\u00faltiples llamadas a <code>SOUND</code>:</p> <pre><code>' Efecto de alarma\nFOR i = 1 TO 5\n    SOUND 800, 5\n    FOR delay = 1 TO 500: NEXT delay\n    SOUND 600, 5\n    FOR delay = 1 TO 500: NEXT delay\nNEXT i\n\n' Efecto de sirena\nFOR freq = 500 TO 1500 STEP 50\n    SOUND freq, 1\nNEXT freq\nFOR freq = 1500 TO 500 STEP -50\n    SOUND freq, 1\nNEXT freq\n\n' Explosi\u00f3n\nFOR i = 1 TO 20\n    f = 200 + RND * 800\n    d = 1 + RND * 5\n    SOUND f, d\nNEXT i\n</code></pre>"},{"location":"sonido/#el-comando-play","title":"El Comando PLAY","text":"<p>El comando <code>PLAY</code> es la herramienta m\u00e1s potente en QBasic para crear m\u00fasica. Utiliza una cadena con un lenguaje musical similar a BASIC que permite especificar notas, duraciones, octavas y m\u00e1s.</p>"},{"location":"sonido/#sintaxis-basica","title":"Sintaxis B\u00e1sica","text":"<pre><code>PLAY \"cadena_musical\"\n</code></pre>"},{"location":"sonido/#notas-musicales","title":"Notas Musicales","text":"<p>Las notas se representan con letras de A a G (tambi\u00e9n pueden usarse sus equivalentes en solfeo):</p> <pre><code>PLAY \"CDEFGAB\"   ' Escala de Do a Si\nPLAY \"C D E F G A B\"  ' Los espacios se ignoran\n</code></pre>"},{"location":"sonido/#duraciones-de-notas","title":"Duraciones de Notas","text":"<p>Se especifican con un n\u00famero despu\u00e9s de la nota:</p> <pre><code>PLAY \"C4 D4 E4 F4\"  ' Notas de 1/4 (negras)\nPLAY \"C8 D8 E8 F8\"  ' Notas de 1/8 (corcheas)\nPLAY \"C2 D2\"        ' Notas de 1/2 (blancas)\nPLAY \"C1\"           ' Nota completa (redonda)\n</code></pre> <p>Valores comunes:</p> <ul> <li>1: Redonda</li> <li>2: Blanca</li> <li>4: Negra</li> <li>8: Corchea</li> <li>16: Semicorchea</li> <li>32: Fusa</li> </ul>"},{"location":"sonido/#octavas","title":"Octavas","text":"<p>Puedes cambiar la octava usando \"O\" seguido de un n\u00famero del 0 al 6:</p> <pre><code>PLAY \"O3 C O4 C O5 C\"  ' Do en tres octavas diferentes\n</code></pre> <p>Tambi\u00e9n puedes subir o bajar octavas temporalmente:</p> <pre><code>PLAY \"C &lt; C &lt; C\"  ' Cada \"&lt;\" baja una octava\nPLAY \"C &gt; C &gt; C\"  ' Cada \"&gt;\" sube una octava\n</code></pre>"},{"location":"sonido/#sostenidos-y-bemoles","title":"Sostenidos y Bemoles","text":"<p>Se indican con \"#\" (sostenido) y \"-\" (bemol):</p> <pre><code>PLAY \"C C# D D# E F F# G G# A A# B\"  ' Escala crom\u00e1tica ascendente\nPLAY \"C D- D E- E F G- G A- A B- B\"  ' Otra forma de escala crom\u00e1tica\n</code></pre>"},{"location":"sonido/#tempo","title":"Tempo","text":"<p>Controla la velocidad de reproducci\u00f3n con \"T\" seguido de un n\u00famero entre 32 y 255:</p> <pre><code>PLAY \"T120 CDEFGAB\"  ' Tempo moderado (120 es un valor com\u00fan)\nPLAY \"T200 CDEFGAB\"  ' Tempo m\u00e1s r\u00e1pido\nPLAY \"T60 CDEFGAB\"   ' Tempo m\u00e1s lento\n</code></pre>"},{"location":"sonido/#pausas","title":"Pausas","text":"<p>Las pausas o silencios se indican con \"P\" seguido de la duraci\u00f3n:</p> <pre><code>PLAY \"C4 P4 E4 P4 G4\"  ' Do, pausa, Mi, pausa, Sol\n</code></pre>"},{"location":"sonido/#legato-y-staccato","title":"Legato y Staccato","text":"<ul> <li>\"L\": Conecta las notas (legato)</li> <li>\"N\": Separa las notas (normal) - por defecto</li> <li>\"S\": Notas cortas y separadas (staccato)</li> </ul> <pre><code>PLAY \"L CDEFGAB\"  ' Legato\nPLAY \"N CDEFGAB\"  ' Normal\nPLAY \"S CDEFGAB\"  ' Staccato\n</code></pre>"},{"location":"sonido/#duracion-relativa-y-punto","title":"Duraci\u00f3n Relativa y Punto","text":"<ul> <li>\"MS\" - Establece la duraci\u00f3n predeterminada</li> <li>\".\" - Aumenta la duraci\u00f3n de la nota en un 50% (como el punto en notaci\u00f3n musical)</li> </ul> <pre><code>PLAY \"MS8\"        ' Establece la duraci\u00f3n predeterminada a 1/8\nPLAY \"C D E F\"    ' Todas las notas son corcheas\nPLAY \"C. D. E. F.\"  ' Notas punteadas (50% m\u00e1s largas)\n</code></pre>"},{"location":"sonido/#ejemplos-completos","title":"Ejemplos Completos","text":""},{"location":"sonido/#escala-de-do-mayor","title":"Escala de Do Mayor","text":"<pre><code>PLAY \"T120 O4 C D E F G A B &gt; C\"\n</code></pre>"},{"location":"sonido/#melodia-simple-cumpleanos-feliz","title":"Melod\u00eda Simple (Cumplea\u00f1os Feliz)","text":"<pre><code>PLAY \"T120 O4 C8 C8 D4 C4 F4 E4\"\nPLAY \"C8 C8 D4 C4 G4 F4\"\nPLAY \"C8 C8 &gt; C4 A4 F4 E4 D4\"\nPLAY \"A#8 A#8 A4 F4 G4 F4\"\n</code></pre>"},{"location":"sonido/#melodia-con-variables","title":"Melod\u00eda con Variables","text":"<p>Puedes combinar varias cadenas musicales, incluso utilizando variables:</p> <pre><code>parte1$ = \"T120 O4 C8 E8 G4\"\nparte2$ = \"E8 G8 &gt; C4\"\nPLAY parte1$ + parte2$\n</code></pre>"},{"location":"sonido/#tecnicas-avanzadas","title":"T\u00e9cnicas Avanzadas","text":""},{"location":"sonido/#reproduccion-de-varias-voces","title":"Reproducci\u00f3n de Varias Voces","text":"<p>QBasic permite tocar hasta 3 voces simult\u00e1neamente usando \"MB\" (m\u00fasica en segundo plano):</p> <pre><code>PLAY \"MB T120 O4 C4 E4 G4 &gt; C2\"  ' Inicia reproducci\u00f3n en segundo plano\nPLAY \"MB O3 E4 G4 B4 &gt; E2\"       ' Segunda voz (simult\u00e1nea)\nPLAY \"O3 G4 B4 &gt; D4 G2\"          ' Tercera voz y espera a que todo termine\n</code></pre>"},{"location":"sonido/#creacion-de-una-biblioteca-de-sonidos","title":"Creaci\u00f3n de una Biblioteca de Sonidos","text":"<pre><code>' Biblioteca de efectos de sonido\nSUB EfectoExplosion\n    FOR i = 1 TO 20\n        SOUND 100 + RND * 200, 1\n    NEXT i\n    FOR i = 1 TO 10\n        SOUND 75 + RND * 100, 2\n    NEXT i\nEND SUB\n\nSUB EfectoLaser\n    FOR f = 800 TO 2000 STEP 200\n        SOUND f, 1\n    NEXT f\nEND SUB\n\nSUB EfectoPowerUp\n    FOR f = 200 TO 800 STEP 20\n        SOUND f, 1\n    NEXT f\nEND SUB\n</code></pre>"},{"location":"sonido/#integracion-de-sonido-en-juegos","title":"Integraci\u00f3n de Sonido en Juegos","text":"<pre><code>' Ejemplo: Integraci\u00f3n de sonido en un juego simple\nDO\n    k$ = INKEY$\n    SELECT CASE k$\n        CASE CHR$(32)  ' Espacio - disparo\n            EfectoLaser\n        CASE \"x\", \"X\"  ' X - explosi\u00f3n\n            EfectoExplosion\n        CASE \"p\", \"P\"  ' P - power-up\n            EfectoPowerUp\n        CASE CHR$(27)  ' ESC - salir\n            EXIT DO\n    END SELECT\nLOOP\n</code></pre>"},{"location":"sonido/#limitaciones-y-soluciones","title":"Limitaciones y Soluciones","text":""},{"location":"sonido/#limitaciones-del-altavoz-del-pc","title":"Limitaciones del Altavoz del PC","text":"<ul> <li>Sonido monof\u00f3nico (una frecuencia a la vez por canal)</li> <li>Calidad de sonido limitada</li> <li>Sin control de volumen</li> </ul>"},{"location":"sonido/#soluciones-y-alternativas","title":"Soluciones y Alternativas","text":"<ol> <li>Tarjetas de Sonido: Algunas versiones extendidas de QBasic permiten acceso a tarjetas de sonido para mejor calidad</li> <li>QB64: Esta versi\u00f3n moderna de QBasic ofrece capacidades de sonido avanzadas, incluyendo reproducci\u00f3n de archivos WAV y MP3</li> <li>Librer\u00edas Externas: Para QBasic original, exist\u00edan librer\u00edas de terceros que permit\u00edan acceso a hardware de sonido avanzado</li> </ol>"},{"location":"sonido/#recursos-y-referencias","title":"Recursos y Referencias","text":"<p>Para profundizar en programaci\u00f3n de sonido en QBasic:</p> <ol> <li>Experimenta con el comando PLAY para crear tus propias melod\u00edas</li> <li>Estudia partituras simples y convi\u00e9rtelas a notaci\u00f3n de QBasic</li> <li>Analiza ejemplos de juegos que usan efectos de sonido</li> </ol> <p>El sonido es un componente esencial para crear aplicaciones y juegos atractivos, incluso con las limitaciones del hardware de la \u00e9poca de QBasic.</p>"},{"location":"tecnicas/","title":"T\u00e9cnicas","text":"<p>Programaci\u00f3n estructurada, modularidad, comentarios.</p>"},{"location":"tecnicas/#tecnicas-graficas-avanzadas","title":"T\u00e9cnicas Gr\u00e1ficas Avanzadas","text":"<p>Esta secci\u00f3n cubre t\u00e9cnicas avanzadas para manipular gr\u00e1ficos en QBasic, basadas en los tutoriales de Damian Nikodem (\"Hacker\").</p>"},{"location":"tecnicas/#manipulacion-de-la-paleta","title":"Manipulaci\u00f3n de la Paleta","text":"<p>La paleta en QBasic es una serie de n\u00fameros donde se almacenan los valores de los colores. Al modificar la paleta, puedes cambiar los colores de una imagen sin alterar su estructura.</p> <p>Para manipular la paleta, se utilizan comandos de entrada/salida directos al hardware:</p> <pre><code>' Cambiar un color en la paleta\nOUT &amp;H3C8, color     ' Seleccionar el color a modificar (0-255)\nOUT &amp;H3C9, rojo      ' Componente rojo (0-63)\nOUT &amp;H3C9, verde     ' Componente verde (0-63)\nOUT &amp;H3C9, azul      ' Componente azul (0-63)\n</code></pre> <p>Los valores de cada componente de color (rojo, verde, azul) deben estar entre 0 y 63.</p> <p>Para guardar y cargar paletas desde archivos, puedes utilizar las siguientes subrutinas:</p> <pre><code>SUB guardarPaleta (archivo$)\n  OPEN archivo$ FOR OUTPUT AS #1\n  FOR x% = 0 TO 255\n    CALL obtenerColor(x%, r%, g%, b%)\n    PRINT #1, CHR$(r%); CHR$(g%); CHR$(b%);\n  NEXT x%\n  CLOSE #1\nEND SUB\n\nSUB obtenerColor (Color%, Rojo%, Verde%, Azul%)\n  OUT &amp;H3C7, Color%\n  Rojo% = INP(&amp;H3C9)\n  Verde% = INP(&amp;H3C9)\n  Azul% = INP(&amp;H3C9)\nEND SUB\n\nSUB cargarPaleta (archivo$)\n  OPEN archivo$ FOR BINARY AS #1\n  r$ = \" \"\n  g$ = \" \"\n  b$ = \" \"\n  FOR x% = 0 TO 255\n    GET #1, , r$: r% = ASC(r$)\n    GET #1, , g$: g% = ASC(g$)\n    GET #1, , b$: b% = ASC(b$)\n    CALL cambiarColor(x%, r%, g%, b%)\n  NEXT x%\n  CLOSE #1\nEND SUB\n\nSUB cambiarColor (Color%, Rojo%, Verde%, Azul%)\n  OUT &amp;H3C8, Color%\n  OUT &amp;H3C9, Rojo%\n  OUT &amp;H3C9, Verde%\n  OUT &amp;H3C9, Azul%\nEND SUB\n</code></pre>"},{"location":"tecnicas/#graficos-rapidos-con-acceso-directo-a-memoria","title":"Gr\u00e1ficos R\u00e1pidos con Acceso Directo a Memoria","text":"<p>PSET es un comando relativamente lento para dibujar p\u00edxeles. Una alternativa mucho m\u00e1s r\u00e1pida es escribir directamente en la memoria de v\u00eddeo:</p> <pre><code>SCREEN 13           ' Modo gr\u00e1fico 320x200 con 256 colores\nDEF SEG = &amp;HA000    ' Apuntar al segmento de memoria de v\u00eddeo\nx = 10              ' Posici\u00f3n X del p\u00edxel\ny = 10              ' Posici\u00f3n Y del p\u00edxel\ncolor = 30          ' Color del p\u00edxel\nPOKE (y * 320) + x, color  ' Colocar el p\u00edxel en la pantalla\n</code></pre> <p>El c\u00e1lculo <code>(y * 320) + x</code> determina la posici\u00f3n exacta en la memoria de v\u00eddeo. En el modo 13h (SCREEN 13), cada l\u00ednea tiene 320 p\u00edxeles, por lo que multiplicamos la coordenada Y por 320 para determinar la l\u00ednea, y luego sumamos X para determinar la columna.</p>"},{"location":"tecnicas/#cargar-imagenes-pcx","title":"Cargar Im\u00e1genes PCX","text":"<p>Las im\u00e1genes PCX son un formato com\u00fan en la \u00e9poca de DOS. Para cargar una imagen PCX en QBasic, necesitamos manejar:</p> <ol> <li>La cabecera: Contiene informaci\u00f3n sobre la imagen, como dimensiones</li> <li>Los datos de la imagen: Comprimidos usando un esquema sencillo</li> <li>La paleta: Almacenada al final del archivo</li> </ol> <p>Este es un ejemplo simplificado para cargar im\u00e1genes PCX de 320x200 directamente a la memoria de v\u00eddeo:</p> <pre><code>SUB cargarPCX (archivo$)\n  OPEN archivo$ FOR BINARY AS #1\n\n  ' Saltar la cabecera de 128 bytes\n  SEEK #1, 129\n\n  DEF SEG = &amp;HA000\n  dirMem = 0\n\n  DO UNTIL EOF(1) OR dirMem &gt;= 64000  ' 320x200 = 64000 bytes\n    GET #1, , dato$\n    datoByte = ASC(dato$)\n\n    ' Comprobar si es un byte de compresi\u00f3n\n    IF datoByte &gt;= 192 AND datoByte &lt;= 255 THEN\n      ' Obtener el contador de repetici\u00f3n\n      contador = datoByte - 192\n\n      ' Obtener el byte a repetir\n      GET #1, , dato$\n      repetir = ASC(dato$)\n\n      ' Repetir el byte en memoria\n      FOR i = 1 TO contador\n        POKE dirMem, repetir\n        dirMem = dirMem + 1\n      NEXT i\n    ELSE\n      ' Byte sin comprimir\n      POKE dirMem, datoByte\n      dirMem = dirMem + 1\n    END IF\n  LOOP\n\n  ' Cargar la paleta (los \u00faltimos 768 bytes)\n  ' Si queda suficiente espacio en el archivo\n  IF LOF(1) - 768 &gt; 0 THEN\n    SEEK #1, LOF(1) - 768 + 1\n\n    FOR color = 0 TO 255\n      GET #1, , r$: r = ASC(r$)\n      GET #1, , g$: g = ASC(g$)\n      GET #1, , b$: b = ASC(b$)\n\n      ' Escalar valores de 0-255 a 0-63 para QBasic\n      cambiarColor color, r \\ 4, g \\ 4, b \\ 4\n    NEXT color\n  END IF\n\n  CLOSE #1\nEND SUB\n</code></pre>"},{"location":"tecnicas/#carga-de-archivos-bmp","title":"Carga de Archivos BMP","text":"<p>Los archivos BMP son uno de los formatos de imagen m\u00e1s simples ya que no utilizan compresi\u00f3n. Esto los hace ideales para trabajar con ellos directamente en QBasic.</p> <p>Un archivo BMP t\u00edpico tiene una cabecera de 1078 bytes que contiene informaci\u00f3n esencial como las dimensiones de la imagen, la profundidad de color y la paleta. Podemos definir esta estructura utilizando el tipo de datos <code>TYPE</code> de QBasic:</p> <pre><code>TYPE BMPHeaderType       \n    id AS STRING * 2      ' Debe ser \"BM\"\n    size AS LONG          ' Tama\u00f1o de los datos\n    rr1 AS INTEGER        ' Reservado\n    rr2 AS INTEGER        ' Reservado\n    offset AS LONG        ' Posici\u00f3n del inicio de los datos de p\u00edxeles\n    horz AS LONG          ' Reservado\n    wid AS LONG           ' Ancho de la imagen\n    hei AS LONG           ' Alto de la imagen\n    planes AS INTEGER     ' Planos de color\n    bpp AS INTEGER        ' Bits por p\u00edxel (8 para una imagen de 256 colores)\n    pakbyte AS LONG       ' Compresi\u00f3n\n    imagebytes AS LONG    ' Ancho*Alto\n    xres AS LONG          ' Resoluci\u00f3n X\n    yres AS LONG          ' Resoluci\u00f3n Y\n    colch AS LONG         ' Colores utilizados\n    ic AS LONG            ' Colores importantes\n    pal AS STRING * 1024  ' Paleta almacenada como &lt;Azul, Verde, Rojo, 0&gt;\nEND TYPE\n</code></pre>"},{"location":"tecnicas/#cargando-la-cabecera-bmp","title":"Cargando la cabecera BMP","text":"<p>Para cargar un archivo BMP, primero debemos abrir el archivo en modo binario y leer la cabecera:</p> <pre><code>DIM BmpHeader AS BMPHeaderType\n\nOPEN \"imagen.bmp\" FOR BINARY AS #1\nGET #1, , BmpHeader\n\n' Verificar que es un archivo BMP v\u00e1lido\nIF BmpHeader.id &lt;&gt; \"BM\" THEN\n    PRINT \"No es un archivo BMP v\u00e1lido\"\n    CLOSE #1\n    END\nEND IF\n</code></pre>"},{"location":"tecnicas/#configurando-la-paleta","title":"Configurando la paleta","text":"<p>Antes de mostrar la imagen, necesitamos establecer la paleta de colores:</p> <pre><code>SCREEN 13                           ' Modo gr\u00e1fico 320x200, 256 colores\n\na$ = BmpHeader.pal                  ' La paleta se almacena en un string de 1024 caracteres\n\nOUT &amp;H3C8, 0                        ' Comenzar a escribir desde el Color 0\nFOR i% = 1 TO 1024 STEP 4\n    b% = ASC(MID$(a$, i%, 1)) \\ 4   ' Azul (dividido por 4 para convertir de 0-255 a 0-63)\n    g% = ASC(MID$(a$, i% + 1, 1)) \\ 4 ' Verde\n    r% = ASC(MID$(a$, i% + 2, 1)) \\ 4 ' Rojo\n                                    ' i% + 3 es cero (no se utiliza)\n    OUT &amp;H3C9, r%                   ' Establecer el color\n    OUT &amp;H3C9, g%\n    OUT &amp;H3C9, b%\nNEXT\n</code></pre>"},{"location":"tecnicas/#mostrando-la-imagen","title":"Mostrando la imagen","text":"<p>Una particularidad de los archivos BMP es que las im\u00e1genes se almacenan invertidas verticalmente. Por eso, al leer los p\u00edxeles, debemos recorrer las filas de abajo hacia arriba:</p> <pre><code>' M\u00e9todo b\u00e1sico (lento) - un p\u00edxel a la vez\nDIM Pixel AS STRING * 1              ' Nuestro \"byte\" de p\u00edxel\niHeight% = BmpHeader.hei - 1         ' Restar 1 para la posici\u00f3n real en pantalla\niWidth% = BmpHeader.wid - 1\n\nFOR y% = iHeight% TO 0 STEP -1       ' Cuenta regresiva para la imagen invertida\n    FOR x% = 0 TO iWidth%\n        GET #1, , Pixel              ' Leer un p\u00edxel (byte)\n        PSET (x%, y%), ASC(Pixel)    ' Dibujar el p\u00edxel\n    NEXT x%\nNEXT y%\n</code></pre>"},{"location":"tecnicas/#optimizacion-para-mayor-velocidad","title":"Optimizaci\u00f3n para mayor velocidad","text":"<p>El m\u00e9todo anterior funciona, pero es muy lento. Podemos mejorar significativamente el rendimiento leyendo una l\u00ednea completa de p\u00edxeles a la vez:</p> <pre><code>' M\u00e9todo optimizado - una l\u00ednea a la vez\nPixel$ = SPACE$(BmpHeader.wid)      ' Crear un buffer para una l\u00ednea completa\n\niHeight% = BmpHeader.hei - 1\niWidth% = BmpHeader.wid - 1\n\nFOR y% = iHeight% TO 0 STEP -1\n    GET #1, , Pixel$                ' Leer una l\u00ednea completa de una vez\n\n    FOR x% = 0 TO iWidth%\n        PSET (x%, y%), ASC(MID$(Pixel$, x% + 1, 1))\n    NEXT x%\nNEXT y%\n</code></pre> <p>Esta optimizaci\u00f3n puede hacer que la carga de im\u00e1genes sea hasta 8 veces m\u00e1s r\u00e1pida, especialmente en computadoras m\u00e1s lentas.</p>"},{"location":"tecnicas/#metodo-ultra-rapido-con-acceso-directo-a-memoria","title":"M\u00e9todo ultra-r\u00e1pido con acceso directo a memoria","text":"<p>Para una velocidad a\u00fan mayor, se puede copiar directamente los datos de la imagen a la memoria de v\u00eddeo. Esto requiere conocimientos sobre interrupciones DOS y acceso directo a la memoria, pero ofrece el mejor rendimiento posible:</p> <pre><code>' M\u00e9todo ultra-r\u00e1pido con acceso directo a memoria\nDECLARE SUB InterruptX (intnum AS INTEGER, inreg AS RegTypeX, outreg AS RegTypeX)\n\nTYPE RegTypeX\n    ax    AS INTEGER\n    bx    AS INTEGER\n    cx    AS INTEGER\n    dx    AS INTEGER\n    bp    AS INTEGER\n    si    AS INTEGER\n    di    AS INTEGER\n    flags AS INTEGER\n    ds    AS INTEGER\n    es    AS INTEGER\nEND TYPE\n\nDIM inregs AS RegTypeX, outregs AS RegTypeX\nPixel$ = SPACE$(BmpHeader.wid)\n\nDEF SEG = &amp;HA000                    ' Segmento de memoria de v\u00eddeo\niHeight% = BmpHeader.hei - 1\n\nFOR y% = iHeight% TO 0 STEP -1\n    offset% = y% * 320              ' Calcular posici\u00f3n en la memoria de v\u00eddeo\n\n    ' Configurar registros para INT 21h (DOS), funci\u00f3n 3Fh (Leer desde archivo)\n    inregs.ax = &amp;H3F00              ' Funci\u00f3n 3Fh\n    inregs.bx = FREEFILE            ' Handle del archivo\n    inregs.cx = BmpHeader.wid       ' N\u00famero de bytes a leer\n    inregs.dx = offset%             ' Offset en memoria donde escribir\n    inregs.ds = &amp;HA000              ' Segmento de memoria\n\n    ' Llamar a la interrupci\u00f3n DOS\n    InterruptX &amp;H21, inregs, outregs\nNEXT y%\n</code></pre> <p>Este \u00faltimo m\u00e9todo es el m\u00e1s r\u00e1pido, pero requiere una comprensi\u00f3n avanzada de interrupciones y memoria en DOS.</p>"},{"location":"tecnicas/#algoritmos-aleatorios-para-graficos-realistas","title":"Algoritmos Aleatorios para Gr\u00e1ficos Realistas","text":"<p>Los algoritmos aleatorios pueden dar un aspecto m\u00e1s natural y realista a tus gr\u00e1ficos. Por ejemplo, para crear una textura de c\u00e9sped:</p> <pre><code>SCREEN 13\nRANDOMIZE TIMER\n\n' Crear una textura de c\u00e9sped de 15x15 p\u00edxeles\nFOR x = 1 TO 15\n  FOR y = 1 TO 15\n    ' Elegir entre diferentes tonos de verde y marr\u00f3n\n    z = INT(RND * 8) + 1\n    color = z + 186  ' Colores 187-194 (ajustar seg\u00fan la paleta)\n\n    PSET (x, y), color\n  NEXT y\nNEXT x\n</code></pre> <p>Este enfoque a\u00f1ade variaci\u00f3n y sutileza a tus gr\u00e1ficos. Puedes aplicar t\u00e9cnicas similares para crear:</p> <ul> <li>Texturas de terreno (tierra, arena, roca)</li> <li>Efectos de cielo y nubes</li> <li>Efectos de luz y sombra</li> <li>Degradados con transiciones naturales</li> </ul>"},{"location":"tecnicas/#consejos-para-mejorar-los-graficos","title":"Consejos para Mejorar los Gr\u00e1ficos","text":"<ol> <li> <p>Usa paletas personalizadas: Crea paletas espec\u00edficas para tus escenas para obtener colores m\u00e1s realistas.</p> </li> <li> <p>Combina t\u00e9cnicas de acceso directo a memoria con algoritmos aleatorios para gr\u00e1ficos r\u00e1pidos y naturales.</p> </li> <li> <p>Simula profundidad utilizando variaciones de color y gradientes sutiles.</p> </li> <li> <p>Estudia im\u00e1genes reales para entender c\u00f3mo la aleatoriedad afecta a las texturas naturales.</p> </li> <li> <p>Optimiza tus rutinas gr\u00e1ficas para mantener un rendimiento aceptable, especialmente en bucles anidados.</p> </li> </ol>"},{"location":"tecnicas/#tecnicas-de-programacion-3d","title":"T\u00e9cnicas de Programaci\u00f3n 3D","text":"<p>Esta secci\u00f3n explora los conceptos b\u00e1sicos para crear gr\u00e1ficos tridimensionales en QBasic, basada en el trabajo de Aaron Severn.</p>"},{"location":"tecnicas/#conceptos-basicos-del-espacio-3d","title":"Conceptos B\u00e1sicos del Espacio 3D","text":"<p>Para programar en 3D, es fundamental comprender c\u00f3mo representar el espacio tridimensional. En un sistema de coordenadas 3D tenemos:</p> <ul> <li>Eje X: Representa el movimiento horizontal (izquierda/derecha)</li> <li>Eje Y: Representa el movimiento vertical (arriba/abajo)</li> <li>Eje Z: Representa la profundidad (cerca/lejos)</li> </ul> <p>En la programaci\u00f3n 3D b\u00e1sica, usamos esta representaci\u00f3n gr\u00e1fica del espacio:</p> <pre><code>                 Z             Donde Y es el eje horizontal\n                 |                   Z es el eje vertical\n                 |                   X es el eje que sale de la pantalla\n                 |\u03c6\n                 |_______            \u03b8 es el \u00e1ngulo en el plano XY\n                 /       Y           \u03c6 es el \u00e1ngulo desde el eje Z\n                / \u03b8 \n               / \n              /\n             X\n</code></pre>"},{"location":"tecnicas/#proyeccion-3d-a-2d","title":"Proyecci\u00f3n 3D a 2D","text":"<p>El principal desaf\u00edo de la programaci\u00f3n 3D es representar un objeto tridimensional en una pantalla bidimensional. La t\u00e9cnica b\u00e1sica consiste en dividir las coordenadas por la distancia al observador (valor Z), creando as\u00ed un efecto de perspectiva.</p> <p>Las f\u00f3rmulas para convertir coordenadas 3D a 2D son:</p> <pre><code>x2D = 256 * (x3D / (z3D + zCentro)) + xCentro\ny2D = 256 * (y3D / (z3D + zCentro)) + yCentro\n</code></pre> <p>Donde:</p> <ul> <li><code>(x2D, y2D)</code> es el punto a dibujar en la pantalla</li> <li><code>(x3D, y3D, z3D)</code> es el punto en el espacio 3D</li> <li><code>xCentro</code> y <code>yCentro</code> representan el centro de la pantalla (generalmente 160,100 en modo 13h)</li> <li><code>zCentro</code> representa la distancia del observador (generalmente 256)</li> </ul> <p>El valor 256 en las ecuaciones ajusta la escala para obtener un tama\u00f1o adecuado en pantalla.</p>"},{"location":"tecnicas/#rotaciones-3d","title":"Rotaciones 3D","text":"<p>Para rotar objetos en el espacio 3D, necesitamos aplicar transformaciones matem\u00e1ticas a cada punto. Estas transformaciones utilizan funciones trigonom\u00e9tricas para calcular las nuevas posiciones.</p> <p>Las f\u00f3rmulas para rotar un punto en 3D son:</p> <pre><code>xR = -xO * SIN(\u03b8) + yO * COS(\u03b8)\nyR = -xO * COS(\u03b8) * SIN(\u03c6) - yO * SIN(\u03b8) * SIN(\u03c6) - zO * COS(\u03c6) + p\nzR = -xO * COS(\u03b8) * COS(\u03c6) - yO * SIN(\u03b8) * COS(\u03c6) + zO * SIN(\u03c6)\n</code></pre> <p>Donde:</p> <ul> <li><code>(xO, yO, zO)</code> son las coordenadas originales del punto</li> <li><code>(xR, yR, zR)</code> son las coordenadas rotadas</li> <li><code>\u03b8</code> (theta) es el \u00e1ngulo de rotaci\u00f3n en el plano XY</li> <li><code>\u03c6</code> (phi) es el \u00e1ngulo desde el eje Z</li> <li><code>p</code> es la distancia desde el centro del objeto (generalmente 1 para puntos en la superficie)</li> </ul>"},{"location":"tecnicas/#optimizacion-con-tablas-trigonometricas","title":"Optimizaci\u00f3n con Tablas Trigonom\u00e9tricas","text":"<p>Las operaciones trigonom\u00e9tricas son costosas en t\u00e9rminos de tiempo de procesamiento. Para optimizar, se recomienda crear tablas de senos y cosenos precalculados:</p> <pre><code>CONST PI = 3.141592\nDIM s!(359)   ' Tabla de senos\nDIM c!(359)   ' Tabla de cosenos\n\nFOR i = 0 TO 359\n   s!(i) = SIN(i * (PI / 180))\n   c!(i) = COS(i * (PI / 180))\nNEXT\n</code></pre> <p>Luego, en lugar de calcular <code>SIN(angulo)</code> y <code>COS(angulo)</code> cada vez, simplemente usamos <code>s!(angulo)</code> y <code>c!(angulo)</code>.</p>"},{"location":"tecnicas/#estructura-de-datos-para-objetos-3d","title":"Estructura de Datos para Objetos 3D","text":"<p>Para representar objetos 3D, es \u00fatil definir una estructura que contenga las coordenadas de cada punto:</p> <pre><code>TYPE punto3D\n    x AS INTEGER    ' Coordenada X\n    y AS INTEGER    ' Coordenada Y\n    z AS INTEGER    ' Coordenada Z\n    p AS INTEGER    ' Distancia desde el centro del objeto\nEND TYPE\n</code></pre>"},{"location":"tecnicas/#ejemplo-de-cubo-rotando-en-3d","title":"Ejemplo de Cubo Rotando en 3D","text":"<p>A continuaci\u00f3n se presenta un ejemplo simplificado de un cubo rotando en 3D:</p> <pre><code>DEFINT A-Z\n\n' Definir tipo para puntos 3D\nTYPE pnt\n    x AS INTEGER        ' Coordenada X\n    y AS INTEGER        ' Coordenada Y\n    z AS INTEGER        ' Coordenada Z\n    p AS INTEGER        ' Distancia desde centro\nEND TYPE\n\n' N\u00famero de l\u00edneas para dibujar el cubo\nnumLineas = 11  ' 0 a 11 = 12 l\u00edneas\n\n' Arreglos para almacenar coordenadas\nDIM lO(numLineas, 1) AS pnt      ' Coordenadas originales\nDIM lR(numLineas, 1) AS pnt      ' Coordenadas rotadas\nDIM scrX(numLineas, 1)           ' Coordenada X en pantalla\nDIM scrY(numLineas, 1)           ' Coordenada Y en pantalla\nDIM oldX(numLineas, 1)           ' Coordenada X anterior (para borrar)\nDIM oldY(numLineas, 1)           ' Coordenada Y anterior (para borrar)\n\n' Tablas trigonom\u00e9tricas precalculadas\nDIM s!(359)\nDIM c!(359)\nCONST PI = 3.141592\n\n' Crear tablas de seno y coseno\nFOR i = 0 TO 359\n   s!(i) = SIN(i * (PI / 180))\n   c!(i) = COS(i * (PI / 180))\nNEXT\n\n' Leer coordenadas del cubo (definidas al final)\nFOR i = 0 TO numLineas\n   READ lO(i, 0).x, lO(i, 0).y, lO(i, 0).z, lO(i, 0).p\n   READ lO(i, 1).x, lO(i, 1).y, lO(i, 1).z, lO(i, 1).p\nNEXT\n\n' Configurar modo gr\u00e1fico\nSCREEN 13\nCLS\n\n' Configurar par\u00e1metros iniciales\nxCentro = 160: yCentro = 100: zCentro = 256\ntheta = 0: phi = 0\nthetaRot = 2: phiRot = 2\n\njustStarted = 1\nDO\n  ' Para cada l\u00ednea del cubo\n  FOR i = 0 TO numLineas\n     ' Guardar valores anteriores para borrado\n     oldX(i, 0) = scrX(i, 0): oldY(i, 0) = scrY(i, 0)\n     oldX(i, 1) = scrX(i, 1): oldY(i, 1) = scrY(i, 1)\n\n     ' Rotar ambos puntos de cada l\u00ednea\n     lR(i, 0).x = -lO(i, 0).x * s!(theta) + lO(i, 0).y * c!(theta)\n     lR(i, 0).y = -lO(i, 0).x * c!(theta) * s!(phi) - lO(i, 0).y * s!(theta) * s!(phi) - lO(i, 0).z * c!(phi) + lO(i, 0).p\n     lR(i, 0).z = -lO(i, 0).x * c!(theta) * c!(phi) - lO(i, 0).y * s!(theta) * c!(phi) + lO(i, 0).z * s!(phi)\n\n     lR(i, 1).x = -lO(i, 1).x * s!(theta) + lO(i, 1).y * c!(theta)\n     lR(i, 1).y = -lO(i, 1).x * c!(theta) * s!(phi) - lO(i, 1).y * s!(theta) * s!(phi) - lO(i, 1).z * c!(phi) + lO(i, 1).p\n     lR(i, 1).z = -lO(i, 1).x * c!(theta) * c!(phi) - lO(i, 1).y * s!(theta) * c!(phi) + lO(i, 1).z * s!(phi)\n\n     ' Convertir de 3D a 2D\n     IF (lR(i, 0).z + zCentro) &lt;&gt; 0 THEN\n       scrX(i, 0) = 256 * (lR(i, 0).x / (lR(i, 0).z + zCentro)) + xCentro\n       scrY(i, 0) = 256 * (lR(i, 0).y / (lR(i, 0).z + zCentro)) + yCentro\n     END IF\n\n     IF (lR(i, 1).z + zCentro) &lt;&gt; 0 THEN\n       scrX(i, 1) = 256 * (lR(i, 1).x / (lR(i, 1).z + zCentro)) + xCentro\n       scrY(i, 1) = 256 * (lR(i, 1).y / (lR(i, 1).z + zCentro)) + yCentro\n     END IF\n  NEXT i\n\n  ' Borrar l\u00edneas anteriores\n  WAIT &amp;H3DA, 8  ' Sincronizar con refresco vertical para evitar parpadeo\n  IF justStarted = 0 THEN\n    FOR i = 0 TO numLineas\n       LINE (oldX(i, 0), oldY(i, 0))-(oldX(i, 1), oldY(i, 1)), 0\n    NEXT i\n  END IF\n\n  ' Dibujar nuevas l\u00edneas\n  FOR i = 0 TO numLineas\n     LINE (scrX(i, 0), scrY(i, 0))-(scrX(i, 1), scrY(i, 1)), 11\n  NEXT i\n\n  ' Actualizar \u00e1ngulos para siguiente fotograma\n  theta = (theta + thetaRot) MOD 360\n  phi = (phi + phiRot) MOD 360\n\n  justStarted = 0\nLOOP UNTIL INKEY$ = CHR$(27)  ' Salir con ESC\n\n' Datos para las l\u00edneas del cubo: formato (X1,Y1,Z1,p1, X2,Y2,Z2,p2)\nDATA -50,50,50,1,50,50,50,1\nDATA 50,-50,50,1,50,50,50,1\nDATA 50,50,-50,1,50,50,50,1\nDATA -50,-50,50,1,-50,50,50,1\nDATA -50,50,-50,1,-50,50,50,1\nDATA -50,-50,50,1,50,-50,50,1\nDATA -50,50,-50,1,50,50,-50,1\nDATA -50,-50,-50,1,50,-50,-50,1\nDATA -50,-50,-50,1,-50,50,-50,1\nDATA 50,-50,-50,1,50,-50,50,1\nDATA 50,-50,-50,1,50,50,-50,1\nDATA -50,-50,-50,1,-50,-50,50,1\n</code></pre>"},{"location":"tecnicas/#consejos-para-mejorar-los-graficos-3d","title":"Consejos para Mejorar los Gr\u00e1ficos 3D","text":"<ol> <li> <p>Utiliza sincronizaci\u00f3n vertical (WAIT &amp;H3DA, 8) para evitar parpadeos al redibujar objetos 3D.</p> </li> <li> <p>Implementa la eliminaci\u00f3n de caras ocultas para que los objetos s\u00f3lidos se vean m\u00e1s realistas.</p> </li> <li> <p>Utiliza tablas precalculadas para todas las operaciones trigonom\u00e9tricas para mejorar significativamente el rendimiento.</p> </li> <li> <p>Aumenta la complejidad gradualmente, empezando con objetos simples como cubos antes de pasar a geometr\u00eda m\u00e1s compleja.</p> </li> <li> <p>Considera usar t\u00e9cnicas de doble b\u00fafer para lograr animaciones m\u00e1s suaves y sin parpadeos.</p> </li> <li> <p>A\u00f1ade iluminaci\u00f3n simple calculando el \u00e1ngulo entre una superficie y una fuente de luz ficticia para sombrear objetos 3D.</p> </li> </ol>"}]}